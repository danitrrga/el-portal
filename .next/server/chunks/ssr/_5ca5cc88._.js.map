{"version":3,"sources":["../../../../node_modules/next/src/shared/lib/router/utils/querystring.ts","../../../../node_modules/next/src/shared/lib/router/utils/format-url.ts","../../../../node_modules/next/src/client/use-merged-ref.ts","../../../../node_modules/next/src/shared/lib/utils.ts","../../../../node_modules/next/src/shared/lib/router/utils/parse-path.ts","../../../../node_modules/next/src/shared/lib/router/utils/add-path-prefix.ts","../../../../node_modules/next/src/shared/lib/router/utils/remove-trailing-slash.ts","../../../../node_modules/next/src/client/normalize-trailing-slash.ts","../../../../node_modules/next/src/client/add-base-path.ts","../../../../node_modules/next/src/shared/lib/utils/warn-once.ts","../../../../node_modules/next/src/client/components/segment-cache/types.ts","../../../../node_modules/next/src/client/components/segment-cache/cache-key.ts","../../../../node_modules/next/src/shared/lib/app-router-types.ts","../../../../node_modules/next/src/client/components/match-segments.ts","../../../../node_modules/next/src/shared/lib/segment-cache/vary-params-decoding.ts","../../../../node_modules/next/src/client/components/app-router-headers.ts","../../../../node_modules/next/src/client/components/router-reducer/router-reducer-types.ts","../../../../node_modules/next/src/shared/lib/is-thenable.ts","../../../../node_modules/next/src/client/components/use-action-queue.ts","../../../../node_modules/next/src/client/app-call-server.ts","../../../../node_modules/next/src/client/app-find-source-map-url.ts","../../../../node_modules/next/src/shared/lib/segment-cache/segment-value-encoding.ts","../../../../node_modules/next/src/client/route-params.ts","../../../../node_modules/next/src/client/components/router-reducer/create-href-from-url.ts","../../../../node_modules/next/src/client/flight-data-helpers.ts","../../../../node_modules/next/src/client/app-build-id.ts","../../../../node_modules/next/src/shared/lib/hash.ts","../../../../node_modules/next/src/shared/lib/router/utils/cache-busting-search-param.ts","../../../../node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts","../../../../node_modules/next/src/shared/lib/deployment-id.ts","../../../../node_modules/next/src/client/components/router-reducer/fetch-server-response.ts","../../../../node_modules/next/src/client/components/segment-cache/lru.ts","../../../../node_modules/next/src/client/components/segment-cache/cache-map.ts","../../../../node_modules/next/src/client/components/segment-cache/vary-path.ts","../../../../node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts","../../../../node_modules/next/src/client/components/segment-cache/optimistic-routes.ts","../../../../node_modules/next/src/client/components/segment-cache/bfcache.ts","../../../../node_modules/next/src/client/components/router-reducer/ppr-navigations.ts","../../../../node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts","../../../../node_modules/next/src/shared/lib/router/utils/app-paths.ts","../../../../node_modules/next/src/shared/lib/router/utils/interception-routes.ts","../../../../node_modules/next/src/client/components/router-reducer/compute-changed-path.ts","../../../../node_modules/next/src/client/lib/javascript-url.ts","../../../../node_modules/next/src/client/components/segment-cache/navigation.ts","../../../../node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts","../../../../node_modules/next/src/shared/lib/promise-with-resolvers.ts","../../../../node_modules/next/src/client/components/segment-cache/cache.ts","../../../../node_modules/next/src/client/components/segment-cache/scheduler.ts","../../../../node_modules/next/src/client/components/links.ts","../../../../node_modules/next/src/shared/lib/router/utils/path-has-prefix.ts","../../../../node_modules/next/src/client/has-base-path.ts","../../../../node_modules/next/src/shared/lib/router/utils/is-local-url.ts","../../../../node_modules/next/src/shared/lib/utils/error-once.ts","../../../../node_modules/next/src/client/app-dir/link.tsx","../../../../src/app/%28portal%29/layout.tsx","../../../../src/components/Layout.tsx","../../../../src/components/PortalEntry.tsx","../../../../src/components/TempoSettingsModal.tsx","../../../../node_modules/lucide-react/src/icons/layout-dashboard.ts","../../../../node_modules/lucide-react/src/icons/moon.ts","../../../../node_modules/lucide-react/src/icons/pencil.ts","../../../../node_modules/lucide-react/src/icons/loader-2.ts","../../../../node_modules/lucide-react/src/icons/sun.ts","../../../../node_modules/lucide-react/src/icons/mail.ts","../../../../node_modules/lucide-react/src/icons/lock.ts","../../../../node_modules/lucide-react/src/icons/log-out.ts","../../../../node_modules/lucide-react/src/icons/panel-left.ts","../../../../src/components/AccountSettingsModal.tsx","../../../../node_modules/lucide-react/src/icons/timer.ts"],"sourcesContent":["import type { ParsedUrlQuery } from 'querystring'\n\nexport function searchParamsToUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  const query: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    const existing = query[key]\n    if (typeof existing === 'undefined') {\n      query[key] = value\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      query[key] = [existing, value]\n    }\n  }\n  return query\n}\n\nfunction stringifyUrlQueryParam(param: unknown): string {\n  if (typeof param === 'string') {\n    return param\n  }\n\n  if (\n    (typeof param === 'number' && !isNaN(param)) ||\n    typeof param === 'boolean'\n  ) {\n    return String(param)\n  } else {\n    return ''\n  }\n}\n\nexport function urlQueryToSearchParams(query: ParsedUrlQuery): URLSearchParams {\n  const searchParams = new URLSearchParams()\n  for (const [key, value] of Object.entries(query)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        searchParams.append(key, stringifyUrlQueryParam(item))\n      }\n    } else {\n      searchParams.set(key, stringifyUrlQueryParam(value))\n    }\n  }\n  return searchParams\n}\n\nexport function assign(\n  target: URLSearchParams,\n  ...searchParamsList: URLSearchParams[]\n): URLSearchParams {\n  for (const searchParams of searchParamsList) {\n    for (const key of searchParams.keys()) {\n      target.delete(key)\n    }\n\n    for (const [key, value] of searchParams.entries()) {\n      target.append(key, value)\n    }\n  }\n\n  return target\n}\n","// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport type { UrlObject } from 'url'\nimport type { ParsedUrlQuery } from 'querystring'\nimport * as querystring from './querystring'\n\nconst slashedProtocols = /https?|ftp|gopher|file/\n\nexport function formatUrl(urlObj: UrlObject) {\n  let { auth, hostname } = urlObj\n  let protocol = urlObj.protocol || ''\n  let pathname = urlObj.pathname || ''\n  let hash = urlObj.hash || ''\n  let query = urlObj.query || ''\n  let host: string | false = false\n\n  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : ''\n\n  if (urlObj.host) {\n    host = auth + urlObj.host\n  } else if (hostname) {\n    host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname)\n    if (urlObj.port) {\n      host += ':' + urlObj.port\n    }\n  }\n\n  if (query && typeof query === 'object') {\n    query = String(querystring.urlQueryToSearchParams(query as ParsedUrlQuery))\n  }\n\n  let search = urlObj.search || (query && `?${query}`) || ''\n\n  if (protocol && !protocol.endsWith(':')) protocol += ':'\n\n  if (\n    urlObj.slashes ||\n    ((!protocol || slashedProtocols.test(protocol)) && host !== false)\n  ) {\n    host = '//' + (host || '')\n    if (pathname && pathname[0] !== '/') pathname = '/' + pathname\n  } else if (!host) {\n    host = ''\n  }\n\n  if (hash && hash[0] !== '#') hash = '#' + hash\n  if (search && search[0] !== '?') search = '?' + search\n\n  pathname = pathname.replace(/[?#]/g, encodeURIComponent)\n  search = search.replace('#', '%23')\n\n  return `${protocol}${host}${pathname}${search}${hash}`\n}\n\nexport const urlObjectKeys = [\n  'auth',\n  'hash',\n  'host',\n  'hostname',\n  'href',\n  'path',\n  'pathname',\n  'port',\n  'protocol',\n  'query',\n  'search',\n  'slashes',\n]\n\nexport function formatWithValidation(url: UrlObject): string {\n  if (process.env.NODE_ENV === 'development') {\n    if (url !== null && typeof url === 'object') {\n      Object.keys(url).forEach((key) => {\n        if (!urlObjectKeys.includes(key)) {\n          console.warn(\n            `Unknown key passed via urlObject into url.format: ${key}`\n          )\n        }\n      })\n    }\n  }\n\n  return formatUrl(url)\n}\n","import { useCallback, useRef, type Ref } from 'react'\n\n// This is a compatibility hook to support React 18 and 19 refs.\n// In 19, a cleanup function from refs may be returned.\n// In 18, returning a cleanup function creates a warning.\n// Since we take userspace refs, we don't know ahead of time if a cleanup function will be returned.\n// This implements cleanup functions with the old behavior in 18.\n// We know refs are always called alternating with `null` and then `T`.\n// So a call with `null` means we need to call the previous cleanup functions.\nexport function useMergedRef<TElement>(\n  refA: Ref<TElement>,\n  refB: Ref<TElement>\n): Ref<TElement> {\n  const cleanupA = useRef<(() => void) | null>(null)\n  const cleanupB = useRef<(() => void) | null>(null)\n\n  // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n  // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n  // But this can cause us to leak a cleanup-ref into user code (previously via `<Link legacyBehavior>`),\n  // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n  // (because it hasn't been updated for React 19)\n  // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n  // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n  return useCallback(\n    (current: TElement | null): void => {\n      if (current === null) {\n        const cleanupFnA = cleanupA.current\n        if (cleanupFnA) {\n          cleanupA.current = null\n          cleanupFnA()\n        }\n        const cleanupFnB = cleanupB.current\n        if (cleanupFnB) {\n          cleanupB.current = null\n          cleanupFnB()\n        }\n      } else {\n        if (refA) {\n          cleanupA.current = applyRef(refA, current)\n        }\n        if (refB) {\n          cleanupB.current = applyRef(refB, current)\n        }\n      }\n    },\n    [refA, refB]\n  )\n}\n\nfunction applyRef<TElement>(\n  refA: NonNullable<Ref<TElement>>,\n  current: TElement\n) {\n  if (typeof refA === 'function') {\n    const cleanup = refA(current)\n    if (typeof cleanup === 'function') {\n      return cleanup\n    } else {\n      return () => refA(null)\n    }\n  } else {\n    refA.current = current\n    return () => {\n      refA.current = null\n    }\n  }\n}\n","import type { HtmlProps } from './html-context.shared-runtime'\nimport type { ComponentType, JSX } from 'react'\nimport type { DomainLocale } from '../../server/config'\nimport type { Env } from '@next/env'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { NextRouter } from './router/router'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { PreviewData } from '../../types'\nimport type { COMPILER_NAMES } from './constants'\nimport type fs from 'fs'\n\nexport type NextComponentType<\n  Context extends BaseContext = NextPageContext,\n  InitialProps = {},\n  Props = {},\n> = ComponentType<Props> & {\n  /**\n   * Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.\n   * Make sure to return plain `Object` without using `Date`, `Map`, `Set`.\n   * @param context Context of `page`\n   */\n  getInitialProps?(context: Context): InitialProps | Promise<InitialProps>\n}\n\nexport type DocumentType = NextComponentType<\n  DocumentContext,\n  DocumentInitialProps,\n  DocumentProps\n>\n\nexport type AppType<P = {}> = NextComponentType<\n  AppContextType,\n  P,\n  AppPropsType<any, P>\n>\n\nexport type AppTreeType = ComponentType<\n  AppInitialProps & { [name: string]: any }\n>\n\n/**\n * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.\n * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting\n */\nexport const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const\nexport type NextWebVitalsMetric = {\n  id: string\n  startTime: number\n  value: number\n  attribution?: { [key: string]: unknown }\n} & (\n  | {\n      label: 'web-vital'\n      name: (typeof WEB_VITALS)[number]\n    }\n  | {\n      label: 'custom'\n      name:\n        | 'Next.js-hydration'\n        | 'Next.js-route-change-to-render'\n        | 'Next.js-render'\n    }\n)\n\nexport type Enhancer<C> = (Component: C) => C\n\nexport type ComponentsEnhancer =\n  | {\n      enhanceApp?: Enhancer<AppType>\n      enhanceComponent?: Enhancer<NextComponentType>\n    }\n  | Enhancer<NextComponentType>\n\nexport type RenderPageResult = {\n  html: string\n  head?: Array<JSX.Element | null>\n}\n\nexport type RenderPage = (\n  options?: ComponentsEnhancer\n) => DocumentInitialProps | Promise<DocumentInitialProps>\n\nexport type BaseContext = {\n  res?: ServerResponse\n  [k: string]: any\n}\n\nexport type NEXT_DATA = {\n  props: Record<string, any>\n  page: string\n  query: ParsedUrlQuery\n  buildId: string\n  assetPrefix?: string\n  nextExport?: boolean\n  autoExport?: boolean\n  isFallback?: boolean\n  isExperimentalCompile?: boolean\n  dynamicIds?: (string | number)[]\n  err?: Error & {\n    statusCode?: number\n    source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer\n  }\n  gsp?: boolean\n  gssp?: boolean\n  customServer?: boolean\n  gip?: boolean\n  appGip?: boolean\n  locale?: string\n  locales?: readonly string[]\n  defaultLocale?: string\n  domainLocales?: readonly DomainLocale[]\n  scriptLoader?: any[]\n  isPreview?: boolean\n  notFoundSrcPage?: string\n}\n\n/**\n * `Next` context\n */\nexport interface NextPageContext {\n  /**\n   * Error object if encountered during rendering\n   */\n  err?: (Error & { statusCode?: number }) | null\n  /**\n   * `HTTP` request object.\n   */\n  req?: IncomingMessage\n  /**\n   * `HTTP` response object.\n   */\n  res?: ServerResponse\n  /**\n   * Path section of `URL`.\n   */\n  pathname: string\n  /**\n   * Query string section of `URL` parsed as an object.\n   */\n  query: ParsedUrlQuery\n  /**\n   * `String` of the actual path including query.\n   */\n  asPath?: string\n  /**\n   * The currently active locale\n   */\n  locale?: string\n  /**\n   * All configured locales\n   */\n  locales?: readonly string[]\n  /**\n   * The configured default locale\n   */\n  defaultLocale?: string\n  /**\n   * `Component` the tree of the App to use if needing to render separately\n   */\n  AppTree: AppTreeType\n}\n\nexport type AppContextType<Router extends NextRouter = NextRouter> = {\n  Component: NextComponentType<NextPageContext>\n  AppTree: AppTreeType\n  ctx: NextPageContext\n  router: Router\n}\n\nexport type AppInitialProps<PageProps = any> = {\n  pageProps: PageProps\n}\n\nexport type AppPropsType<\n  Router extends NextRouter = NextRouter,\n  PageProps = {},\n> = AppInitialProps<PageProps> & {\n  Component: NextComponentType<NextPageContext, any, any>\n  router: Router\n  __N_SSG?: boolean\n  __N_SSP?: boolean\n}\n\nexport type DocumentContext = NextPageContext & {\n  renderPage: RenderPage\n  defaultGetInitialProps(\n    ctx: DocumentContext,\n    options?: { nonce?: string }\n  ): Promise<DocumentInitialProps>\n}\n\nexport type DocumentInitialProps = RenderPageResult & {\n  styles?: React.ReactElement[] | Iterable<React.ReactNode> | JSX.Element\n}\n\nexport type DocumentProps = DocumentInitialProps & HtmlProps\n\n/**\n * Next `API` route request\n */\nexport interface NextApiRequest extends IncomingMessage {\n  /**\n   * Object of `query` values from url\n   */\n  query: Partial<{\n    [key: string]: string | string[]\n  }>\n  /**\n   * Object of `cookies` from header\n   */\n  cookies: Partial<{\n    [key: string]: string\n  }>\n\n  body: any\n\n  env: Env\n\n  draftMode?: boolean\n\n  preview?: boolean\n  /**\n   * Preview data set on the request, if any\n   * */\n  previewData?: PreviewData\n}\n\n/**\n * Send body of response\n */\ntype Send<T> = (body: T) => void\n\n/**\n * Next `API` route response\n */\nexport type NextApiResponse<Data = any> = ServerResponse & {\n  /**\n   * Send data `any` data in response\n   */\n  send: Send<Data>\n  /**\n   * Send data `json` data in response\n   */\n  json: Send<Data>\n  status: (statusCode: number) => NextApiResponse<Data>\n  redirect(url: string): NextApiResponse<Data>\n  redirect(status: number, url: string): NextApiResponse<Data>\n\n  /**\n   * Set draft mode\n   */\n  setDraftMode: (options: { enable: boolean }) => NextApiResponse<Data>\n\n  /**\n   * Set preview data for Next.js' prerender mode\n   */\n  setPreviewData: (\n    data: object | string,\n    options?: {\n      /**\n       * Specifies the number (in seconds) for the preview session to last for.\n       * The given number will be converted to an integer by rounding down.\n       * By default, no maximum age is set and the preview session finishes\n       * when the client shuts down (browser is closed).\n       */\n      maxAge?: number\n      /**\n       * Specifies the path for the preview session to work under. By default,\n       * the path is considered the \"default path\", i.e., any pages under \"/\".\n       */\n      path?: string\n    }\n  ) => NextApiResponse<Data>\n\n  /**\n   * Clear preview data for Next.js' prerender mode\n   */\n  clearPreviewData: (options?: { path?: string }) => NextApiResponse<Data>\n\n  /**\n   * Revalidate a specific page and regenerate it using On-Demand Incremental\n   * Static Regeneration.\n   * The path should be an actual path, not a rewritten path. E.g. for\n   * \"/blog/[slug]\" this should be \"/blog/post-1\".\n   * @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath\n   */\n  revalidate: (\n    urlPath: string,\n    opts?: {\n      unstable_onlyGenerated?: boolean\n    }\n  ) => Promise<void>\n}\n\n/**\n * Next `API` route handler\n */\nexport type NextApiHandler<T = any> = (\n  req: NextApiRequest,\n  res: NextApiResponse<T>\n) => unknown | Promise<unknown>\n\n/**\n * Utils\n */\nexport function execOnce<T extends (...args: any[]) => ReturnType<T>>(\n  fn: T\n): T {\n  let used = false\n  let result: ReturnType<T>\n\n  return ((...args: any[]) => {\n    if (!used) {\n      used = true\n      result = fn(...args)\n    }\n    return result\n  }) as T\n}\n\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/\nexport const isAbsoluteUrl = (url: string) => ABSOLUTE_URL_REGEX.test(url)\n\nexport function getLocationOrigin() {\n  const { protocol, hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? ':' + port : ''}`\n}\n\nexport function getURL() {\n  const { href } = window.location\n  const origin = getLocationOrigin()\n  return href.substring(origin.length)\n}\n\nexport function getDisplayName<P>(Component: ComponentType<P>) {\n  return typeof Component === 'string'\n    ? Component\n    : Component.displayName || Component.name || 'Unknown'\n}\n\nexport function isResSent(res: ServerResponse) {\n  return res.finished || res.headersSent\n}\n\nexport function normalizeRepeatedSlashes(url: string) {\n  const urlParts = url.split('?')\n  const urlNoQuery = urlParts[0]\n\n  return (\n    urlNoQuery\n      // first we replace any non-encoded backslashes with forward\n      // then normalize repeated forward slashes\n      .replace(/\\\\/g, '/')\n      .replace(/\\/\\/+/g, '/') +\n    (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')\n  )\n}\n\nexport async function loadGetInitialProps<\n  C extends BaseContext,\n  IP = {},\n  P = {},\n>(App: NextComponentType<C, IP, P>, ctx: C): Promise<IP> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (App.prototype?.getInitialProps) {\n      const message = `\"${getDisplayName(\n        App\n      )}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`\n      throw new Error(message)\n    }\n  }\n  // when called from _app `ctx` is nested in `ctx`\n  const res = ctx.res || (ctx.ctx && ctx.ctx.res)\n\n  if (!App.getInitialProps) {\n    if (ctx.ctx && ctx.Component) {\n      // @ts-ignore pageProps default\n      return {\n        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),\n      }\n    }\n    return {} as IP\n  }\n\n  const props = await App.getInitialProps(ctx)\n\n  if (res && isResSent(res)) {\n    return props\n  }\n\n  if (!props) {\n    const message = `\"${getDisplayName(\n      App\n    )}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`\n    throw new Error(message)\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (Object.keys(props).length === 0 && !ctx.ctx) {\n      console.warn(\n        `${getDisplayName(\n          App\n        )} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`\n      )\n    }\n  }\n\n  return props\n}\n\nexport const SP = typeof performance !== 'undefined'\nexport const ST =\n  SP &&\n  (['mark', 'measure', 'getEntriesByName'] as const).every(\n    (method) => typeof performance[method] === 'function'\n  )\n\nexport class DecodeError extends Error {}\nexport class NormalizeError extends Error {}\nexport class PageNotFoundError extends Error {\n  code: string\n\n  constructor(page: string) {\n    super()\n    this.code = 'ENOENT'\n    this.name = 'PageNotFoundError'\n    this.message = `Cannot find module for page: ${page}`\n  }\n}\n\nexport class MissingStaticPage extends Error {\n  constructor(page: string, message: string) {\n    super()\n    this.message = `Failed to load static file for page: ${page} ${message}`\n  }\n}\n\nexport class MiddlewareNotFoundError extends Error {\n  code: string\n  constructor() {\n    super()\n    this.code = 'ENOENT'\n    this.message = `Cannot find the middleware module`\n  }\n}\n\nexport interface CacheFs {\n  existsSync: typeof fs.existsSync\n  readFile: typeof fs.promises.readFile\n  readFileSync: typeof fs.readFileSync\n  writeFile(f: string, d: any): Promise<void>\n  mkdir(dir: string): Promise<void | string>\n  stat(f: string): Promise<{ mtime: Date }>\n}\n\nexport function stringifyError(error: Error) {\n  return JSON.stringify({ message: error.message, stack: error.stack })\n}\n","/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\nexport function parsePath(path: string) {\n  const hashIndex = path.indexOf('#')\n  const queryIndex = path.indexOf('?')\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex)\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery\n        ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined)\n        : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : '',\n    }\n  }\n\n  return { pathname: path, query: '', hash: '' }\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */\nexport function addPathPrefix(path: string, prefix?: string) {\n  if (!path.startsWith('/') || !prefix) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  return `${prefix}${pathname}${query}${hash}`\n}\n","/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */\nexport function removeTrailingSlash(route: string) {\n  return route.replace(/\\/$/, '') || '/'\n}\n","import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n","import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n","let warnOnce = (_: string) => {}\nif (process.env.NODE_ENV !== 'production') {\n  const warnings = new Set<string>()\n  warnOnce = (msg: string) => {\n    if (!warnings.has(msg)) {\n      console.warn(msg)\n    }\n    warnings.add(msg)\n  }\n}\n\nexport { warnOnce }\n","/**\n * Shared types and constants for the Segment Cache.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n","// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedPathname = Opaque<'NormalizedPathname', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    pathname: NormalizedPathname\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    pathname: originalUrl.pathname as NormalizedPathname,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n","/**\n * App Router types - Client-safe types for the Next.js App Router\n *\n * This file contains type definitions that can be safely imported\n * by both client-side and server-side code without circular dependencies.\n */\n\nimport type React from 'react'\n\nexport type LoadingModuleData =\n  | [React.JSX.Element, React.ReactNode, React.ReactNode]\n  | null\n\nimport type { VaryParamsThenable } from './segment-cache/vary-params-decoding'\n\n/** viewport metadata node */\nexport type HeadData = React.ReactNode\n\n/**\n * Cache node used in app-router / layout-router.\n */\n\nexport type CacheNode = {\n  /**\n   * When rsc is not null, it represents the RSC data for the\n   * corresponding segment.\n   *\n   * `null` is a valid React Node but because segment data is always a\n   * <LayoutRouter> component, we can use `null` to represent empty. When it is\n   * null, it represents missing data, and rendering should suspend.\n   */\n  rsc: React.ReactNode\n\n  /**\n   * Represents a static version of the segment that can be shown immediately,\n   * and may or may not contain dynamic holes. It's prefetched before a\n   * navigation occurs.\n   *\n   * During rendering, we will choose whether to render `rsc` or `prefetchRsc`\n   * with `useDeferredValue`. As with the `rsc` field, a value of `null` means\n   * no value was provided. In this case, the LayoutRouter will go straight to\n   * rendering the `rsc` value; if that one is also missing, it will suspend and\n   * trigger a lazy fetch.\n   */\n  prefetchRsc: React.ReactNode\n\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  slots: Record<string, CacheNode> | null\n}\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted-(..)(..)'\n  | 'catchall-intercepted-(.)'\n  | 'catchall-intercepted-(..)'\n  | 'catchall-intercepted-(...)'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted-(..)(..)'\n  | 'dynamic-intercepted-(.)'\n  | 'dynamic-intercepted-(..)'\n  | 'dynamic-intercepted-(...)'\n\nexport type DynamicParamTypesShort =\n  | 'c'\n  | 'ci(..)(..)'\n  | 'ci(.)'\n  | 'ci(..)'\n  | 'ci(...)'\n  | 'oc'\n  | 'd'\n  | 'di(..)(..)'\n  | 'di(.)'\n  | 'di(..)'\n  | 'di(...)'\n\n// The tuple form of a segment, used for dynamic route params\nexport type DynamicSegmentTuple = [\n  // Param name\n  paramName: string,\n  // Param cache key (almost the same as the value, but arrays are\n  // concatenated into strings)\n  // TODO: We should change this to just be the value. Currently we convert\n  // it back to a value when passing to useParams. It only needs to be\n  // a string when converted to a a cache key, but that doesn't mean we\n  // need to store it as that representation.\n  paramCacheKey: string,\n  // Dynamic param type\n  dynamicParamType: DynamicParamTypesShort,\n  // Static sibling segments at the same URL level. Used by the client\n  // router to determine if a prefetch can be reused when navigating to\n  // a static sibling of a dynamic route. For example, if the route is\n  // /products/[id] and there's also /products/sale, then staticSiblings\n  // would be ['sale']. null means the siblings are unknown (e.g. in\n  // webpack dev mode).\n  staticSiblings: readonly string[] | null,\n]\n\nexport type Segment = string | DynamicSegmentTuple\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  refreshState?: CompressedRefreshState | null,\n  /**\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation — inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   * - \"metadata-only\" instructs the server to skip rendering the segments and\n   *   only send the head data.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case — during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?: 'refetch' | 'inside-shared-layout' | 'metadata-only' | null,\n  isRootLayout?: boolean,\n  /**\n   * Only present when responding to a tree prefetch request. Indicates whether\n   * there is a loading boundary somewhere in the tree. The client cache uses\n   * this to determine if it can skip the data prefetch request.\n   */\n  hasLoadingBoundary?: HasLoadingBoundary,\n]\n\n/**\n * When rendering a parallel route, some of the parallel paths may not match\n * the current URL. In that case, the Next client has to render something,\n * so it will render whichever was the last route to match that slot. We use\n * this type to track when this has happened. It's a tuple of the original\n * URL that was used to fetch the segment, and the (possibly rewritten) search\n * query that was rendered by the server. The URL is needed when performing\n * a refresh of the segment, and the search query is needed for looking up\n * matching entries in the segment cache.\n */\nexport type CompressedRefreshState = [url: string, renderedSearch: string]\n\nexport const enum HasLoadingBoundary {\n  // There is a loading boundary in this particular segment\n  SegmentHasLoadingBoundary = 1,\n  // There is a loading boundary somewhere in the subtree (but not in\n  // this segment)\n  SubtreeHasLoadingBoundary = 2,\n  // There is no loading boundary in this segment or any of its descendants\n  SubtreeHasNoLoadingBoundary = 3,\n}\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  // TODO: This field is no longer used. Remove it.\n  loading: null,\n  isPartial: boolean,\n  /** TODO: this doesn't feel like it belongs here, because it's only used during build, in `collectSegmentData` */\n  hasRuntimePrefetch: boolean,\n  /**\n   * A thenable that resolves to the set of route params this segment accessed\n   * during server rendering. Used by the client router to determine cache key\n   * specificity - segments that only access certain params can be reused across\n   * navigations where unaccessed params change.\n   *\n   * - null thenable: tracking was not enabled for this render (e.g., not a\n   *   prerender). Treat conservatively - assume all params vary.\n   * - Thenable resolves to empty Set: segment accesses no params (e.g., client\n   *   components, or server components that don't read params). Can be shared\n   *   across all param values.\n   * - Thenable resolves to non-empty Set: segment depends on those params.\n   *   Can only reuse when those specific params match.\n   */\n  varyParams: VaryParamsThenable | null,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** initialRenderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** prerendered */\n  S: boolean\n  /**\n   * headVaryParams - vary params for the head (metadata) of the response.\n   */\n  h: VaryParamsThenable | null\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n  /** renderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** runtimePrefetch - [isPartial, staleTime]. Only present in runtime prefetch responses. */\n  rp?: [boolean, number]\n  /** headVaryParams */\n  h: VaryParamsThenable | null\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** renderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n","import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n","/**\n * Vary Params Decoding\n *\n * This module is shared between server and client.\n */\n\nexport type VaryParams = Set<string>\n\ntype FulfilledVaryParamsThenable = {\n  status: 'fulfilled'\n  value: VaryParams\n} & PromiseLike<VaryParams>\n\ntype PendingVaryParamsThenable = {\n  // 'resolved_model' is an internal React Flight state: the underlying model\n  // data has arrived but the thenable hasn't been \"unwrapped\" yet. Calling\n  // .then() triggers Flight to synchronously transition to 'fulfilled'.\n  status: 'pending' | 'resolved_model'\n  value: unknown\n} & PromiseLike<VaryParams>\n\nexport type VaryParamsThenable =\n  | FulfilledVaryParamsThenable\n  | PendingVaryParamsThenable\n\n/**\n * Synchronously reads vary params from a thenable.\n *\n * By the time this is called (client-side or in collectSegmentData), the\n * thenable should already be fulfilled because the Flight stream has been\n * fully received. We check the status synchronously to avoid unnecessary\n * microtasks.\n *\n * Returns null if the thenable is still pending (which shouldn't happen in\n * normal operation - it indicates the server failed to track vary params).\n */\nexport function readVaryParams(\n  thenable: VaryParamsThenable\n): VaryParams | null {\n  // Attach a no-op listener to force Flight to synchronously resolve the\n  // thenable. When a thenable arrives from the Flight stream, it may be in an\n  // intermediate 'resolved_model' state (data received but not unwrapped).\n  // Calling .then() triggers Flight to transition it to 'fulfilled', making\n  // the value available synchronously. React uses this same optimization\n  // internally to avoid unnecessary microtasks.\n  thenable.then(noop)\n  // If the thenable is still not 'fulfilled' after calling .then(), the server\n  // failed to resolve it before the stream ended. Treat as unknown.\n  if (thenable.status !== 'fulfilled') {\n    return null\n  }\n  return thenable.value\n}\n\nconst noop = () => {}\n","export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n\n// TODO: Should this include nextjs in the name, like the others?\nexport const NEXT_ACTION_REVALIDATED_HEADER = 'x-action-revalidated' as const\n","import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { NavigationSeed } from '../segment-cache/navigation'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  previousTree: FlightRouterState\n  url: URL\n  nextUrl: string | null\n  seed: NavigationSeed | null\n  mpa: boolean\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n\n  /**\n   * The search query observed by the server during rendering. This may be\n   * different from the canonical URL's search query if the server performed\n   * a rewrite. Even though a client component won't observe this (unless it\n   * were passed from a Server component), the client router needs to know this\n   * so it can properly cache segment data; it'ss part of a page segment's\n   * cache key.\n   */\n  renderedSearch: string\n\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { Dispatch } from 'react'\nimport React, { use, useMemo, useOptimistic } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\n// Optimistic state setter for experimental_gesturePush. Only should be used\n// during a gesture transition.\nlet setGestureRouterState: ((state: ReducerState) => void) | null = null\n\nexport function dispatchGestureState(state: ReducerState) {\n  if (setGestureRouterState === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  setGestureRouterState(state)\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production'\nconst promisesWithDebugInfo: WeakMap<\n  Promise<AppRouterState>,\n  Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n> = __DEV__ ? new WeakMap() : (null as any)\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [canonicalState, setState] = React.useState<ReducerState>(\n    actionQueue.state\n  )\n\n  // Wrap the canonical state in useOptimistic to support\n  // experimental_gesturePush. During a gesture transition, this returns a fork\n  // of the router state that represents the eventual target if/when the gesture\n  // completes. Otherwise it returns the canonical state.\n  const [state, setGesture] = useOptimistic(canonicalState)\n  setGestureRouterState = setGesture\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (!__DEV__) {\n      return state\n    }\n\n    if (isThenable(state)) {\n      // useMemo can't be used to cache a Promise since the memoized value is thrown\n      // away when we suspend. So we use a WeakMap to cache the Promise with debug info.\n      let promiseWithDebugInfo = promisesWithDebugInfo.get(state)\n      if (promiseWithDebugInfo === undefined) {\n        const debugInfo: Array<unknown> = []\n        promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n          if (asyncState.debugInfo !== null) {\n            debugInfo.push(...asyncState.debugInfo)\n          }\n          return asyncState\n        }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n        promiseWithDebugInfo._debugInfo = debugInfo\n\n        promisesWithDebugInfo.set(state, promiseWithDebugInfo)\n      }\n\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n","import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n","import { PAGE_SEGMENT_KEY } from '../segment'\nimport type { Segment as FlightRouterStateSegment } from '../app-router-types'\n\n// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\nexport type SegmentRequestKeyPart = Opaque<'SegmentRequestKeyPart', string>\nexport type SegmentRequestKey = Opaque<'SegmentRequestKey', string>\n\nexport const ROOT_SEGMENT_REQUEST_KEY = '' as SegmentRequestKey\n\nexport const HEAD_REQUEST_KEY = '/_head' as SegmentRequestKey\n\nexport function createSegmentRequestKeyPart(\n  segment: FlightRouterStateSegment\n): SegmentRequestKeyPart {\n  if (typeof segment === 'string') {\n    if (segment.startsWith(PAGE_SEGMENT_KEY)) {\n      // The Flight Router State type sometimes includes the search params in\n      // the page segment. However, the Segment Cache tracks this as a separate\n      // key. So, we strip the search params here, and then add them back when\n      // the cache entry is turned back into a FlightRouterState. This is an\n      // unfortunate consequence of the FlightRouteState being used both as a\n      // transport type and as a cache key; we'll address this once more of the\n      // Segment Cache implementation has settled.\n      // TODO: We should hoist the search params out of the FlightRouterState\n      // type entirely, This is our plan for dynamic route params, too.\n      return PAGE_SEGMENT_KEY as SegmentRequestKeyPart\n    }\n    const safeName =\n      // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n      // But params typically don't include the leading slash. We should use\n      // a different encoding to avoid this special case.\n      segment === '/_not-found'\n        ? '_not-found'\n        : encodeToFilesystemAndURLSafeString(segment)\n    // Since this is not a dynamic segment, it's fully encoded. It does not\n    // need to be \"hydrated\" with a param value.\n    return safeName as SegmentRequestKeyPart\n  }\n\n  const name = segment[0]\n  const paramType = segment[2]\n  const safeName = encodeToFilesystemAndURLSafeString(name)\n\n  const encodedName = '$' + paramType + '$' + safeName\n  return encodedName as SegmentRequestKeyPart\n}\n\nexport function appendSegmentRequestKeyPart(\n  parentRequestKey: SegmentRequestKey,\n  parallelRouteKey: string,\n  childRequestKeyPart: SegmentRequestKeyPart\n): SegmentRequestKey {\n  // Aside from being filesystem safe, segment keys are also designed so that\n  // each segment and parallel route creates its own subdirectory. Roughly in\n  // the same shape as the source app directory. This is mostly just for easier\n  // debugging (you can open up the build folder and navigate the output); if\n  // we wanted to do we could just use a flat structure.\n\n  // Omit the parallel route key for children, since this is the most\n  // common case. Saves some bytes (and it's what the app directory does).\n  const slotKey =\n    parallelRouteKey === 'children'\n      ? childRequestKeyPart\n      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`\n  return (parentRequestKey + '/' + slotKey) as SegmentRequestKey\n}\n\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/\n\nfunction encodeToFilesystemAndURLSafeString(value: string) {\n  if (simpleParamValueRegex.test(value)) {\n    return value\n  }\n  // If there are any unsafe characters, base64url-encode the entire value.\n  // We also add a ! prefix so it doesn't collide with the simple case.\n  const base64url = btoa(value)\n    .replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove trailing '='\n  return '!' + base64url\n}\n\nexport function convertSegmentPathToStaticExportFilename(\n  segmentPath: string\n): string {\n  return `__next${segmentPath.replace(/\\//g, '.')}.txt`\n}\n","import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n} from './components/segment-cache/cache-key'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): NormalizedPathname {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (rewrittenPath ??\n    urlToUrlWithoutFlightMarker(new URL(response.url))\n      .pathname) as NormalizedPathname\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Catchall intercepted\n    case 'ci(..)(..)':\n    case 'ci(.)':\n    case 'ci(..)':\n    case 'ci(...)': {\n      const prefix = paramType.length - 2\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s, i) => {\n            if (i === 0) {\n              return encodeURIComponent(s.slice(prefix))\n            }\n\n            return encodeURIComponent(s)\n          })\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    // Dynamic intercepted\n    case 'di(..)(..)':\n    case 'di(.)':\n    case 'di(..)':\n    case 'di(...)': {\n      const prefix = paramType.length - 2\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n\n      return encodeURIComponent(pathnameParts[partIndex].slice(prefix))\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache/cache-key'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    S: fallbackInitialRSCPayload.S,\n    h: fallbackInitialRSCPayload.h,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const staticSiblings = originalSegment[3]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType, staticSiblings]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _refreshState, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // Strip client-only data from the segment\n  const cleanedSegment = stripClientOnlyDataFromSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [cleanedSegment, cleanedParallelRoutes]\n  if (refreshMarker) {\n    result[2] = null // null slightly more compact than undefined\n    result[3] = refreshMarker\n  }\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  // Everything else is used only by the client and is not needed for requests.\n  return result\n}\n\n/**\n * Strips client-only data from segments:\n * - Search parameters from __PAGE__ segments\n * - staticSiblings from dynamic segment tuples (only needed for client-side\n *   prefetch reuse decisions)\n */\nfunction stripClientOnlyDataFromSegment(segment: Segment): Segment {\n  if (typeof segment === 'string') {\n    // Strip search params from __PAGE__ segments\n    if (segment.startsWith(PAGE_SEGMENT_KEY + '?')) {\n      return PAGE_SEGMENT_KEY\n    }\n    return segment\n  }\n  // Dynamic segment tuple: [paramName, paramCacheKey, paramType, staticSiblings]\n  // Strip staticSiblings (4th element) since server doesn't need it\n  const [paramName, paramCacheKey, paramType] = segment\n  return [paramName, paramCacheKey, paramType, null]\n}\n","// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n","// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str: string) {\n  let hash = 5381\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) + hash + char) & 0xffffffff\n  }\n  return hash >>> 0\n}\n\nexport function hexHash(str: string) {\n  return djb2Hash(str).toString(36).slice(0, 5)\n}\n","import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: '1' | '2' | '0' | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string {\n  if (\n    (prefetchHeader === undefined || prefetchHeader === '0') &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return ''\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n","'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","let deploymentId: string | undefined\n\nif (typeof window !== 'undefined') {\n  deploymentId = document.documentElement.dataset.dplId\n  // Immediately remove the attribute to prevent hydration errors (the dplId was inserted into the\n  // HTML only), React isn't aware of it at all.\n  delete document.documentElement.dataset.dplId\n} else {\n  // Client side: replaced with globalThis.NEXT_DEPLOYMENT_ID\n  // Server side: left as is or replaced with a string or replaced with false\n  deploymentId = process.env.NEXT_DEPLOYMENT_ID || undefined\n}\n\nexport function getDeploymentId(): string | undefined {\n  return deploymentId\n}\n\nexport function getDeploymentIdQueryOrEmptyString(): string {\n  if (deploymentId) {\n    return `?dpl=${deploymentId}`\n  }\n  return ''\n}\n","'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport {\n  type NEXT_ROUTER_PREFETCH_HEADER,\n  type NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport { urlToUrlWithoutFlightMarker } from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\nimport { getDeploymentId } from '../../../shared/lib/deployment-id'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet isPageUnloading = false\n\nif (typeof window !== 'undefined') {\n  // Track when the page is unloading, e.g. due to reloading the page or\n  // performing hard navigations. This allows us to suppress error logging when\n  // the browser cancels in-flight requests during page unload.\n  window.addEventListener('pagehide', () => {\n    isPageUnloading = true\n  })\n\n  // Reset the flag on pageshow, e.g. when navigating back and the JavaScript\n  // execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    isPageUnloading = false\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      'auto',\n      shouldImmediatelyDecode\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      // TODO: We should be able to read this from the rewrite header, not the\n      // Flight response. Theoretically they should always agree, but there are\n      // currently some cases where it's incorrect for interception routes. We\n      // can always trust the value in the response body. However, per-segment\n      // prefetch responses don't embed the value in the body; they rely on the\n      // header alone. So we need to investigate why the header is sometimes\n      // wrong for interception routes.\n      renderedSearch: flightResponse.q as NormalizedSearch,\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!isPageUnloading) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  const deploymentId = getDeploymentId()\n  if (deploymentId) {\n    headers['x-deployment-id'] = deploymentId\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid — when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n","import { deleteMapEntry } from './cache-map'\nimport type { UnknownMapEntry } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\nlet head: UnknownMapEntry | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: UnknownMapEntry) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: UnknownMapEntry, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: UnknownMapEntry) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n        prev.next = next\n        next.prev = prev\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteMapEntry(tail)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n","import type { VaryPath } from './vary-path'\nimport { lruPut, updateLruSize, deleteFromLru } from './lru'\n\n/**\n * A specialized data type for storing multi-key cache entries.\n *\n * The basic structure is a map whose keys are tuples, called the keypath.\n * When querying the cache, keypaths are compared per-element.\n *\n * Example:\n *   set(map, ['https://localhost', 'foo/bar/baz'], 'yay');\n *   get(map, ['https://localhost', 'foo/bar/baz']) -> 'yay'\n *\n * NOTE: Array syntax is used in these examples for illustration purposes, but\n * in reality the paths are lists.\n * \n * The parts of the keypath represent the different inputs that contribute\n * to the entry value. To illustrate, if you were to use this data type to store\n * HTTP responses, the keypath would include the URL and everything listed by\n * the Vary header.\n * \n * See vary-path.ts for more details.\n *\n * The order of elements in a keypath must be consistent between lookups to\n * be considered the same, but besides that, the order of the keys is not\n * semantically meaningful.\n *\n * Keypaths may include a special kind of key called Fallback. When an entry is\n * stored with Fallback as part of its keypath, it means that the entry does not\n * vary by that key. When querying the cache, if an exact match is not found for\n * a keypath, the cache will check for a Fallback match instead. Each element of\n * the keypath may have a Fallback, so retrieval is an O(n ^ 2) operation, but\n * it's expected that keypaths are relatively short.\n *\n * Example:\n *   set(cacheMap, ['store', 'product', 1], PRODUCT_PAGE_1);\n *   set(cacheMap, ['store', 'product', Fallback], GENERIC_PRODUCT_PAGE);\n *\n *   // Exact match\n *   get(cacheMap, ['store', 'product', 1]) -> PRODUCT_PAGE_1\n *\n *   // Fallback match\n *   get(cacheMap, ['store', 'product', 2]) -> GENERIC_PRODUCT_PAGE\n *\n * Because we have the Fallback mechanism, we can impose a constraint that\n * regular JS maps do not have: a value cannot be stored at multiple keypaths\n * simultaneously. These cases should be expressed with Fallback keys instead.\n *\n * Additionally, because values only exist at a single keypath at a time, we\n * can optimize successive lookups by caching the internal map entry on the\n * value itself, using the `ref` field. This is especially useful because it\n * lets us skip the O(n ^ 2) lookup that occurs when Fallback entries\n * are present.\n *\n\n * How to decide if stuff belongs in here, or in cache.ts?\n * -------------------------------------------------------\n * \n * Anything to do with retrival, lifetimes, or eviction needs to go in this\n * module because it affects the fallback algorithm. For example, when\n * performing a lookup, if an entry is stale, it needs to be treated as\n * semantically equivalent to if the entry was not present at all.\n * \n * If there's logic that's not related to the fallback algorithm, though, we\n * should prefer to put it in cache.ts.\n */\n\n// The protocol that values must implement. In practice, the only two types that\n// we ever actually deal with in this module are RouteCacheEntry and\n// SegmentCacheEntry; this is just to keep track of the coupling so we don't\n// leak concerns between the modules unnecessarily.\nexport interface MapValue {\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Represents a node in the cache map and LRU.\n * MapEntry<V> structurally satisfies this interface for any V extends MapValue.\n *\n * The LRU can contain entries of different value types\n * (e.g., both RouteCacheEntry and SegmentCacheEntry). This interface captures\n * the common structure needed for cache map and LRU operations without\n * requiring knowledge of the specific value type.\n */\nexport interface MapEntry<V extends MapValue> {\n  // Cache map structure fields\n  parent: MapEntry<V> | null\n  key: unknown\n  map: Map<unknown, MapEntry<V>> | null\n  value: V | null\n\n  // LRU linked list fields\n  prev: MapEntry<V> | null\n  next: MapEntry<V> | null\n  size: number\n}\n\n/**\n * A looser type for MapEntry\n * This allows the LRU to work with entries of different\n * value types while still providing type safety.\n *\n * The `map` field lets Map<unknown, MapEntry<V>> be assignable to this\n * type since we're only reading from the map, not inserting into it.\n */\nexport type UnknownMapEntry = {\n  parent: UnknownMapEntry | null\n  key: unknown\n  map: Pick<Map<unknown, UnknownMapEntry>, 'get' | 'delete' | 'size'> | null\n  value: MapValue | null\n\n  prev: UnknownMapEntry | null\n  next: UnknownMapEntry | null\n  size: number\n}\n\n// The CacheMap type is just the root entry of the map.\nexport type CacheMap<V extends MapValue> = MapEntry<V>\n\nexport type FallbackType = { __brand: 'Fallback' }\nexport const Fallback = {} as FallbackType\n\n// This is a special internal key that is used for \"revalidation\" entries. It's\n// an implementation detail that shouldn't leak outside of this module.\nconst Revalidation = {}\n\nexport function createCacheMap<V extends MapValue>(): CacheMap<V> {\n  const cacheMap: MapEntry<V> = {\n    parent: null,\n    key: null,\n    value: null,\n    map: null,\n\n    // LRU-related fields\n    prev: null,\n    next: null,\n    size: 0,\n  }\n  return cacheMap\n}\n\nfunction getOrInitialize<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): MapEntry<V> {\n  // Go through each level of keys until we find the entry that matches, or\n  // create a new entry if one doesn't exist.\n  //\n  // This function will only return entries that match the keypath _exactly_.\n  // Unlike getWithFallback, it will not access fallback entries unless it's\n  // explicitly part of the keypath.\n  let entry = cacheMap\n  let remainingKeys: VaryPath | null = keys\n  let key: unknown | null = null\n  while (true) {\n    const previousKey = key\n    if (remainingKeys !== null) {\n      key = remainingKeys.value\n      remainingKeys = remainingKeys.parent\n    } else if (isRevalidation && previousKey !== Revalidation) {\n      // During a revalidation, we append an internal \"Revalidation\" key to\n      // the end of the keypath. The \"normal\" entry is its parent.\n\n      // However, if the parent entry is currently empty, we don't need to store\n      // this as a revalidation entry. Just insert the revalidation into the\n      // normal slot.\n      if (entry.value === null) {\n        return entry\n      }\n\n      // Otheriwse, create a child entry.\n      key = Revalidation\n    } else {\n      // There are no more keys. This is the terminal entry.\n      break\n    }\n\n    let map = entry.map\n    if (map !== null) {\n      const existingEntry = map.get(key)\n      if (existingEntry !== undefined) {\n        // Found a match. Keep going.\n        entry = existingEntry\n        continue\n      }\n    } else {\n      map = new Map()\n      entry.map = map\n    }\n    // No entry exists yet at this level. Create a new one.\n    const newEntry: MapEntry<V> = {\n      parent: entry,\n      key,\n      value: null,\n      map: null,\n\n      // LRU-related fields\n      prev: null,\n      next: null,\n      size: 0,\n    }\n    map.set(key, newEntry)\n    entry = newEntry\n  }\n\n  return entry\n}\n\nexport function getFromCacheMap<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  rootEntry: CacheMap<V>,\n  keys: VaryPath,\n  isRevalidation: boolean\n): V | null {\n  const entry = getEntryWithFallbackImpl(\n    now,\n    currentCacheVersion,\n    rootEntry,\n    keys,\n    isRevalidation,\n    0\n  )\n  if (entry === null || entry.value === null) {\n    return null\n  }\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  return entry.value\n}\n\nexport function isValueExpired(\n  now: number,\n  currentCacheVersion: number,\n  value: MapValue\n): boolean {\n  return value.staleAt <= now || value.version < currentCacheVersion\n}\n\nfunction lazilyEvictIfNeeded<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>\n) {\n  // We have a matching entry, but before we can return it, we need to check if\n  // it's still fresh. Otherwise it should be treated the same as a cache miss.\n\n  if (entry.value === null) {\n    // This entry has no value, so there's nothing to evict.\n    return entry\n  }\n\n  const value = entry.value\n  if (isValueExpired(now, currentCacheVersion, value)) {\n    // The value expired. Lazily evict it from the cache, and return null. This\n    // is conceptually the same as a cache miss.\n    deleteMapEntry(entry)\n    return null\n  }\n\n  // The matched entry has not expired. Return it.\n  return entry\n}\n\nfunction getEntryWithFallbackImpl<V extends MapValue>(\n  now: number,\n  currentCacheVersion: number,\n  entry: MapEntry<V>,\n  keys: VaryPath | null,\n  isRevalidation: boolean,\n  previousKey: unknown | null\n): MapEntry<V> | null {\n  // This is similar to getExactEntry, but if an exact match is not found for\n  // a key, it will return the fallback entry instead. This is recursive at\n  // every level, e.g. an entry with keypath [a, Fallback, c, Fallback] is\n  // valid match for [a, b, c, d].\n  //\n  // It will return the most specific match available.\n  let key\n  let remainingKeys: VaryPath | null\n  if (keys !== null) {\n    key = keys.value\n    remainingKeys = keys.parent\n  } else if (isRevalidation && previousKey !== Revalidation) {\n    // During a revalidation, we append an internal \"Revalidation\" key to\n    // the end of the keypath.\n    key = Revalidation\n    remainingKeys = null\n  } else {\n    // There are no more keys. This is the terminal entry.\n\n    // TODO: When performing a lookup during a navigation, as opposed to a\n    // prefetch, we may want to skip entries that are Pending if there's also\n    // a Fulfilled fallback entry. Tricky to say, though, since if it's\n    // already pending, it's likely to stream in soon. Maybe we could do this\n    // just on slow connections and offline mode.\n\n    return lazilyEvictIfNeeded(now, currentCacheVersion, entry)\n  }\n  const map = entry.map\n  if (map !== null) {\n    const existingEntry = map.get(key)\n    if (existingEntry !== undefined) {\n      // Found an exact match for this key. Keep searching.\n      const result = getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        existingEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n      if (result !== null) {\n        return result\n      }\n    }\n    // No match found for this key. Check if there's a fallback.\n    const fallbackEntry = map.get(Fallback)\n    if (fallbackEntry !== undefined) {\n      // Found a fallback for this key. Keep searching.\n      return getEntryWithFallbackImpl(\n        now,\n        currentCacheVersion,\n        fallbackEntry,\n        remainingKeys,\n        isRevalidation,\n        key\n      )\n    }\n  }\n  return null\n}\n\nexport function setInCacheMap<V extends MapValue>(\n  cacheMap: CacheMap<V>,\n  keys: VaryPath,\n  value: V,\n  isRevalidation: boolean\n): void {\n  // Add a value to the map at the given keypath. If the value is already\n  // part of the map, it's removed from its previous keypath. (NOTE: This is\n  // unlike a regular JS map, but the behavior is intentional.)\n  const entry = getOrInitialize(cacheMap, keys, isRevalidation)\n  setMapEntryValue(entry, value)\n\n  // This is an LRU access. Move the entry to the front of the list.\n  lruPut(entry)\n  updateLruSize(entry, value.size)\n}\n\nfunction setMapEntryValue(entry: UnknownMapEntry, value: MapValue): void {\n  if (entry.value !== null) {\n    // There's already a value at the given keypath. Disconnect the old value\n    // from the map. We're not calling `deleteMapEntry` here because the\n    // entry itself is still in the map. We just want to overwrite its value.\n    dropRef(entry.value)\n    entry.value = null\n  }\n\n  // This value may already be in the map at a different keypath.\n  // Grab a reference before we overwrite it.\n  const oldEntry = value.ref\n\n  entry.value = value\n  value.ref = entry\n\n  updateLruSize(entry, value.size)\n\n  if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n    // This value is already in the map at a different keypath in the map.\n    // Values only exist at a single keypath at a time. Remove it from the\n    // previous keypath.\n    //\n    // Note that only the internal map entry is garbage collected; we don't\n    // call `dropRef` here because it's still in the map, just\n    // at a new keypath (the one we just set, above).\n    deleteMapEntry(oldEntry)\n  }\n}\n\nexport function deleteFromCacheMap(value: MapValue): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n\n  dropRef(value)\n  deleteMapEntry(entry)\n}\n\nfunction dropRef(value: MapValue): void {\n  // Drop the value from the map by setting its `ref` backpointer to\n  // null. This is a separate operation from `deleteMapEntry` because when\n  // re-keying a value we need to be able to delete the old, internal map\n  // entry without garbage collecting the value itself.\n  value.ref = null\n}\n\nexport function deleteMapEntry(entry: UnknownMapEntry): void {\n  // Delete the entry from the cache.\n  entry.value = null\n\n  deleteFromLru(entry)\n\n  // Check if we can garbage collect the entry.\n  const map = entry.map\n  if (map === null) {\n    // Since this entry has no value, and also no child entries, we can\n    // garbage collect it. Remove it from its parent, and keep garbage\n    // collecting the parents until we reach a non-empty entry.\n    let parent = entry.parent\n    let key = entry.key\n    while (parent !== null) {\n      const parentMap = parent.map\n      if (parentMap !== null) {\n        parentMap.delete(key)\n        if (parentMap.size === 0) {\n          // We just removed the last entry in the parent map.\n          parent.map = null\n          if (parent.value === null) {\n            // The parent node has no child entries, nor does it have a value\n            // on itself. It can be garbage collected. Keep going.\n            key = parent.key\n            parent = parent.parent\n            continue\n          }\n        }\n      }\n      // The parent is not empty. Stop garbage collecting.\n      break\n    }\n  } else {\n    // Check if there's a revalidating entry. If so, promote it to a\n    // \"normal\" entry, since the normal one was just deleted.\n    const revalidatingEntry = map.get(Revalidation)\n    if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n      setMapEntryValue(entry, revalidatingEntry.value)\n    }\n  }\n}\n\nexport function setSizeInCacheMap<V extends MapValue>(\n  value: V,\n  size: number\n): void {\n  const entry = value.ref\n  if (entry === null) {\n    // This value is not a member of any map.\n    return\n  }\n  // Except during initialization (when the size is set to 0), this is the only\n  // place the `size` field should be updated, to ensure it's in sync with the\n  // the LRU.\n  value.size = size\n  updateLruSize(entry, size)\n}\n","import { FetchStrategy } from './types'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  NormalizedNextUrl,\n} from './cache-key'\nimport type { RouteTree } from './cache'\nimport { Fallback, type FallbackType } from './cache-map'\nimport { HEAD_REQUEST_KEY } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\ntype Opaque<T, K> = T & { __brand: K }\n\n/**\n * A linked-list of all the params (or other param-like) inputs that a cache\n * entry may vary by. This is used by the CacheMap module to reuse cache entries\n * across different param values. If a param has a value of Fallback, it means\n * the cache entry is reusable for all possible values of that param. See\n * cache-map.ts for details.\n *\n * A segment's vary path is a pure function of a segment's position in a\n * particular route tree and the (post-rewrite) URL that is being queried. More\n * concretely, successive queries of the cache for the same segment always use\n * the same vary path.\n *\n * A route's vary path is simpler: it's comprised of the pathname, search\n * string, and Next-URL header.\n */\nexport type VaryPath = {\n  /**\n   * Identifies which param this vary path node corresponds to. Used by\n   * getFulfilledSegmentVaryPath to determine which params to replace with\n   * Fallback based on the varyParams set from the server.\n   *\n   * - For path params: the param name (e.g., 'slug')\n   * - For search params: '?'\n   * - For non-param nodes (request keys, etc.): null\n   */\n  id: string | null\n  value: string | null | FallbackType\n  parent: VaryPath | null\n}\n\n// Because it's so important for vary paths to line up across cache accesses,\n// we use opaque type aliases to ensure these are only created within\n// this module.\n\n// requestKey -> searchParams -> nextUrl\nexport type RouteVaryPath = Opaque<\n  {\n    id: null\n    value: NormalizedPathname\n    parent: {\n      id: '?'\n      value: NormalizedSearch\n      parent: {\n        id: null\n        value: NormalizedNextUrl | null | FallbackType\n        parent: null\n      }\n    }\n  },\n  'RouteVaryPath'\n>\n\n// requestKey -> pathParams\nexport type LayoutVaryPath = Opaque<\n  {\n    id: null\n    value: string\n    parent: PartialSegmentVaryPath | null\n  },\n  'LayoutVaryPath'\n>\n\n// requestKey -> searchParams -> pathParams\nexport type PageVaryPath = Opaque<\n  {\n    id: null\n    value: string\n    parent: {\n      id: '?'\n      value: NormalizedSearch | FallbackType\n      parent: PartialSegmentVaryPath | null\n    }\n  },\n  'PageVaryPath'\n>\n\nexport type SegmentVaryPath = LayoutVaryPath | PageVaryPath\n\n// Intermediate type used when building a vary path during a recursive traversal\n// of the route tree.\nexport type PartialSegmentVaryPath = Opaque<VaryPath, 'PartialSegmentVaryPath'>\n\nexport function getRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null\n): RouteVaryPath {\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    id: null,\n    value: pathname,\n    parent: {\n      id: '?',\n      value: search,\n      parent: {\n        id: null,\n        value: nextUrl,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function getFulfilledRouteVaryPath(\n  pathname: NormalizedPathname,\n  search: NormalizedSearch,\n  nextUrl: NormalizedNextUrl | null,\n  couldBeIntercepted: boolean\n): RouteVaryPath {\n  // This is called when a route's data is fulfilled. The cache entry will be\n  // re-keyed based on which inputs the response varies by.\n  // requestKey -> searchParams -> nextUrl\n  const varyPath: VaryPath = {\n    id: null,\n    value: pathname,\n    parent: {\n      id: '?',\n      value: search,\n      parent: {\n        id: null,\n        value: couldBeIntercepted ? nextUrl : Fallback,\n        parent: null,\n      },\n    },\n  }\n  return varyPath as RouteVaryPath\n}\n\nexport function appendLayoutVaryPath(\n  parentPath: PartialSegmentVaryPath | null,\n  cacheKey: string,\n  paramName: string\n): PartialSegmentVaryPath {\n  const varyPathPart: VaryPath = {\n    id: paramName,\n    value: cacheKey,\n    parent: parentPath,\n  }\n  return varyPathPart as PartialSegmentVaryPath\n}\n\nexport function finalizeLayoutVaryPath(\n  requestKey: string,\n  varyPath: PartialSegmentVaryPath | null\n): LayoutVaryPath {\n  const layoutVaryPath: VaryPath = {\n    id: null,\n    value: requestKey,\n    parent: varyPath,\n  }\n  return layoutVaryPath as LayoutVaryPath\n}\n\nexport function getPartialLayoutVaryPath(\n  finalizedVaryPath: LayoutVaryPath\n): PartialSegmentVaryPath | null {\n  // This is the inverse of finalizeLayoutVaryPath.\n  return finalizedVaryPath.parent\n}\n\nexport function finalizePageVaryPath(\n  requestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // Unlike layouts, a page segment's vary path also includes the search string.\n  // requestKey -> searchParams -> pathParams\n  const pageVaryPath: VaryPath = {\n    id: null,\n    value: requestKey,\n    parent: {\n      id: '?',\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getPartialPageVaryPath(\n  finalizedVaryPath: PageVaryPath\n): PartialSegmentVaryPath | null {\n  // This is the inverse of finalizePageVaryPath.\n  return finalizedVaryPath.parent.parent\n}\n\nexport function finalizeMetadataVaryPath(\n  pageRequestKey: string,\n  renderedSearch: NormalizedSearch,\n  varyPath: PartialSegmentVaryPath | null\n): PageVaryPath {\n  // The metadata \"segment\" is not a real segment because it doesn't exist in\n  // the normal structure of the route tree, but in terms of caching, it\n  // behaves like a page segment because it varies by all the same params as\n  // a page.\n  //\n  // To keep the protocol for querying the server simple, the request key for\n  // the metadata does not include any path information. It's unnecessary from\n  // the server's perspective, because unlike page segments, there's only one\n  // metadata response per URL, i.e. there's no need to distinguish multiple\n  // parallel pages.\n  //\n  // However, this means the metadata request key is insufficient for\n  // caching the the metadata in the client cache, because on the client we\n  // use the request key to distinguish the metadata entry from all other\n  // page's metadata entries.\n  //\n  // So instead we create a simulated request key based on the page segment.\n  // Conceptually this is equivalent to the request key the server would have\n  // assigned the metadata segment if it treated it as part of the actual\n  // route structure.\n\n  // If there are multiple parallel pages, we use whichever is the first one.\n  // This is fine because the only difference between request keys for\n  // different parallel pages are things like route groups and parallel\n  // route slots. As long as it's always the same one, it doesn't matter.\n  const pageVaryPath: VaryPath = {\n    id: null,\n    // Append the actual metadata request key to the page request key. Note\n    // that we're not using a separate vary path part; it's unnecessary because\n    // these are not conceptually separate inputs.\n    value: pageRequestKey + HEAD_REQUEST_KEY,\n    parent: {\n      id: '?',\n      value: renderedSearch,\n      parent: varyPath,\n    },\n  }\n  return pageVaryPath as PageVaryPath\n}\n\nexport function getSegmentVaryPathForRequest(\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentVaryPath {\n  // This is used for storing pending requests in the cache. We want to choose\n  // the most generic vary path based on the strategy used to fetch it, i.e.\n  // static/PPR versus runtime prefetching, so that it can be reused as much\n  // as possible.\n  //\n  // We may be able to re-key the response to something even more generic once\n  // we receive it — for example, if the server tells us that the response\n  // doesn't vary on a particular param — but even before we send the request,\n  // we know some params are reusable based on the fetch strategy alone. For\n  // example, a static prefetch will never vary on search params.\n  //\n  // The original vary path with all the params filled in is stored on the\n  // route tree object. We will clone this one to create a new vary path\n  // where certain params are replaced with Fallback.\n  //\n  // This result of this function is not stored anywhere. It's only used to\n  // access the cache a single time.\n  //\n  // TODO: Rather than create a new list object just to access the cache, the\n  // plan is to add the concept of a \"vary mask\". This will represent all the\n  // params that can be treated as Fallback. (Or perhaps the inverse.)\n  const originalVaryPath = tree.varyPath\n\n  // Only page segments (and the special \"metadata\" segment, which is treated\n  // like a page segment for the purposes of caching) may contain search\n  // params. There's no reason to include them in the vary path otherwise.\n  if (tree.isPage) {\n    // Only a runtime prefetch will include search params in the vary path.\n    // Static prefetches never include search params, so they can be reused\n    // across all possible search param values.\n    const doesVaryOnSearchParams =\n      fetchStrategy === FetchStrategy.Full ||\n      fetchStrategy === FetchStrategy.PPRRuntime\n\n    if (!doesVaryOnSearchParams) {\n      // The response from the the server will not vary on search params. Clone\n      // the end of the original vary path to replace the search params\n      // with Fallback.\n      //\n      // requestKey -> searchParams -> pathParams\n      //               ^ This part gets replaced with Fallback\n      const searchParamsVaryPath = (originalVaryPath as PageVaryPath).parent\n      const pathParamsVaryPath = searchParamsVaryPath.parent\n      const patchedVaryPath: VaryPath = {\n        id: null,\n        value: originalVaryPath.value,\n        parent: {\n          id: '?',\n          value: Fallback,\n          parent: pathParamsVaryPath,\n        },\n      }\n      return patchedVaryPath as SegmentVaryPath\n    }\n  }\n\n  // The request does vary on search params. We don't need to modify anything.\n  return originalVaryPath as SegmentVaryPath\n}\n\nexport function clonePageVaryPathWithNewSearchParams(\n  originalVaryPath: PageVaryPath,\n  newSearch: NormalizedSearch\n): PageVaryPath {\n  // requestKey -> searchParams -> pathParams\n  //               ^ This part gets replaced with newSearch\n  const searchParamsVaryPath = originalVaryPath.parent\n  const clonedVaryPath: VaryPath = {\n    id: null,\n    value: originalVaryPath.value,\n    parent: {\n      id: '?',\n      value: newSearch,\n      parent: searchParamsVaryPath.parent,\n    },\n  }\n  return clonedVaryPath as PageVaryPath\n}\n\nexport function getRenderedSearchFromVaryPath(\n  varyPath: PageVaryPath\n): NormalizedSearch | null {\n  const searchParams = varyPath.parent.value\n  return typeof searchParams === 'string'\n    ? (searchParams as NormalizedSearch)\n    : null\n}\n\nexport function getFulfilledSegmentVaryPath(\n  original: VaryPath,\n  varyParams: Set<string>\n): SegmentVaryPath {\n  // Re-keys a segment's vary path based on which params the segment actually\n  // depends on. Params that are NOT in the varyParams set are replaced with\n  // Fallback, allowing the cache entry to be reused across different values of\n  // those params.\n\n  // This is called when a segment is fulfilled with data from the server. The\n  // varyParams set comes from the server and indicates which params were\n  // accessed during rendering.\n  const clone: VaryPath = {\n    id: original.id,\n    // If the id is null, this node is not a param (e.g., it's a request key).\n    // If the id is in the varyParams set, keep the original value.\n    // Otherwise, replace with Fallback to make it reusable.\n    value:\n      original.id === null || varyParams.has(original.id)\n        ? original.value\n        : Fallback,\n    parent:\n      original.parent === null\n        ? null\n        : getFulfilledSegmentVaryPath(original.parent, varyParams),\n  }\n  return clone as SegmentVaryPath\n}\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport type { RouteTree } from '../segment-cache/cache'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: RouteTree\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree.segment\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree.isRootLayout\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree.isRootLayout) {\n    return true\n  }\n\n  const slots = nextTree.slots\n  const currentTreeChildren = currentTree[1]\n  if (slots !== null) {\n    for (const slot in slots) {\n      const nextTreeChild = slots[slot]\n      const currentTreeChild = currentTreeChildren[slot]\n      if (\n        currentTreeChild === undefined ||\n        isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n      ) {\n        return true\n      }\n    }\n  }\n  return false\n}\n","/**\n * Optimistic Routing (Known Routes)\n *\n * This module enables the client to predict route structure for URLs that\n * haven't been prefetched yet, based on previously learned route patterns.\n * When successful, this allows skipping the route tree prefetch request\n * entirely.\n *\n * The core idea is that many URLs map to the same route structure. For example,\n * /blog/post-1 and /blog/post-2 both resolve to /blog/[slug]. Once we've\n * prefetched one, we can predict the structure of the other.\n *\n * However, we can't always make this prediction. Static siblings (like\n * /blog/featured alongside /blog/[slug]) have different route structures.\n * When we learn a dynamic route, we also learn its static siblings so we\n * know when NOT to apply the prediction.\n *\n * Main entry points:\n *\n * 1. discoverKnownRoute: Called after receiving a route tree from the server.\n *    Traverses the route tree, compares URL parts to segments, and populates\n *    the known route tree if they match. Routes are always inserted into the\n *    cache.\n *\n * 2. matchKnownRoute: Called when looking up a route with no cache entry.\n *    Matches the candidate URL against learned patterns. Returns a synthetic\n *    cache entry if successful, or null to fall back to server resolution.\n *\n * Rewrite detection happens during traversal: if a URL path part doesn't match\n * the corresponding route segment, we stop populating the known route tree\n * (since the mapping is incorrect) but still insert the route into the cache.\n *\n * The known route tree is append-only with no eviction. Route patterns are\n * derived from the filesystem, so they don't become stale within a session.\n * Cache invalidation on deploy clears everything anyway.\n *\n * Current limitations (deopt to server resolution):\n * - Rewrites: Detected during traversal (tree not populated, but route cached)\n * - Intercepted routes: Routes using (.), (..), (...) patterns\n */\n\nimport type { DynamicParamTypesShort } from '../../../shared/lib/app-router-types'\nimport type { RouteTree, FulfilledRouteCacheEntry } from './cache'\nimport {\n  EntryStatus,\n  writeRouteIntoCache,\n  fulfillRouteCacheEntry,\n  type PendingRouteCacheEntry,\n  createMetadataRouteTree,\n} from './cache'\nimport { doesStaticSegmentAppearInURL } from '../../route-params'\nimport type { NormalizedPathname, NormalizedSearch } from './cache-key'\nimport {\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  finalizeMetadataVaryPath,\n  type PartialSegmentVaryPath,\n  type PageVaryPath,\n} from './vary-path'\n\n/**\n * The known route tree is analogous to a route table. A different routing\n * implementation might use regexes or URLPattern; ours uses a trie indexed\n * by URL path segments.\n *\n * Each node (KnownRoutePart) represents a position in the URL and can have:\n * - staticChildren: Map of literal segments to child nodes\n * - dynamicChild: A single dynamic segment node ([slug], [...params], etc.)\n * - pattern: A cache entry template for routes that terminate here\n *\n * This tree only contains segments that correspond to actual filesystem routes.\n * Route groups like (marketing) and parallel routes like @modal are not\n * included since they don't appear in URLs. Similarly, if a URL is rewritten\n * to a different filesystem path, the original URL segments don't appear here\n * — only the resolved filesystem route structure is stored.\n *\n * Example tree after learning /blog/[slug], /blog/featured, and /about:\n *\n *   ├── about\n *   └── blog\n *       ├── featured\n *       └── [slug]\n *\n * When matching /blog/hello:\n *   1. \"blog\" matches static child\n *   2. \"hello\" doesn't match \"featured\", falls through to [slug]\n *   3. Returns [slug]'s pattern with resolved param { slug: \"hello\" }\n */\ntype KnownRoutePartBase = {\n  // Known static paths at this level. The null vs Map distinction is\n  // semantically meaningful:\n  // - null: Static siblings are UNKNOWN at this level (e.g., webpack dev mode\n  //   where routes are compiled on-demand). If there's a dynamicChild, we\n  //   can't safely match it because the URL might be an unknown static sibling.\n  // - Map (even if empty): Static siblings are KNOWN. We can safely match a\n  //   dynamicChild if the URL doesn't match any entry in the Map.\n  staticChildren: Map<string, KnownRoutePart> | null\n\n  // The cache entry that serves as a pattern for this route.\n  // When a URL matches, we clone this and substitute param values.\n  // null means we know this path exists (from static siblings) but haven't\n  // learned its structure yet.\n  pattern: FulfilledRouteCacheEntry | null\n\n  // TODO: For prefix rewrite support. When true, this part may not appear in\n  // the candidate URL because it was injected by a rewrite.\n  // mayBeSkippedInURL: boolean\n}\n\n// The dynamic child fields are structured as a union so that narrowing on\n// dynamicChild also narrows dynamicChildParamName and dynamicChildParamType.\ntype KnownRoutePartWithoutDynamicChild = KnownRoutePartBase & {\n  dynamicChild: null\n  dynamicChildParamName: null\n  dynamicChildParamType: null\n}\n\ntype KnownRoutePartWithDynamicChild = KnownRoutePartBase & {\n  dynamicChild: KnownRoutePart\n  dynamicChildParamName: string\n  dynamicChildParamType: DynamicParamTypesShort\n}\n\ntype KnownRoutePart =\n  | KnownRoutePartWithoutDynamicChild\n  | KnownRoutePartWithDynamicChild\n\n/**\n * Param values extracted during URL matching. Used to reify the template.\n * - string for regular dynamic [param]\n * - string[] for catch-all [...param] and optional catch-all [[...param]]\n */\ntype ResolvedParams = Map<string, string | string[]>\n\nfunction createEmptyPart(): KnownRoutePart {\n  return {\n    staticChildren: null,\n    dynamicChild: null,\n    dynamicChildParamName: null,\n    dynamicChildParamType: null,\n    pattern: null,\n  }\n}\n\n// The root of the known route tree.\nlet knownRouteTreeRoot: KnownRoutePart = createEmptyPart()\n\n/**\n * Learns a route pattern from a server response and inserts it into the cache.\n *\n * Called after receiving a route tree from the server (initial load, navigation,\n * or prefetch). Traverses the route tree, compares URL parts to segments, and\n * populates the known route tree if they match. Routes are always inserted into\n * the cache regardless of whether the URL matches the route structure.\n *\n * When pendingEntry is provided, it's fulfilled and used. When null, an entry\n * is created and inserted into the route cache map.\n *\n * When hasDynamicRewrite is true, the route entry is marked as having a\n * dynamic rewrite, which prevents it from being used as a template for future\n * predictions. This is set when we detect a mismatch between what we predicted\n * and what the server returned.\n *\n * Returns the fulfilled route cache entry.\n */\nexport function discoverKnownRoute(\n  now: number,\n  pathname: string,\n  pendingEntry: PendingRouteCacheEntry | null,\n  routeTree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean,\n  hasDynamicRewrite: boolean\n): FulfilledRouteCacheEntry {\n  const tree = routeTree\n\n  const pathnameParts = pathname.split('/').filter((p) => p !== '')\n  const firstPart = pathnameParts.length > 0 ? pathnameParts[0] : null\n  const remainingParts = pathnameParts.length > 0 ? pathnameParts.slice(1) : []\n\n  if (pendingEntry !== null) {\n    // Fulfill the pending entry first\n    const fulfilledEntry = fulfillRouteCacheEntry(\n      now,\n      pendingEntry,\n      tree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled\n    )\n    if (hasDynamicRewrite) {\n      fulfilledEntry.hasDynamicRewrite = true\n    }\n    // Populate the known route tree (handles rewrite detection internally).\n    // The entry is already in the cache; this just stores it as a pattern\n    // if the URL matches the route structure.\n    discoverKnownRoutePart(\n      knownRouteTreeRoot,\n      tree,\n      firstPart,\n      remainingParts,\n      fulfilledEntry,\n      now,\n      pathname,\n      tree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled,\n      hasDynamicRewrite\n    )\n    return fulfilledEntry\n  }\n\n  // No pending entry - discoverKnownRoutePart will create one and insert it\n  // into the cache, or return an existing pattern if one exists.\n  return discoverKnownRoutePart(\n    knownRouteTreeRoot,\n    tree,\n    firstPart,\n    remainingParts,\n    null,\n    now,\n    pathname,\n    tree,\n    metadataVaryPath,\n    couldBeIntercepted,\n    canonicalUrl,\n    isPPREnabled,\n    hasDynamicRewrite\n  )\n}\n\n/**\n * Gets or creates the dynamic child node for a KnownRoutePart.\n * A node can have at most one dynamic child (you can't have both [slug] and\n * [id] at the same route level), so we either return existing or create new.\n */\nfunction discoverDynamicChild(\n  part: KnownRoutePart,\n  paramName: string,\n  paramType: DynamicParamTypesShort\n): KnownRoutePart {\n  if (part.dynamicChild !== null) {\n    return part.dynamicChild\n  }\n  const newChild = createEmptyPart()\n  // Type assertion needed because we're converting from \"without\" to \"with\"\n  // dynamic child variant.\n  const mutablePart = part as unknown as KnownRoutePartWithDynamicChild\n  mutablePart.dynamicChild = newChild\n  mutablePart.dynamicChildParamName = paramName\n  mutablePart.dynamicChildParamType = paramType\n  return newChild\n}\n\n/**\n * Recursive workhorse for discoverKnownRoute.\n *\n * Walks the route tree and URL parts in parallel, building out the known\n * route tree as it goes. At each step:\n * 1. Determines if the current segment appears in the URL (dynamic/static)\n * 2. Validates URL matches route structure (detects rewrites)\n * 3. Creates/updates the corresponding KnownRoutePart node\n * 4. Records static siblings for future matching\n * 5. Recurses into child slots (parallel routes)\n *\n * If a URL/route mismatch is detected (rewrite), we stop building the known\n * route tree but still cache the route entry for direct lookup.\n */\nfunction discoverKnownRoutePart(\n  parentKnownRoutePart: KnownRoutePart,\n  routeTree: RouteTree,\n  urlPart: string | null,\n  remainingParts: string[],\n  existingEntry: FulfilledRouteCacheEntry | null,\n  // These are passed through unchanged for entry creation at the leaf\n  now: number,\n  pathname: string,\n  fullTree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean,\n  hasDynamicRewrite: boolean\n): FulfilledRouteCacheEntry {\n  const segment = routeTree.segment\n\n  let segmentAppearsInURL: boolean\n  let paramName: string | null = null\n  let paramType: DynamicParamTypesShort | null = null\n  let staticSiblings: readonly string[] | null = null\n\n  if (typeof segment === 'string') {\n    segmentAppearsInURL = doesStaticSegmentAppearInURL(segment)\n  } else {\n    // Dynamic segment tuple: [paramName, paramCacheKey, paramType, staticSiblings]\n    paramName = segment[0]\n    paramType = segment[2]\n    staticSiblings = segment[3]\n    segmentAppearsInURL = true\n  }\n\n  let knownRoutePart: KnownRoutePart = parentKnownRoutePart\n  let nextUrlPart: string | null = urlPart\n  let nextRemainingParts: string[] = remainingParts\n\n  if (segmentAppearsInURL) {\n    // Check for mismatch: if this is a static segment, the URL part must match\n    if (paramName === null && urlPart !== segment) {\n      // URL doesn't match route structure (likely a rewrite).\n      // Don't populate the known route tree, just write the route into the\n      // cache and return immediately.\n      if (existingEntry !== null) {\n        return existingEntry\n      }\n      return writeRouteIntoCache(\n        now,\n        pathname as NormalizedPathname,\n        fullTree,\n        metadataVaryPath,\n        couldBeIntercepted,\n        canonicalUrl,\n        isPPREnabled\n      )\n    }\n\n    // URL matches route structure. Build the known route tree.\n    if (paramName !== null && paramType !== null) {\n      // Dynamic segment\n      knownRoutePart = discoverDynamicChild(\n        parentKnownRoutePart,\n        paramName,\n        paramType\n      )\n\n      // Record static siblings as placeholder parts.\n      // IMPORTANT: We use the null vs Map distinction to track whether\n      // siblings are known at this level:\n      // - staticChildren: null = siblings unknown (can't safely match dynamic)\n      // - staticChildren: Map = siblings known (even if empty)\n      // This matters in dev mode where webpack may not know all siblings yet.\n      if (staticSiblings !== null) {\n        // Siblings are known - ensure we have a Map (even if empty)\n        if (parentKnownRoutePart.staticChildren === null) {\n          parentKnownRoutePart.staticChildren = new Map()\n        }\n        for (const sibling of staticSiblings) {\n          if (!parentKnownRoutePart.staticChildren.has(sibling)) {\n            parentKnownRoutePart.staticChildren.set(sibling, createEmptyPart())\n          }\n        }\n      }\n    } else {\n      // Static segment\n      if (parentKnownRoutePart.staticChildren === null) {\n        parentKnownRoutePart.staticChildren = new Map()\n      }\n      let existingChild = parentKnownRoutePart.staticChildren.get(urlPart!)\n      if (existingChild === undefined) {\n        existingChild = createEmptyPart()\n        parentKnownRoutePart.staticChildren.set(urlPart!, existingChild)\n      }\n      knownRoutePart = existingChild\n    }\n\n    // Advance to next URL part\n    nextUrlPart = remainingParts.length > 0 ? remainingParts[0] : null\n    nextRemainingParts =\n      remainingParts.length > 0 ? remainingParts.slice(1) : []\n  }\n  // else: Transparent segment (route group, __PAGE__, etc.)\n  // Stay at the same known route part, don't advance URL parts\n\n  // Recurse into child routes. A route tree can have multiple parallel routes\n  // (e.g., @modal alongside children). Each parallel route is a separate\n  // branch, but they all share the same URL - we just need to traverse all\n  // branches to build out the known route tree.\n  const slots = routeTree.slots\n  let resultFromChildren: FulfilledRouteCacheEntry | null = null\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childRouteTree = slots[parallelRouteKey]\n      // Skip branches with refreshState set - these were reused from a\n      // different route (e.g., a \"default\" parallel slot) and don't represent\n      // the actual route structure for this URL.\n      if (childRouteTree.refreshState !== null) {\n        continue\n      }\n      const result = discoverKnownRoutePart(\n        knownRoutePart,\n        childRouteTree,\n        nextUrlPart,\n        nextRemainingParts,\n        existingEntry,\n        now,\n        pathname,\n        fullTree,\n        metadataVaryPath,\n        couldBeIntercepted,\n        canonicalUrl,\n        isPPREnabled,\n        hasDynamicRewrite\n      )\n      // All parallel route branches share the same URL, so they should all\n      // reach compatible leaf nodes. We capture any result.\n      resultFromChildren = result\n    }\n    if (resultFromChildren !== null) {\n      return resultFromChildren\n    }\n    // Defensive fallback: no children returned a result. This shouldn't happen\n    // for valid route trees, but handle it gracefully.\n    if (existingEntry !== null) {\n      return existingEntry\n    }\n    return writeRouteIntoCache(\n      now,\n      pathname as NormalizedPathname,\n      fullTree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled\n    )\n  }\n\n  // Reached a page node. Create/get the route cache entry and store as a\n  // pattern. First, check if there's already a pattern for this route.\n  if (knownRoutePart.pattern !== null) {\n    // If this route has a dynamic rewrite, mark the existing pattern.\n    if (hasDynamicRewrite) {\n      knownRoutePart.pattern.hasDynamicRewrite = true\n    }\n    return knownRoutePart.pattern\n  }\n\n  // Get or create the entry\n  let entry: FulfilledRouteCacheEntry\n  if (existingEntry !== null) {\n    // Already have a fulfilled entry, use it directly. It's already in the\n    // route cache map.\n    entry = existingEntry\n  } else {\n    // Create the entry and insert it into the route cache map.\n    entry = writeRouteIntoCache(\n      now,\n      pathname as NormalizedPathname,\n      fullTree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      canonicalUrl,\n      isPPREnabled\n    )\n  }\n\n  if (hasDynamicRewrite) {\n    entry.hasDynamicRewrite = true\n  }\n\n  // Store as pattern\n  knownRoutePart.pattern = entry\n  return entry\n}\n\n/**\n * Attempts to match a URL against learned route patterns.\n *\n * Returns a synthetic FulfilledRouteCacheEntry if the URL matches a known\n * pattern, or null if no match is found (fall back to server resolution).\n */\nexport function matchKnownRoute(\n  pathname: string,\n  search: NormalizedSearch\n): FulfilledRouteCacheEntry | null {\n  const pathnameParts = pathname.split('/').filter((p) => p !== '')\n  const resolvedParams: ResolvedParams = new Map()\n  const match = matchKnownRoutePart(\n    knownRouteTreeRoot,\n    pathnameParts,\n    0,\n    resolvedParams\n  )\n\n  if (match === null) {\n    return null\n  }\n\n  const matchedPart = match.part\n  const pattern = match.pattern\n\n  // If the pattern could be intercepted, we can't safely use it for prediction\n  // because the route structure may vary based on the Next-Url header.\n  if (pattern.couldBeIntercepted) {\n    return null\n  }\n\n  // \"Reify\" the pattern: clone the template tree with concrete param values.\n  // This substitutes resolved params (e.g., slug: \"hello\") into dynamic\n  // segments and recomputes vary paths for correct segment cache keying.\n  const acc: ReifyAccumulator = { metadataVaryPath: null }\n  const reifiedTree = reifyRouteTree(\n    pattern.tree,\n    resolvedParams,\n    search,\n    null, // Start with null partial vary path at the root\n    acc\n  )\n\n  // The metadata tree is a flat page node without the intermediate layout\n  // structure. Clone it with the updated metadata vary path collected during\n  // the main tree traversal.\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    // This shouldn't be reachable for a valid route tree.\n    return null\n  }\n  const reifiedMetadata = createMetadataRouteTree(metadataVaryPath)\n\n  // Create a synthetic (predicted) entry and store it as the new pattern.\n  //\n  // Why replace the pattern? We intentionally update the pattern with this\n  // synthetic entry so that if our prediction was wrong (server returns a\n  // different pathname due to dynamic rewrite), the entry gets marked with\n  // hasDynamicRewrite. Future predictions for this route will see the flag\n  // and bail out to server resolution instead of making the same mistake.\n  const syntheticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: pathname + search,\n    status: EntryStatus.Fulfilled,\n    blockedTasks: null,\n    tree: reifiedTree,\n    metadata: reifiedMetadata,\n    couldBeIntercepted: pattern.couldBeIntercepted,\n    isPPREnabled: pattern.isPPREnabled,\n    hasDynamicRewrite: false,\n    renderedSearch: search,\n    ref: null,\n    size: pattern.size,\n    staleAt: pattern.staleAt,\n    version: pattern.version,\n  }\n\n  matchedPart.pattern = syntheticEntry\n\n  return syntheticEntry\n}\n\n/**\n * Result of a successful match: the matched tree node and its pattern.\n * We return both because the caller needs to update the pattern after\n * creating a synthetic entry (for dynamic rewrite detection).\n */\ntype KnownRouteMatch = {\n  part: KnownRoutePart\n  pattern: FulfilledRouteCacheEntry\n} | null\n\n/**\n * Recursively matches a URL against the known route tree.\n *\n * Matching priority (most specific first):\n * 1. Static children - exact path segment match\n * 2. Dynamic child - [param], [...param], [[...param]]\n * 3. Direct pattern - when no more URL parts remain\n *\n * Collects resolved param values in resolvedParams as it traverses.\n * Returns null if no match found (caller should fall back to server).\n */\nfunction matchKnownRoutePart(\n  part: KnownRoutePart,\n  pathnameParts: string[],\n  partIndex: number,\n  resolvedParams: ResolvedParams\n): KnownRouteMatch {\n  const urlPart =\n    partIndex < pathnameParts.length ? pathnameParts[partIndex] : null\n\n  // If staticChildren is null, we don't know what static routes exist at this\n  // level. This happens in webpack dev mode where routes are compiled\n  // on-demand. We can't safely match a dynamicChild because the URL part might\n  // be a static sibling we haven't discovered yet. Example: We know\n  // /blog/[slug] exists, but haven't compiled /blog/featured. A request for\n  // /blog/featured would incorrectly match /blog/[slug].\n  if (part.staticChildren === null) {\n    // The only safe match is a direct pattern when no URL parts remain.\n    if (urlPart === null) {\n      const pattern = part.pattern\n      if (pattern !== null && !pattern.hasDynamicRewrite) {\n        return { part, pattern }\n      }\n    }\n    return null\n  }\n\n  // Static children take priority over dynamic. This ensures /blog/featured\n  // matches its own route rather than /blog/[slug].\n  if (urlPart !== null) {\n    const staticChild = part.staticChildren.get(urlPart)\n    if (staticChild !== undefined) {\n      // Check if this is an \"unknown\" placeholder part. These are created when\n      // we learn about static siblings (from the route tree's staticSiblings\n      // field) but haven't prefetched them yet. We know the path exists but\n      // don't know its structure, so we can't predict it.\n      if (\n        staticChild.pattern === null &&\n        staticChild.dynamicChild === null &&\n        staticChild.staticChildren === null\n      ) {\n        // Bail out - server must resolve this route.\n        return null\n      }\n      const match = matchKnownRoutePart(\n        staticChild,\n        pathnameParts,\n        partIndex + 1,\n        resolvedParams\n      )\n      if (match !== null) {\n        return match\n      }\n      // Static child exists but didn't match (e.g., wrong depth).\n      // Fall through to try dynamic.\n    }\n  }\n\n  // Try dynamic child\n  if (part.dynamicChild !== null) {\n    const dynamicPart = part.dynamicChild\n    const paramName = part.dynamicChildParamName\n    const paramType = part.dynamicChildParamType\n    const dynamicPattern = dynamicPart.pattern\n\n    switch (paramType) {\n      case 'c':\n        // Required catch-all [...param]: consumes 1+ URL parts\n        if (\n          dynamicPattern !== null &&\n          !dynamicPattern.hasDynamicRewrite &&\n          urlPart !== null\n        ) {\n          resolvedParams.set(paramName, pathnameParts.slice(partIndex))\n          return { part: dynamicPart, pattern: dynamicPattern }\n        }\n        break\n      case 'oc':\n        // Optional catch-all [[...param]]: consumes 0+ URL parts\n        if (dynamicPattern !== null && !dynamicPattern.hasDynamicRewrite) {\n          if (urlPart !== null) {\n            resolvedParams.set(paramName, pathnameParts.slice(partIndex))\n            return { part: dynamicPart, pattern: dynamicPattern }\n          }\n          // urlPart is null - can match with zero parts, but a direct pattern\n          // (e.g., page.tsx alongside [[...param]]) takes precedence.\n          if (part.pattern === null || part.pattern.hasDynamicRewrite) {\n            resolvedParams.set(paramName, [])\n            return { part: dynamicPart, pattern: dynamicPattern }\n          }\n        }\n        break\n      case 'd':\n        // Regular dynamic [param]: consumes exactly 1 URL part.\n        // Unlike catch-all which terminates here, regular dynamic must\n        // continue recursing to find the leaf pattern.\n        if (urlPart !== null) {\n          resolvedParams.set(paramName, urlPart)\n          return matchKnownRoutePart(\n            dynamicPart,\n            pathnameParts,\n            partIndex + 1,\n            resolvedParams\n          )\n        }\n        break\n      // Intercepted routes use relative path markers like (.), (..), (...)\n      // Their behavior depends on navigation context (soft vs hard nav),\n      // so we can't predict them client-side. Defer to server.\n      case 'ci(..)(..)':\n      case 'ci(.)':\n      case 'ci(..)':\n      case 'ci(...)':\n      case 'di(..)(..)':\n      case 'di(.)':\n      case 'di(..)':\n      case 'di(...)':\n        return null\n      default:\n        paramType satisfies never\n    }\n  }\n\n  // No children matched. If we've consumed all URL parts, check for a direct\n  // pattern at this node (the route terminates here).\n  if (urlPart === null) {\n    const pattern = part.pattern\n    if (pattern !== null && !pattern.hasDynamicRewrite) {\n      return { part, pattern }\n    }\n  }\n\n  return null\n}\n\n/**\n * Accumulator for collecting data during reifyRouteTree traversal.\n * metadataVaryPath is collected from the first page node encountered\n * (parallel routes may have multiple pages, but metadata uses the first).\n */\ntype ReifyAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\n/**\n * \"Reify\" means to make concrete - we take an abstract pattern (the template\n * route tree) and produce a concrete instance with actual param values.\n *\n * This function clones a RouteTree, substituting dynamic segment values from\n * resolvedParams and computing new vary paths. The vary path encodes param\n * values so segment cache entries can be correctly keyed.\n *\n * Example: Pattern for /blog/[slug] with resolvedParams { slug: \"hello\" }\n * produces a tree where segment [slug] has cacheKey \"hello\".\n */\nfunction reifyRouteTree(\n  pattern: RouteTree,\n  resolvedParams: ResolvedParams,\n  search: NormalizedSearch,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  acc: ReifyAccumulator\n): RouteTree {\n  const originalSegment = pattern.segment\n\n  let newSegment = originalSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n\n  if (typeof originalSegment !== 'string') {\n    // Dynamic segment: compute new cache key and append to partial vary path\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const staticSiblings = originalSegment[3]\n    const newValue = resolvedParams.get(paramName)\n    if (newValue !== undefined) {\n      const newCacheKey = Array.isArray(newValue)\n        ? newValue.join('/')\n        : newValue\n      newSegment = [paramName, newCacheKey, paramType, staticSiblings]\n      partialVaryPath = appendLayoutVaryPath(\n        parentPartialVaryPath,\n        newCacheKey,\n        paramName\n      )\n    } else {\n      // Param not found in resolvedParams - keep original and inherit partial\n      // TODO: This should never happen. Bail out with null.\n      partialVaryPath = parentPartialVaryPath\n    }\n  } else {\n    // Static segment: inherit partial vary path from parent\n    partialVaryPath = parentPartialVaryPath\n  }\n\n  // Recurse into children with the (possibly updated) partial vary path\n  let newSlots: Record<string, RouteTree> | null = null\n  if (pattern.slots !== null) {\n    newSlots = {}\n    for (const key in pattern.slots) {\n      newSlots[key] = reifyRouteTree(\n        pattern.slots[key],\n        resolvedParams,\n        search,\n        partialVaryPath,\n        acc\n      )\n    }\n  }\n\n  if (pattern.isPage) {\n    // Page segment: finalize with search params\n    const newVaryPath = finalizePageVaryPath(\n      pattern.requestKey,\n      search,\n      partialVaryPath\n    )\n    // Collect metadata vary path (first page wins, same as original algorithm)\n    if (acc.metadataVaryPath === null) {\n      acc.metadataVaryPath = finalizeMetadataVaryPath(\n        pattern.requestKey,\n        search,\n        partialVaryPath\n      )\n    }\n    return {\n      requestKey: pattern.requestKey,\n      segment: newSegment,\n      refreshState: pattern.refreshState,\n      slots: newSlots,\n      isRootLayout: pattern.isRootLayout,\n      hasLoadingBoundary: pattern.hasLoadingBoundary,\n      hasRuntimePrefetch: pattern.hasRuntimePrefetch,\n      isPage: true,\n      varyPath: newVaryPath,\n    }\n  } else {\n    // Layout segment: finalize without search params\n    const newVaryPath = finalizeLayoutVaryPath(\n      pattern.requestKey,\n      partialVaryPath\n    )\n    return {\n      requestKey: pattern.requestKey,\n      segment: newSegment,\n      refreshState: pattern.refreshState,\n      slots: newSlots,\n      isRootLayout: pattern.isRootLayout,\n      hasLoadingBoundary: pattern.hasLoadingBoundary,\n      hasRuntimePrefetch: pattern.hasRuntimePrefetch,\n      isPage: false,\n      varyPath: newVaryPath,\n    }\n  }\n}\n\n/**\n * Resets the known route tree. Called during development when routes may\n * change due to hot reloading.\n */\nexport function resetKnownRoutes(): void {\n  knownRouteTreeRoot = createEmptyPart()\n}\n","import type { SegmentVaryPath } from './vary-path'\nimport {\n  setInCacheMap,\n  getFromCacheMap,\n  type UnknownMapEntry,\n  type CacheMap,\n  createCacheMap,\n} from './cache-map'\nimport { DYNAMIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\n\nexport type BFCacheEntry = {\n  rsc: React.ReactNode | null\n  prefetchRsc: React.ReactNode | null\n  head: React.ReactNode | null\n  prefetchHead: React.ReactNode | null\n\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nconst bfcacheMap: CacheMap<BFCacheEntry> = createCacheMap()\n\nlet currentBfCacheVersion = 0\n\nexport function invalidateBfCache(): void {\n  currentBfCacheVersion++\n}\n\nexport function writeToBFCache(\n  now: number,\n  varyPath: SegmentVaryPath,\n  rsc: React.ReactNode,\n  prefetchRsc: React.ReactNode,\n  head: React.ReactNode,\n  prefetchHead: React.ReactNode\n): void {\n  const entry: BFCacheEntry = {\n    rsc,\n    prefetchRsc,\n\n    // TODO: These fields will be removed from both BFCacheEntry and\n    // SegmentCacheEntry. The head has its own separate cache entry.\n    head,\n    prefetchHead,\n\n    ref: null,\n    // TODO: This is just a heuristic. Getting the actual size of the segment\n    // isn't feasible because it's part of a larger streaming response. The\n    // LRU will still evict it, we just won't have a fully accurate total\n    // LRU size. However, we'll probably remove the size tracking from the LRU\n    // entirely and use memory pressure events instead.\n    size: 100,\n\n    // A back/forward navigation will disregard the stale time. This field is\n    // only relevant when staleTimes.dynamic is enabled.\n    staleAt: now + DYNAMIC_STALETIME_MS,\n    version: currentBfCacheVersion,\n  }\n  const isRevalidation = false\n  setInCacheMap(bfcacheMap, varyPath, entry, isRevalidation)\n}\n\nexport function writeHeadToBFCache(\n  now: number,\n  varyPath: SegmentVaryPath,\n  head: React.ReactNode,\n  prefetchHead: React.ReactNode\n): void {\n  // Read the special \"segment\" that represents the head data.\n  writeToBFCache(now, varyPath, head, prefetchHead, null, null)\n}\n\nexport function readFromBFCache(\n  varyPath: SegmentVaryPath\n): BFCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    // During a back/forward navigation, it doesn't matter how stale the data\n    // might be. Pass -1 instead of the actual current time to bypass\n    // staleness checks.\n    -1,\n    currentBfCacheVersion,\n    bfcacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function readFromBFCacheDuringRegularNavigation(\n  now: number,\n  varyPath: SegmentVaryPath\n): BFCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    currentBfCacheVersion,\n    bfcacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type { HeadData } from '../../../shared/lib/app-router-types'\nimport {\n  PAGE_SEGMENT_KEY,\n  DEFAULT_SEGMENT_KEY,\n  NOT_FOUND_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { dispatchAppRouterAction } from '../use-action-queue'\nimport {\n  ACTION_SERVER_PATCH,\n  type ServerPatchAction,\n} from './router-reducer-types'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport {\n  convertServerPatchToFullTree,\n  type NavigationSeed,\n} from '../segment-cache/navigation'\nimport {\n  type RouteTree,\n  type RefreshState,\n  type FulfilledRouteCacheEntry,\n  convertReusedFlightRouterStateToRouteTree,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  markRouteEntryAsDynamicRewrite,\n  invalidateRouteCacheEntries,\n  EntryStatus,\n} from '../segment-cache/cache'\nimport { discoverKnownRoute } from '../segment-cache/optimistic-routes'\nimport type { NormalizedSearch } from '../segment-cache/cache-key'\nimport {\n  getRenderedSearchFromVaryPath,\n  type PageVaryPath,\n} from '../segment-cache/vary-path'\nimport {\n  readFromBFCache,\n  readFromBFCacheDuringRegularNavigation,\n  writeToBFCache,\n  writeHeadToBFCache,\n} from '../segment-cache/bfcache'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\nexport type NavigationTask = {\n  status: NavigationTaskStatus\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents.\n  node: CacheNode\n  // The tree sent to the server during the dynamic request. If all the segments\n  // are static, then this will be null, and no server request is required.\n  // Otherwise, this is the same as `route`, except with the `refetch` marker\n  // set on the top-most segment that needs to be fetched.\n  dynamicRequestTree: FlightRouterState | null\n  // The URL that should be used to fetch the dynamic data. This is only set\n  // when the segment cannot be refetched from the current route, because it's\n  // part of a \"default\" parallel slot that was reused during a navigation.\n  refreshState: RefreshState | null\n  children: Map<string, NavigationTask> | null\n}\n\nexport const enum FreshnessPolicy {\n  Default,\n  Hydration,\n  HistoryTraversal,\n  RefreshAll,\n  HMRRefresh,\n  Gesture,\n}\n\nconst enum NavigationTaskStatus {\n  Pending,\n  Fulfilled,\n  Rejected,\n}\n\n/**\n * When a NavigationTask finishes, there may or may not be data still missing,\n * necessitating a retry.\n */\nconst enum NavigationTaskExitStatus {\n  /**\n   * No additional navigation is required.\n   */\n  Done = 0,\n  /**\n   * Some data failed to load, presumably due to a route tree mismatch. Perform\n   * a soft retry to reload the entire tree.\n   */\n  SoftRetry = 1,\n  /**\n   * Some data failed to load in an unrecoverable way, e.g. in an inactive\n   * parallel route. Fall back to a hard (MPA-style) retry.\n   */\n  HardRetry = 2,\n}\n\nexport type NavigationRequestAccumulation = {\n  scrollableSegments: Array<FlightSegmentPath> | null\n  separateRefreshUrls: Set<string> | null\n}\n\nconst noop = () => {}\n\nexport function createInitialCacheNodeForHydration(\n  navigatedAt: number,\n  initialTree: RouteTree,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData\n): NavigationTask {\n  // Create the initial cache node tree, using the data embedded into the\n  // HTML document.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  const task = createCacheNodeOnNavigation(\n    navigatedAt,\n    initialTree,\n    null,\n    FreshnessPolicy.Hydration,\n    seedData,\n    seedHead,\n    null,\n    null,\n    false,\n    accumulation\n  )\n  return task\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldRenderedSearch: string,\n  oldCacheNode: CacheNode | null,\n  oldRouterState: FlightRouterState,\n  newRouteTree: RouteTree,\n  newMetadataVaryPath: PageVaryPath | null,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  isSamePageNavigation: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  const didFindRootLayout = false\n  const parentNeedsDynamicRequest = false\n  const parentRefreshState = null\n  const oldRootRefreshState: RefreshState = {\n    canonicalUrl: createHrefFromUrl(oldUrl),\n    renderedSearch: oldRenderedSearch as NormalizedSearch,\n  }\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode !== null ? oldCacheNode : undefined,\n    oldRouterState,\n    newRouteTree,\n    newMetadataVaryPath,\n    freshness,\n    didFindRootLayout,\n    seedData,\n    seedHead,\n    isSamePageNavigation,\n    null,\n    null,\n    parentNeedsDynamicRequest,\n    oldRootRefreshState,\n    parentRefreshState,\n    accumulation\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode | void,\n  oldRouterState: FlightRouterState,\n  newRouteTree: RouteTree,\n  newMetadataVaryPath: PageVaryPath | null,\n  freshness: FreshnessPolicy,\n  didFindRootLayout: boolean,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  isSamePageNavigation: boolean,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  oldRootRefreshState: RefreshState,\n  parentRefreshState: RefreshState | null,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask | null {\n  // Check if this segment matches the one in the previous route.\n  const oldSegment = oldRouterState[0]\n  const newSegment = createSegmentFromRouteTree(newRouteTree)\n  if (!matchSegment(newSegment, oldSegment)) {\n    // This segment does not match the previous route. We're now entering the\n    // new part of the target route. Switch to the \"create\" path.\n    if (\n      // Check if the route tree changed before we reached a layout. (The\n      // highest-level layout in a route tree is referred to as the \"root\"\n      // layout.) This could mean that we're navigating between two different\n      // root layouts. When this happens, we perform a full-page (MPA-style)\n      // navigation.\n      //\n      // However, the algorithm for deciding where to start rendering a route\n      // (i.e. the one performed in order to reach this function) is stricter\n      // than the one used to detect a change in the root layout. So just\n      // because we're re-rendering a segment outside of the root layout does\n      // not mean we should trigger a full-page navigation.\n      //\n      // Specifically, we handle dynamic parameters differently: two segments\n      // are considered the same even if their parameter values are different.\n      //\n      // Refer to isNavigatingToNewRootLayout for details.\n      //\n      // Note that we only have to perform this extra traversal if we didn't\n      // already discover a root layout in the part of the tree that is\n      // unchanged. We also only need to compare the subtree that is not\n      // shared. In the common case, this branch is skipped completely.\n      (!didFindRootLayout &&\n        isNavigatingToNewRootLayout(oldRouterState, newRouteTree)) ||\n      // The global Not Found route (app/global-not-found.tsx) is a special\n      // case, because it acts like a root layout, but in the router tree, it\n      // is rendered in the same position as app/layout.tsx.\n      //\n      // Any navigation to the global Not Found route should trigger a\n      // full-page navigation.\n      //\n      // TODO: We should probably model this by changing the key of the root\n      // segment when this happens. Then the root layout check would work\n      // as expected, without a special case.\n      newSegment === NOT_FOUND_SEGMENT_KEY\n    ) {\n      return null\n    }\n    if (parentSegmentPath === null || parentParallelRouteKey === null) {\n      // The root should never mismatch. If it does, it suggests an internal\n      // Next.js error, or a malformed server response. Trigger a full-\n      // page navigation.\n      return null\n    }\n    return createCacheNodeOnNavigation(\n      navigatedAt,\n      newRouteTree,\n      newMetadataVaryPath,\n      freshness,\n      seedData,\n      seedHead,\n      parentSegmentPath,\n      parentParallelRouteKey,\n      parentNeedsDynamicRequest,\n      accumulation\n    )\n  }\n\n  // TODO: The segment paths are tracked so that LayoutRouter knows which\n  // segments to scroll to after a navigation. But we should just mark this\n  // information on the CacheNode directly. It used to be necessary to do this\n  // separately because CacheNodes were created lazily during render, not when\n  // rather than when creating the route tree.\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newSlots = newRouteTree.slots\n  const oldRouterStateChildren = oldRouterState[1]\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n\n  // We're currently traversing the part of the tree that was also part of\n  // the previous route. If we discover a root layout, then we don't need to\n  // trigger an MPA navigation.\n  const childDidFindRootLayout = didFindRootLayout || newRouteTree.isRootLayout\n\n  let shouldRefreshDynamicData: boolean = false\n  switch (freshness) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n    case FreshnessPolicy.Gesture:\n      // We should never drop dynamic data in shared layouts, except during\n      // a refresh.\n      shouldRefreshDynamicData = false\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      shouldRefreshDynamicData = true\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n\n  // TODO: We're not consistent about how we do this check. Some places\n  // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n  // check if there any any children, which is why I'm doing it here. We\n  // should probably encode an empty children set as `null` though. Either\n  // way, we should update all the checks to be consistent.\n  const isLeafSegment = newSlots === null\n\n  // Get the data for this segment. Since it was part of the previous route,\n  // usually we just clone the data from the old CacheNode. However, during a\n  // refresh or a revalidation, there won't be any existing CacheNode. So we\n  // may need to consult the prefetch cache, like we would for a new segment.\n  let newCacheNode: CacheNode\n  let needsDynamicRequest: boolean\n  if (\n    oldCacheNode !== undefined &&\n    !shouldRefreshDynamicData &&\n    // During a same-page navigation, we always refetch the page segments\n    !(isLeafSegment && isSamePageNavigation)\n  ) {\n    // Reuse the existing CacheNode\n    const dropPrefetchRsc = false\n    newCacheNode = reuseSharedCacheNode(dropPrefetchRsc, oldCacheNode)\n    needsDynamicRequest = false\n  } else {\n    // If this is part of a refresh, ignore the existing CacheNode and create a\n    // new one.\n    const seedRsc = seedData !== null ? seedData[0] : null\n    const result = createCacheNodeForSegment(\n      navigatedAt,\n      newRouteTree,\n      seedRsc,\n      newMetadataVaryPath,\n      seedHead,\n      freshness\n    )\n    newCacheNode = result.cacheNode\n    needsDynamicRequest = result.needsDynamicRequest\n  }\n\n  // During a refresh navigation, there's a special case that happens when\n  // entering a \"default\" slot. The default slot may not be part of the\n  // current route; it may have been reused from an older route. If so,\n  // we need to fetch its data from the old route's URL rather than current\n  // route's URL. Keep track of this as we traverse the tree.\n  const maybeRefreshState = newRouteTree.refreshState\n  const refreshState =\n    maybeRefreshState !== undefined && maybeRefreshState !== null\n      ? // This segment is not present in the current route. Track its\n        // refresh URL as we continue traversing the tree.\n        maybeRefreshState\n      : // Inherit the refresh URL from the parent.\n        parentRefreshState\n\n  // If this segment itself needs to fetch new data from the server, then by\n  // definition it is being refreshed. Track its refresh URL so we know which\n  // URL to request the data from.\n  if (needsDynamicRequest && refreshState !== null) {\n    accumulateRefreshUrl(accumulation, refreshState)\n  }\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let childNeedsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. childNeedsDynamicRequest is false\n  // at the end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  let newCacheNodeSlots: Record<string, CacheNode> | null = null\n  if (newSlots !== null) {\n    const oldCacheNodeSlots =\n      oldCacheNode !== undefined ? oldCacheNode.slots : null\n\n    newCacheNode.slots = newCacheNodeSlots = {}\n    taskChildren = new Map()\n    for (let parallelRouteKey in newSlots) {\n      let newRouteTreeChild: RouteTree = newSlots[parallelRouteKey]\n      const oldRouterStateChild: FlightRouterState | void =\n        oldRouterStateChildren[parallelRouteKey]\n      if (oldRouterStateChild === undefined) {\n        // This should never happen, but if it does, it suggests a malformed\n        // server response. Trigger a full-page navigation.\n        return null\n      }\n\n      let seedDataChild: CacheNodeSeedData | void | null =\n        seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n\n      const oldSegmentChild = oldRouterStateChild[0]\n      let newSegmentChild = createSegmentFromRouteTree(newRouteTreeChild)\n      let seedHeadChild = seedHead\n      if (\n        // Skip this branch during a history traversal. We restore the tree that\n        // was stashed in the history entry as-is.\n        freshness !== FreshnessPolicy.HistoryTraversal &&\n        newSegmentChild === DEFAULT_SEGMENT_KEY &&\n        oldSegmentChild !== DEFAULT_SEGMENT_KEY\n      ) {\n        // This is a \"default\" segment. These are never sent by the server during\n        // a soft navigation; instead, the client reuses whatever segment was\n        // already active in that slot on the previous route.\n        newRouteTreeChild = reuseActiveSegmentInDefaultSlot(\n          newRouteTree,\n          parallelRouteKey,\n          oldRootRefreshState,\n          oldRouterStateChild\n        )\n        newSegmentChild = createSegmentFromRouteTree(newRouteTreeChild)\n\n        // Since we're switching to a different route tree, these are no\n        // longer valid, because they correspond to the outer tree.\n        seedDataChild = null\n        seedHeadChild = null\n      }\n\n      const oldCacheNodeChild =\n        oldCacheNodeSlots !== null\n          ? oldCacheNodeSlots[parallelRouteKey]\n          : undefined\n\n      const taskChild = updateCacheNodeOnNavigation(\n        navigatedAt,\n        oldUrl,\n        oldCacheNodeChild,\n        oldRouterStateChild,\n        newRouteTreeChild,\n        newMetadataVaryPath,\n        freshness,\n        childDidFindRootLayout,\n        seedDataChild ?? null,\n        seedHeadChild,\n        isSamePageNavigation,\n        segmentPath,\n        parallelRouteKey,\n        parentNeedsDynamicRequest || needsDynamicRequest,\n        oldRootRefreshState,\n        refreshState,\n        accumulation\n      )\n\n      if (taskChild === null) {\n        // One of the child tasks discovered a change to the root layout.\n        // Immediately unwind from this recursive traversal. This will trigger a\n        // full-page navigation.\n        return null\n      }\n\n      // Recursively propagate up the child tasks.\n      taskChildren.set(parallelRouteKey, taskChild)\n      newCacheNodeSlots[parallelRouteKey] = taskChild.node\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        childNeedsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    }\n  }\n\n  const newFlightRouterState: FlightRouterState = [\n    createSegmentFromRouteTree(newRouteTree),\n    patchedRouterStateChildren,\n    refreshState !== null\n      ? [refreshState.canonicalUrl, refreshState.renderedSearch]\n      : null,\n    null,\n    newRouteTree.isRootLayout,\n  ]\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: newFlightRouterState,\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newFlightRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    refreshState,\n    children: taskChildren,\n  }\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  newRouteTree: RouteTree,\n  newMetadataVaryPath: PageVaryPath | null,\n  freshness: FreshnessPolicy,\n  seedData: CacheNodeSeedData | null,\n  seedHead: HeadData | null,\n  parentSegmentPath: FlightSegmentPath | null,\n  parentParallelRouteKey: string | null,\n  parentNeedsDynamicRequest: boolean,\n  accumulation: NavigationRequestAccumulation\n): NavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but simpler. We switch to this\n  // path once we reach the part of the tree that was not in the previous route.\n  // We don't need to diff against the old tree, we just need to create a new\n  // one. We also don't need to worry about any refresh-related logic.\n  //\n  // For the most part, this is a subset of updateCacheNodeOnNavigation, so any\n  // change that happens in this function likely needs to be applied to that\n  // one, too. However there are some places where the behavior intentionally\n  // diverges, which is why we keep them separate.\n\n  const newSegment = createSegmentFromRouteTree(newRouteTree)\n  const segmentPath =\n    parentParallelRouteKey !== null && parentSegmentPath !== null\n      ? parentSegmentPath.concat([parentParallelRouteKey, newSegment])\n      : // NOTE: The root segment is intentionally omitted from the segment path\n        []\n\n  const newSlots = newRouteTree.slots\n  const seedDataChildren = seedData !== null ? seedData[1] : null\n\n  const isLeafSegment = newSlots === null\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    //\n    // This only happens for new pages, not for refreshed pages.\n    //\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    if (accumulation.scrollableSegments === null) {\n      accumulation.scrollableSegments = []\n    }\n    accumulation.scrollableSegments.push(segmentPath)\n  }\n\n  const seedRsc = seedData !== null ? seedData[0] : null\n  const result = createCacheNodeForSegment(\n    navigatedAt,\n    newRouteTree,\n    seedRsc,\n    newMetadataVaryPath,\n    seedHead,\n    freshness\n  )\n  const newCacheNode = result.cacheNode\n  const needsDynamicRequest = result.needsDynamicRequest\n\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  let childNeedsDynamicRequest = false\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  let newCacheNodeSlots: Record<string, CacheNode> | null = null\n  if (newSlots !== null) {\n    newCacheNode.slots = newCacheNodeSlots = {}\n    taskChildren = new Map()\n    for (let parallelRouteKey in newSlots) {\n      const newRouteTreeChild: RouteTree = newSlots[parallelRouteKey]\n      const seedDataChild: CacheNodeSeedData | void | null =\n        seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n\n      const taskChild = createCacheNodeOnNavigation(\n        navigatedAt,\n        newRouteTreeChild,\n        newMetadataVaryPath,\n        freshness,\n        seedDataChild ?? null,\n        seedHead,\n        segmentPath,\n        parallelRouteKey,\n        parentNeedsDynamicRequest || needsDynamicRequest,\n        accumulation\n      )\n\n      taskChildren.set(parallelRouteKey, taskChild)\n      newCacheNodeSlots[parallelRouteKey] = taskChild.node\n\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        childNeedsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    }\n  }\n\n  const newFlightRouterState: FlightRouterState = [\n    newSegment,\n    patchedRouterStateChildren,\n    null,\n    null,\n    newRouteTree.isRootLayout,\n  ]\n\n  return {\n    status: needsDynamicRequest\n      ? NavigationTaskStatus.Pending\n      : NavigationTaskStatus.Fulfilled,\n    route: newFlightRouterState,\n    node: newCacheNode,\n    dynamicRequestTree: createDynamicRequestTree(\n      newFlightRouterState,\n      dynamicRequestTreeChildren,\n      needsDynamicRequest,\n      childNeedsDynamicRequest,\n      parentNeedsDynamicRequest\n    ),\n    // This route is not part of the current tree, so there's no reason to\n    // track the refresh URL.\n    refreshState: null,\n    children: taskChildren,\n  }\n}\n\nfunction createSegmentFromRouteTree(newRouteTree: RouteTree): Segment {\n  if (newRouteTree.isPage) {\n    // In a dynamic server response, the server embeds the search params into\n    // the segment key, but in a static one it's omitted. The client handles\n    // this inconsistency by adding the search params back right at the end.\n    //\n    // TODO: The only thing this is used for is to create a cache key for\n    // ChildSegmentMap. But we already track the `renderedSearch` everywhere as\n    // part of the varyPath. The plan is get rid of ChildSegmentMap and\n    // store the page data in a CacheMap using the varyPath, like we do\n    // for prefetches. Then we can remove it from the segment key.\n    //\n    // As an incremental step, we can grab the search params from the varyPath.\n    const renderedSearch = getRenderedSearchFromVaryPath(newRouteTree.varyPath)\n    if (renderedSearch === null) {\n      return PAGE_SEGMENT_KEY\n    }\n    // This is based on equivalent logic in addSearchParamsIfPageSegment, used\n    // on the server.\n    const stringifiedQuery = JSON.stringify(\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    )\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n  return newRouteTree.segment\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction createDynamicRequestTree(\n  newRouterState: FlightRouterState,\n  dynamicRequestTreeChildren: Record<string, FlightRouterState>,\n  needsDynamicRequest: boolean,\n  childNeedsDynamicRequest: boolean,\n  parentNeedsDynamicRequest: boolean\n): FlightRouterState | null {\n  // Create a FlightRouterState that instructs the server how to render the\n  // requested segment.\n  //\n  // Or, if neither this segment nor any of the children require a new data,\n  // then we return `null` to skip the request.\n  let dynamicRequestTree: FlightRouterState | null = null\n  if (needsDynamicRequest) {\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n    // The \"refetch\" marker is set on the top-most segment that requires new\n    // data. We can omit it if a parent was already marked.\n    if (!parentNeedsDynamicRequest) {\n      dynamicRequestTree[3] = 'refetch'\n    }\n  } else if (childNeedsDynamicRequest) {\n    // This segment does not request new data, but at least one of its\n    // children does.\n    dynamicRequestTree = patchRouterStateWithNewChildren(\n      newRouterState,\n      dynamicRequestTreeChildren\n    )\n  } else {\n    dynamicRequestTree = null\n  }\n  return dynamicRequestTree\n}\n\nfunction accumulateRefreshUrl(\n  accumulation: NavigationRequestAccumulation,\n  refreshState: RefreshState\n) {\n  // This is a refresh navigation, and we're inside a \"default\" slot that's\n  // not part of the current route; it was reused from an older route. In\n  // order to get fresh data for this reused route, we need to issue a\n  // separate request using the old route's URL.\n  //\n  // Track these extra URLs in the accumulated result. Later, we'll construct\n  // an appropriate request for each unique URL in the final set. The reason\n  // we don't do it immediately here is so we can deduplicate multiple\n  // instances of the same URL into a single request. See\n  // listenForDynamicRequest for more details.\n  const refreshUrl = refreshState.canonicalUrl\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  if (separateRefreshUrls === null) {\n    accumulation.separateRefreshUrls = new Set([refreshUrl])\n  } else {\n    separateRefreshUrls.add(refreshUrl)\n  }\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  parentRouteTree: RouteTree,\n  parallelRouteKey: string,\n  oldRootRefreshState: RefreshState,\n  oldRouterState: FlightRouterState\n): RouteTree {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n\n  let reusedUrl: string\n  let reusedRenderedSearch: NormalizedSearch\n  const oldRefreshState = oldRouterState[2]\n  if (oldRefreshState !== undefined && oldRefreshState !== null) {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh state.\n    reusedUrl = oldRefreshState[0]\n    reusedRenderedSearch = oldRefreshState[1] as NormalizedSearch\n  } else {\n    // Since this route didn't already have a refresh state, it must have been\n    // reachable from the root of the old route. So we use the refresh state\n    // that represents the old route.\n    reusedUrl = oldRootRefreshState.canonicalUrl\n    reusedRenderedSearch = oldRootRefreshState.renderedSearch\n  }\n\n  const acc = { metadataVaryPath: null }\n  const reusedRouteTree = convertReusedFlightRouterStateToRouteTree(\n    parentRouteTree,\n    parallelRouteKey,\n    oldRouterState,\n    reusedRenderedSearch,\n    acc\n  )\n  reusedRouteTree.refreshState = {\n    canonicalUrl: reusedUrl,\n    renderedSearch: reusedRenderedSearch,\n  }\n  return reusedRouteTree\n}\n\nfunction reuseSharedCacheNode(\n  dropPrefetchRsc: boolean,\n  existingCacheNode: CacheNode\n): CacheNode {\n  // Clone the CacheNode that was already present in the previous tree\n  return createCacheNode(\n    existingCacheNode.rsc,\n    dropPrefetchRsc ? null : existingCacheNode.prefetchRsc,\n    existingCacheNode.head,\n    dropPrefetchRsc ? null : existingCacheNode.prefetchHead\n  )\n}\n\nfunction createCacheNodeForSegment(\n  now: number,\n  tree: RouteTree,\n  seedRsc: React.ReactNode | null,\n  metadataVaryPath: PageVaryPath | null,\n  seedHead: HeadData | null,\n  freshness: FreshnessPolicy\n): { cacheNode: CacheNode; needsDynamicRequest: boolean } {\n  // Construct a new CacheNode using data from the BFCache, the client's\n  // Segment Cache, or seeded from a server response.\n  //\n  // If there's a cache miss, or if we only have a partial hit, we'll render\n  // the partial state immediately, and spawn a request to the server to fill\n  // in the missing data.\n  //\n  // If the segment is fully cached on the client already, we can omit this\n  // segment from the server request.\n  //\n  // If we already have a dynamic data response associated with this navigation,\n  // as in the case of a Server Action-initiated redirect or refresh, we may\n  // also be able to use that data without spawning a new request. (This is\n  // referred to as the \"seed\" data.)\n\n  const isPage = tree.isPage\n\n  // During certain kinds of navigations, we may be able to render from\n  // the BFCache.\n  switch (freshness) {\n    case FreshnessPolicy.Default: {\n      // When experimental.staleTimes.dynamic config is set, we read from the\n      // BFCache even during regular navigations. (This is not a recommended API\n      // with Cache Components, but it's supported for backwards compatibility.\n      // Use cacheLife instead.)\n\n      // This outer check isn't semantically necessary; even if the configured\n      // stale time is 0, the bfcache will return null, because any entry would\n      // have immediately expired. Just an optimization.\n      if (DYNAMIC_STALETIME_MS > 0) {\n        const bfcacheEntry = readFromBFCacheDuringRegularNavigation(\n          now,\n          tree.varyPath\n        )\n        if (bfcacheEntry !== null) {\n          return {\n            cacheNode: createCacheNode(\n              bfcacheEntry.rsc,\n              bfcacheEntry.prefetchRsc,\n              bfcacheEntry.head,\n              bfcacheEntry.prefetchHead\n            ),\n            needsDynamicRequest: false,\n          }\n        }\n      }\n      break\n    }\n    case FreshnessPolicy.Hydration: {\n      // This is not related to the BFCache but it is a special case.\n      //\n      // We should never spawn network requests during hydration. We must treat\n      // the initial payload as authoritative, because the initial page load is\n      // used as a last-ditch mechanism for recovering the app.\n      //\n      // This is also an important safety check because if this leaks into the\n      // server rendering path (which theoretically it never should because the\n      // server payload should be consistent), the server would hang because these\n      // promises would never resolve.\n      //\n      // TODO: There is an existing case where the global \"not found\" boundary\n      // triggers this path. But it does render correctly despite that. That's an\n      // unusual render path so it's not surprising, but we should look into\n      // modeling it in a more consistent way. See also the /_notFound special\n      // case in updateCacheNodeOnNavigation.\n      const rsc = seedRsc\n      const prefetchRsc = null\n      const head = isPage ? seedHead : null\n      const prefetchHead = null\n      writeToBFCache(now, tree.varyPath, rsc, prefetchRsc, head, prefetchHead)\n      if (isPage && metadataVaryPath !== null) {\n        writeHeadToBFCache(now, metadataVaryPath, head, prefetchHead)\n      }\n      return {\n        cacheNode: createCacheNode(rsc, prefetchRsc, head, prefetchHead),\n        needsDynamicRequest: false,\n      }\n    }\n    case FreshnessPolicy.HistoryTraversal:\n      const bfcacheEntry = readFromBFCache(tree.varyPath)\n      if (bfcacheEntry !== null) {\n        // Only show prefetched data if the dynamic data is still pending. This\n        // avoids a flash back to the prefetch state in a case where it's highly\n        // likely to have already streamed in.\n        //\n        // Tehnically, what we're actually checking is whether the dynamic\n        // network response was received. But since it's a streaming response,\n        // this does not mean that all the dynamic data has fully streamed in.\n        // It just means that _some_ of the dynamic data was received. But as a\n        // heuristic, we assume that the rest dynamic data will stream in\n        // quickly, so it's still better to skip the prefetch state.\n        const oldRsc = bfcacheEntry.rsc\n        const oldRscDidResolve =\n          !isDeferredRsc(oldRsc) || oldRsc.status !== 'pending'\n        const dropPrefetchRsc = oldRscDidResolve\n        return {\n          cacheNode: createCacheNode(\n            bfcacheEntry.rsc,\n            dropPrefetchRsc ? null : bfcacheEntry.prefetchRsc,\n            bfcacheEntry.head,\n            dropPrefetchRsc ? null : bfcacheEntry.prefetchHead\n          ),\n          needsDynamicRequest: false,\n        }\n      }\n      break\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n    case FreshnessPolicy.Gesture:\n      // Don't consult the BFCache.\n      break\n    default:\n      freshness satisfies never\n      break\n  }\n\n  let cachedRsc: React.ReactNode | null = null\n  let isCachedRscPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        cachedRsc = segmentEntry.rsc\n        isCachedRscPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        cachedRsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        // Because the request is still pending, we typically don't know yet\n        // whether the response will be partial. We shouldn't skip this segment\n        // during the dynamic navigation request. Otherwise, we might need to\n        // do yet another request to fill in the remaining data, creating\n        // a waterfall.\n        //\n        // The one exception is if this segment is being fetched with via\n        // prefetch={true} (i.e. the \"force stale\" or \"full\" strategy). If so,\n        // we can assume the response will be full. This field is set to `false`\n        // for such segments.\n        isCachedRscPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected: {\n        break\n      }\n      default: {\n        segmentEntry satisfies never\n        break\n      }\n    }\n  }\n\n  // Now combine the cached data with the seed data to determine what we can\n  // render immediately, versus what needs to stream in later.\n\n  // A partial state to show immediately while we wait for the final data to\n  // arrive. If `rsc` is already a complete value (not partial), or if we\n  // don't have any useful partial state, this will be `null`.\n  let prefetchRsc: React.ReactNode | null\n  // The final, resolved segment data. If the data is missing, this will be a\n  // promise that resolves to the eventual data. A resolved value of `null`\n  // means the data failed to load; the LayoutRouter will suspend indefinitely\n  // until the router updates again (refer to finishNavigationTask).\n  let rsc: React.ReactNode | null\n  let doesSegmentNeedDynamicRequest: boolean\n\n  if (seedRsc !== null) {\n    // We already have a dynamic server response for this segment.\n    if (isCachedRscPartial) {\n      // The seed data may still be streaming in, so it's worth showing the\n      // partial cached state in the meantime.\n      prefetchRsc = cachedRsc\n      rsc = seedRsc\n    } else {\n      // We already have a completely cached segment. Ignore the seed data,\n      // which may still be streaming in. This shouldn't happen in the normal\n      // case because the client will inform the server which segments are\n      // already fully cached, and the server will skip rendering them.\n      prefetchRsc = null\n      rsc = cachedRsc\n    }\n    doesSegmentNeedDynamicRequest = false\n  } else {\n    if (isCachedRscPartial) {\n      // The cached data contains dynamic holes, or it's missing entirely. We'll\n      // show the partial state immediately (if available), and stream in the\n      // final data.\n      //\n      // Create a pending promise that we can later write to when the\n      // data arrives from the server.\n      prefetchRsc = cachedRsc\n      rsc = createDeferredRsc()\n    } else {\n      // The data is fully cached.\n      prefetchRsc = null\n      rsc = cachedRsc\n    }\n    doesSegmentNeedDynamicRequest = isCachedRscPartial\n  }\n\n  // If this is a page segment, we need to do the same for the head. This\n  // follows analogous logic to the segment data above.\n  // TODO: We don't need to store the head on the page segment's CacheNode; we\n  // can lift it to the main state object. Then we can also delete\n  // findHeadCache.\n\n  let prefetchHead: HeadData | null = null\n  let head: React.ReactNode | null = null\n  let doesHeadNeedDynamicRequest: boolean = isPage\n\n  if (isPage) {\n    let cachedHead: HeadData | null = null\n    let isCachedHeadPartial: boolean = true\n    if (metadataVaryPath !== null) {\n      const metadataEntry = readSegmentCacheEntry(now, metadataVaryPath)\n      if (metadataEntry !== null) {\n        switch (metadataEntry.status) {\n          case EntryStatus.Fulfilled: {\n            cachedHead = metadataEntry.rsc\n            isCachedHeadPartial = metadataEntry.isPartial\n            break\n          }\n          case EntryStatus.Pending: {\n            cachedHead = waitForSegmentCacheEntry(metadataEntry).then(\n              (entry) => (entry !== null ? entry.rsc : null)\n            )\n            isCachedHeadPartial = metadataEntry.isPartial\n            break\n          }\n          case EntryStatus.Empty:\n          case EntryStatus.Rejected: {\n            break\n          }\n          default: {\n            metadataEntry satisfies never\n            break\n          }\n        }\n      }\n    }\n\n    if (process.env.__NEXT_OPTIMISTIC_ROUTING && isCachedHeadPartial) {\n      // TODO: When optimistic routing is enabled, don't block on waiting for\n      // the viewport to resolve. This is a temporary workaround until Vary\n      // Params are tracked when rendering the metadata. We'll fix it before\n      // this feature is stable. However, it's not a critical issue because 1)\n      // it will stream in eventually anyway 2) metadata is wrapped in an\n      // internal Suspense boundary, so is always non-blocking; this only\n      // affects the viewport node, which is meant to blocking, however... 3)\n      // before Segment Cache landed this wasn't always the case, anyway, so\n      // it's unlikely that many people are relying on this behavior. Still,\n      // will be fixed before stable. It's the very next step in the sequence of\n      // work on this project.\n      //\n      // This line of code works because the App Router treats `null` as\n      // \"no renderable head available\", rather than an empty head. React treats\n      // an empty string as empty.\n      cachedHead = ''\n    }\n\n    if (seedHead !== null) {\n      if (isCachedHeadPartial) {\n        prefetchHead = cachedHead\n        head = seedHead\n      } else {\n        prefetchHead = null\n        head = cachedHead\n      }\n      doesHeadNeedDynamicRequest = false\n    } else {\n      if (isCachedHeadPartial) {\n        prefetchHead = cachedHead\n        head = createDeferredRsc()\n      } else {\n        prefetchHead = null\n        head = cachedHead\n      }\n      doesHeadNeedDynamicRequest = isCachedHeadPartial\n    }\n  }\n\n  // Now that we're creating a new segment, write its data to the BFCache. A\n  // subsequent back/forward navigation will reuse this same data, until or\n  // unless it's cleared by a refresh/revalidation.\n  //\n  // Skip BFCache writes for optimistic navigations since they are transient\n  // and will be replaced by the canonical navigation.\n  if (freshness !== FreshnessPolicy.Gesture) {\n    writeToBFCache(now, tree.varyPath, rsc, prefetchRsc, head, prefetchHead)\n    if (isPage && metadataVaryPath !== null) {\n      writeHeadToBFCache(now, metadataVaryPath, head, prefetchHead)\n    }\n  }\n\n  return {\n    cacheNode: createCacheNode(rsc, prefetchRsc, head, prefetchHead),\n    // TODO: We should store this field on the CacheNode itself. I think we can\n    // probably unify NavigationTask, CacheNode, and DeferredRsc into a\n    // single type. Or at least CacheNode and DeferredRsc.\n    needsDynamicRequest:\n      doesSegmentNeedDynamicRequest || doesHeadNeedDynamicRequest,\n  }\n}\n\nfunction createCacheNode(\n  rsc: React.ReactNode | null,\n  prefetchRsc: React.ReactNode | null,\n  head: React.ReactNode | null,\n  prefetchHead: HeadData | null\n): CacheNode {\n  return {\n    rsc,\n    prefetchRsc,\n    head,\n    prefetchHead,\n    slots: null,\n  }\n}\n\n// Represents whether the previuos navigation resulted in a route tree mismatch.\n// A mismatch results in a refresh of the page. If there are two successive\n// mismatches, we will fall back to an MPA navigation, to prevent a retry loop.\nlet previousNavigationDidMismatch = false\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function spawnDynamicRequests(\n  task: NavigationTask,\n  primaryUrl: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  accumulation: NavigationRequestAccumulation,\n  // The route cache entry used for this navigation, if it came from route\n  // prediction. Passed through so it can be marked as having a dynamic rewrite\n  // if the server returns a different pathname than expected (indicating\n  // dynamic rewrite behavior that varies by param value).\n  routeCacheEntry: FulfilledRouteCacheEntry | null\n): void {\n  const dynamicRequestTree = task.dynamicRequestTree\n  if (dynamicRequestTree === null) {\n    // This navigation was fully cached. There are no dynamic requests to spawn.\n    previousNavigationDidMismatch = false\n    return\n  }\n\n  // This is intentionally not an async function to discourage the caller from\n  // awaiting the result. Any subsequent async operations spawned by this\n  // function should result in a separate navigation task, rather than\n  // block the original one.\n  //\n  // In this function we spawn (but do not await) all the network requests that\n  // block the navigation, and collect the promises. The next function,\n  // `finishNavigationTask`, can await the promises in any order without\n  // accidentally introducing a network waterfall.\n  const primaryRequestPromise = fetchMissingDynamicData(\n    task,\n    dynamicRequestTree,\n    primaryUrl,\n    nextUrl,\n    freshnessPolicy\n  )\n\n  const separateRefreshUrls = accumulation.separateRefreshUrls\n  let refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null = null\n  if (separateRefreshUrls !== null) {\n    // There are multiple URLs that we need to request the data from. This\n    // happens when a \"default\" parallel route slot is present in the tree, and\n    // its data cannot be fetched from the current route. We need to split the\n    // combined dynamic request tree into separate requests per URL.\n\n    // TODO: Create a scoped dynamic request tree that omits anything that\n    // is not relevant to the given URL. Without doing this, the server may\n    // sometimes render more data than necessary; this is not a regression\n    // compared to the pre-Segment Cache implementation, though, just an\n    // optimization we can make in the future.\n\n    // Construct a request tree for each additional refresh URL. This will\n    // prune away everything except the parts of the tree that match the\n    // given refresh URL.\n    refreshRequestPromises = []\n    const canonicalUrl = createHrefFromUrl(primaryUrl)\n    for (const refreshUrl of separateRefreshUrls) {\n      if (refreshUrl === canonicalUrl) {\n        // We already initiated a request for the this URL, above. Skip it.\n        // TODO: This only happens because the main URL is not tracked as\n        // part of the separateRefreshURLs set. There's probably a better way\n        // to structure this so this case doesn't happen.\n        continue\n      }\n      // TODO: Create a scoped dynamic request tree that omits anything that\n      // is not relevant to the given URL. Without doing this, the server may\n      // sometimes render more data than necessary; this is not a regression\n      // compared to the pre-Segment Cache implementation, though, just an\n      // optimization we can make in the future.\n      // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n      const scopedDynamicRequestTree = dynamicRequestTree\n      if (scopedDynamicRequestTree !== null) {\n        refreshRequestPromises.push(\n          fetchMissingDynamicData(\n            task,\n            scopedDynamicRequestTree,\n            new URL(refreshUrl, location.origin),\n            // TODO: Just noticed that this should actually the Next-Url at the\n            // time the refresh URL was set, not the current Next-Url. Need to\n            // start tracking this alongside the refresh URL. In the meantime,\n            // if a refresh fails due to a mismatch, it will trigger a\n            // hard refresh.\n            nextUrl,\n            freshnessPolicy\n          )\n        )\n      }\n    }\n  }\n\n  // Further async operations are moved into this separate function to\n  // discourage sequential network requests.\n  const voidPromise = finishNavigationTask(\n    task,\n    nextUrl,\n    primaryRequestPromise,\n    refreshRequestPromises,\n    routeCacheEntry\n  )\n  // `finishNavigationTask` is responsible for error handling, so we can attach\n  // noop callbacks to this promise.\n  voidPromise.then(noop, noop)\n}\n\nasync function finishNavigationTask(\n  task: NavigationTask,\n  nextUrl: string | null,\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null,\n  routeCacheEntry: FulfilledRouteCacheEntry | null\n): Promise<void> {\n  // Wait for all the requests to finish, or for the first one to fail.\n  let exitStatus = await waitForRequestsToFinish(\n    primaryRequestPromise,\n    refreshRequestPromises\n  )\n\n  // Once the all the requests have finished, check the tree for any remaining\n  // pending tasks. If anything is still pending, it means the server response\n  // does not match the client, and we must refresh to get back to a consistent\n  // state. We can skip this step if we already detected a mismatch during the\n  // first phase; it doesn't matter in that case because we're going to refresh\n  // the whole tree regardless.\n  if (exitStatus === NavigationTaskExitStatus.Done) {\n    exitStatus = abortRemainingPendingTasks(task, null, null)\n  }\n\n  switch (exitStatus) {\n    case NavigationTaskExitStatus.Done: {\n      // The task has completely finished. There's no missing data. Exit.\n      previousNavigationDidMismatch = false\n      return\n    }\n    case NavigationTaskExitStatus.SoftRetry: {\n      // Some data failed to finish loading. Trigger a soft retry.\n      // TODO: As an extra precaution against soft retry loops, consider\n      // tracking whether a navigation was itself triggered by a retry. If two\n      // happen in a row, fall back to a hard retry.\n      const isHardRetry = false\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route,\n        routeCacheEntry\n      )\n      return\n    }\n    case NavigationTaskExitStatus.HardRetry: {\n      // Some data failed to finish loading in a non-recoverable way, such as a\n      // network error. Trigger an MPA navigation.\n      //\n      // Hard navigating/refreshing is how we prevent an infinite retry loop\n      // caused by a network error — when the network fails, we fall back to the\n      // browser behavior for offline navigations. In the future, Next.js may\n      // introduce its own custom handling of offline navigations, but that\n      // doesn't exist yet.\n      const isHardRetry = true\n      const primaryRequestResult = await primaryRequestPromise\n      dispatchRetryDueToTreeMismatch(\n        isHardRetry,\n        primaryRequestResult.url,\n        nextUrl,\n        primaryRequestResult.seed,\n        task.route,\n        routeCacheEntry\n      )\n      return\n    }\n    default: {\n      return exitStatus satisfies never\n    }\n  }\n}\n\nfunction waitForRequestsToFinish(\n  primaryRequestPromise: ReturnType<typeof fetchMissingDynamicData>,\n  refreshRequestPromises: Array<\n    ReturnType<typeof fetchMissingDynamicData>\n  > | null\n) {\n  // Custom async combinator logic. This could be replaced by Promise.any but\n  // we don't assume that's available.\n  //\n  // Each promise resolves once the server responsds and the data is written\n  // into the CacheNode tree. Resolve the combined promise once all the\n  // requests finish.\n  //\n  // Or, resolve as soon as one of the requests fails, without waiting for the\n  // others to finish.\n  return new Promise<NavigationTaskExitStatus>((resolve) => {\n    const onFulfill = (result: { exitStatus: NavigationTaskExitStatus }) => {\n      if (result.exitStatus === NavigationTaskExitStatus.Done) {\n        remainingCount--\n        if (remainingCount === 0) {\n          // All the requests finished successfully.\n          resolve(NavigationTaskExitStatus.Done)\n        }\n      } else {\n        // One of the requests failed. Exit with a failing status.\n        // NOTE: It's possible for one of the requests to fail with SoftRetry\n        // and a later one to fail with HardRetry. In this case, we choose to\n        // retry immediately, rather than delay the retry until all the requests\n        // finish. If it fails again, we will hard retry on the next\n        // attempt, anyway.\n        resolve(result.exitStatus)\n      }\n    }\n    // onReject shouldn't ever be called because fetchMissingDynamicData's\n    // entire body is wrapped in a try/catch. This is just defensive.\n    const onReject = () => resolve(NavigationTaskExitStatus.HardRetry)\n\n    // Attach the listeners to the promises.\n    let remainingCount = 1\n    primaryRequestPromise.then(onFulfill, onReject)\n    if (refreshRequestPromises !== null) {\n      remainingCount += refreshRequestPromises.length\n      refreshRequestPromises.forEach((refreshRequestPromise) =>\n        refreshRequestPromise.then(onFulfill, onReject)\n      )\n    }\n  })\n}\n\nfunction dispatchRetryDueToTreeMismatch(\n  isHardRetry: boolean,\n  retryUrl: URL,\n  retryNextUrl: string | null,\n  seed: NavigationSeed | null,\n  baseTree: FlightRouterState,\n  // The route cache entry used for this navigation, if it came from route\n  // prediction. If the navigation results in a mismatch, we mark it as having\n  // a dynamic rewrite so future predictions bail out.\n  routeCacheEntry: FulfilledRouteCacheEntry | null\n) {\n  // If the navigation used a route prediction, mark it as having a dynamic\n  // rewrite since it resulted in a mismatch.\n  if (routeCacheEntry !== null) {\n    markRouteEntryAsDynamicRewrite(routeCacheEntry)\n  } else if (seed !== null) {\n    // Even without a direct reference to the route cache entry, we can still\n    // mark the route as having a dynamic rewrite by traversing the known route\n    // tree. This handles cases where the navigation didn't originate from a\n    // route prediction, but still needs to mark the pattern.\n    const metadataVaryPath = seed.metadataVaryPath\n    if (metadataVaryPath !== null) {\n      const now = Date.now()\n      discoverKnownRoute(\n        now,\n        retryUrl.pathname,\n        null,\n        seed.routeTree,\n        metadataVaryPath,\n        false, // couldBeIntercepted - doesn't matter, we're just marking hasDynamicRewrite\n        createHrefFromUrl(retryUrl),\n        false, // isPPREnabled - doesn't matter, we're just marking hasDynamicRewrite\n        true // hasDynamicRewrite\n      )\n    }\n  }\n\n  // Invalidate all route cache entries. Other entries may have been derived\n  // from the template before we knew it had a dynamic rewrite. This also\n  // triggers re-prefetching of visible links.\n  invalidateRouteCacheEntries(retryNextUrl, baseTree)\n\n  // If this is the second time in a row that a navigation resulted in a\n  // mismatch, fall back to a hard (MPA) refresh.\n  isHardRetry = isHardRetry || previousNavigationDidMismatch\n  previousNavigationDidMismatch = true\n  const retryAction: ServerPatchAction = {\n    type: ACTION_SERVER_PATCH,\n    previousTree: baseTree,\n    url: retryUrl,\n    nextUrl: retryNextUrl,\n    seed,\n    mpa: isHardRetry,\n  }\n  dispatchAppRouterAction(retryAction)\n}\n\nasync function fetchMissingDynamicData(\n  task: NavigationTask,\n  dynamicRequestTree: FlightRouterState,\n  url: URL,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy\n): Promise<{\n  exitStatus: NavigationTaskExitStatus\n  url: URL\n  seed: NavigationSeed | null\n}> {\n  try {\n    const result = await fetchServerResponse(url, {\n      flightRouterState: dynamicRequestTree,\n      nextUrl,\n      isHmrRefresh: freshnessPolicy === FreshnessPolicy.HMRRefresh,\n    })\n    if (typeof result === 'string') {\n      // fetchServerResponse will return an href to indicate that the SPA\n      // navigation failed. For example, if the server triggered a hard\n      // redirect, or the fetch request errored. Initiate an MPA navigation\n      // to the given href.\n      return {\n        exitStatus: NavigationTaskExitStatus.HardRetry,\n        url: new URL(result, location.origin),\n        seed: null,\n      }\n    }\n    const seed = convertServerPatchToFullTree(\n      task.route,\n      result.flightData,\n      result.renderedSearch\n    )\n    const didReceiveUnknownParallelRoute = writeDynamicDataIntoNavigationTask(\n      task,\n      seed.routeTree,\n      seed.data,\n      seed.head,\n      result.debugInfo\n    )\n    return {\n      exitStatus: didReceiveUnknownParallelRoute\n        ? NavigationTaskExitStatus.SoftRetry\n        : NavigationTaskExitStatus.Done,\n      url: new URL(result.canonicalUrl, location.origin),\n      seed,\n    }\n  } catch {\n    // This shouldn't happen because fetchServerResponse's entire body is\n    // wrapped in a try/catch. If it does, though, it implies the server failed\n    // to respond with any tree at all. So we must fall back to a hard retry.\n    return {\n      exitStatus: NavigationTaskExitStatus.HardRetry,\n      url: url,\n      seed: null,\n    }\n  }\n}\n\nfunction writeDynamicDataIntoNavigationTask(\n  task: NavigationTask,\n  serverRouteTree: RouteTree,\n  dynamicData: CacheNodeSeedData | null,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): boolean {\n  if (task.status === NavigationTaskStatus.Pending && dynamicData !== null) {\n    task.status = NavigationTaskStatus.Fulfilled\n    finishPendingCacheNode(task.node, dynamicData, dynamicHead, debugInfo)\n  }\n\n  const taskChildren = task.children\n  const serverChildren = serverRouteTree.slots\n  const dynamicDataChildren = dynamicData !== null ? dynamicData[1] : null\n\n  // Detect whether the server sends a parallel route slot that the client\n  // doesn't know about.\n  let didReceiveUnknownParallelRoute = false\n\n  if (taskChildren !== null) {\n    if (serverChildren !== null) {\n      for (const parallelRouteKey in serverChildren) {\n        const serverRouteTreeChild: RouteTree = serverChildren[parallelRouteKey]\n        const dynamicDataChild: CacheNodeSeedData | null | void =\n          dynamicDataChildren !== null\n            ? dynamicDataChildren[parallelRouteKey]\n            : null\n\n        const taskChild = taskChildren.get(parallelRouteKey)\n        if (taskChild === undefined) {\n          // The server sent a child segment that the client doesn't know about.\n          //\n          // When we receive an unknown parallel route, we must consider it a\n          // mismatch. This is unlike the case where the segment itself\n          // mismatches, because multiple routes can be active simultaneously.\n          // But a given layout should never have a mismatching set of\n          // child slots.\n          //\n          // Theoretically, this should only happen in development during an HMR\n          // refresh, because the set of parallel routes for a layout does not\n          // change over the lifetime of a build/deployment. In production, we\n          // should have already mismatched on either the build id or the segment\n          // path. But as an extra precaution, we validate in prod, too.\n          didReceiveUnknownParallelRoute = true\n        } else {\n          const taskSegment = taskChild.route[0]\n          const serverSegment = createSegmentFromRouteTree(serverRouteTreeChild)\n          if (\n            matchSegment(serverSegment, taskSegment) &&\n            dynamicDataChild !== null &&\n            dynamicDataChild !== undefined\n          ) {\n            // Found a match for this task. Keep traversing down the task tree.\n            const childDidReceiveUnknownParallelRoute =\n              writeDynamicDataIntoNavigationTask(\n                taskChild,\n                serverRouteTreeChild,\n                dynamicDataChild,\n                dynamicHead,\n                debugInfo\n              )\n            if (childDidReceiveUnknownParallelRoute) {\n              didReceiveUnknownParallelRoute = true\n            }\n          }\n        }\n      }\n    } else {\n      if (serverChildren !== null) {\n        // The server sent a child segment that the client doesn't know about.\n        didReceiveUnknownParallelRoute = true\n      }\n    }\n  }\n\n  return didReceiveUnknownParallelRoute\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n\n  if (dynamicSegmentData === null) {\n    // This is an empty CacheNode; this particular server request did not\n    // render this segment. There may be a separate pending request that will,\n    // though, so we won't abort the task until all pending requests finish.\n    return\n  }\n\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nfunction abortRemainingPendingTasks(\n  task: NavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): NavigationTaskExitStatus {\n  let exitStatus\n  if (task.status === NavigationTaskStatus.Pending) {\n    // The data for this segment is still missing.\n    task.status = NavigationTaskStatus.Rejected\n    abortPendingCacheNode(task.node, error, debugInfo)\n\n    // If the server failed to fulfill the data for this segment, it implies\n    // that the route tree received from the server mismatched the tree that\n    // was previously prefetched.\n    //\n    // In an app with fully static routes and no proxy-driven redirects or\n    // rewrites, this should never happen, because the route for a URL would\n    // always be the same across multiple requests. So, this implies that some\n    // runtime routing condition changed, likely in a proxy, without being\n    // pushed to the client.\n    //\n    // When this happens, we treat this the same as a refresh(). The entire\n    // tree will be re-rendered from the root.\n    if (task.refreshState === null) {\n      // Trigger a \"soft\" refresh. Essentially the same as calling `refresh()`\n      // in a Server Action.\n      exitStatus = NavigationTaskExitStatus.SoftRetry\n    } else {\n      // The mismatch was discovered inside an inactive parallel route. This\n      // implies the inactive parallel route is no longer reachable at the URL\n      // that originally rendered it. Fall back to an MPA refresh.\n      // TODO: An alternative could be to trigger a soft refresh but to _not_\n      // re-use the inactive parallel routes this time. Similar to what would\n      // happen if were to do a hard refrehs, but without the HTML page.\n      exitStatus = NavigationTaskExitStatus.HardRetry\n    }\n  } else {\n    // This segment finished. (An error here is treated as Done because they are\n    // surfaced to the application during render.)\n    exitStatus = NavigationTaskExitStatus.Done\n  }\n\n  const taskChildren = task.children\n  if (taskChildren !== null) {\n    for (const [, taskChild] of taskChildren) {\n      const childExitStatus = abortRemainingPendingTasks(\n        taskChild,\n        error,\n        debugInfo\n      )\n      // Propagate the exit status up the tree. The statuses are ordered by\n      // their precedence.\n      if (childExitStatus > exitStatus) {\n        exitStatus = childExitStatus\n      }\n    }\n  }\n\n  return exitStatus\n}\n\nfunction abortPendingCacheNode(\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nexport function isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport type InterceptionMarker = (typeof INTERCEPTION_ROUTE_MARKERS)[number]\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\ntype InterceptionRouteInformation = {\n  /**\n   * The intercepting route. This is the route that is being intercepted or the\n   * route that the user was coming from. This is matched by the Next-Url\n   * header.\n   */\n  interceptingRoute: string\n\n  /**\n   * The intercepted route. This is the route that is being intercepted or the\n   * route that the user is going to. This is matched by the request pathname.\n   */\n  interceptedRoute: string\n}\n\nexport function extractInterceptionRouteInformation(\n  path: string\n): InterceptionRouteInformation {\n  let interceptingRoute: string | undefined\n  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined\n  let interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n","import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n","// Adapted from React's sanitizeURL function found here: https://github.com/facebook/react/blob/b565373afd0cc1988497e1107106e851e8cfb261/packages/react-dom-bindings/src/shared/sanitizeURL.js\n\n// A javascript: URL can contain leading C0 control or \\u0020 SPACE,\n// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n\nconst isJavaScriptProtocol =\n  // eslint-disable-next-line no-control-regex\n  /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i\n\nexport function isJavaScriptURLString(url: string): boolean {\n  return isJavaScriptProtocol.test('' + (url as unknown as string))\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type { HeadData } from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  spawnDynamicRequests,\n  FreshnessPolicy,\n  type NavigationRequestAccumulation,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  deprecated_requestOptimisticRouteCacheEntry,\n  convertRootFlightRouterStateToRouteTree,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { discoverKnownRoute } from './optimistic-routes'\nimport { createCacheKey, type NormalizedSearch } from './cache-key'\nimport type { PageVaryPath } from './vary-path'\nimport type { AppRouterState } from '../router-reducer/router-reducer-types'\nimport { computeChangedPath } from '../router-reducer/compute-changed-path'\nimport { isJavaScriptURLString } from '../../lib/javascript-url'\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  state: AppRouterState,\n  url: URL,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace'\n): AppRouterState | Promise<AppRouterState> {\n  const now = Date.now()\n  const href = url.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      state,\n      url,\n      currentUrl,\n      currentRenderedSearch,\n      nextUrl,\n      currentCacheNode,\n      currentFlightRouterState,\n      freshnessPolicy,\n      shouldScroll,\n      navigateType,\n      route\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree using the deprecated search-params\n  // based matching. This is only used when the new optimisticRouting flag is\n  // disabled.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (!process.env.__NEXT_OPTIMISTIC_ROUTING) {\n    if (route === null || route.status !== EntryStatus.Rejected) {\n      const optimisticRoute = deprecated_requestOptimisticRouteCacheEntry(\n        now,\n        url,\n        nextUrl\n      )\n      if (optimisticRoute !== null) {\n        // We have an optimistic route tree. Proceed with the normal flow.\n        return navigateUsingPrefetchedRouteTree(\n          now,\n          state,\n          url,\n          currentUrl,\n          currentRenderedSearch,\n          nextUrl,\n          currentCacheNode,\n          currentFlightRouterState,\n          freshnessPolicy,\n          shouldScroll,\n          navigateType,\n          optimisticRoute\n        )\n      }\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache. We must lazily\n  // fetch it from the server before we can perform the navigation.\n  // TODO: If this is an gesture navigation, instead of performing a\n  // dynamic request, we should do a runtime prefetch.\n  return navigateToUnknownRoute(\n    now,\n    state,\n    url,\n    currentUrl,\n    currentRenderedSearch,\n    nextUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    shouldScroll,\n    navigateType\n  ).catch(() => {\n    // If the navigation fails, return the current state\n    return state\n  })\n}\n\nexport function navigateToKnownRoute(\n  now: number,\n  state: AppRouterState,\n  url: URL,\n  canonicalUrl: string,\n  navigationSeed: NavigationSeed,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  nextUrl: string | null,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace',\n  debugInfo: Array<unknown> | null,\n  // The route cache entry used for this navigation, if it came from route\n  // prediction. Passed through so it can be marked as having a dynamic rewrite\n  // if the server returns a different pathname (indicating dynamic rewrite\n  // behavior).\n  //\n  // When null, the navigation did not use route prediction - either because\n  // the route was already fully cached, or it's a navigation that doesn't\n  // involve prediction (refresh, history traversal, server action, etc.).\n  // In these cases, if a mismatch occurs, we still mark the route as having a\n  // dynamic rewrite by traversing the known route tree (see\n  // dispatchRetryDueToTreeMismatch).\n  routeCacheEntry: FulfilledRouteCacheEntry | null\n): AppRouterState {\n  // A version of navigate() that accepts the target route tree as an argument\n  // rather than reading it from the prefetch cache.\n  const accumulation: NavigationRequestAccumulation = {\n    scrollableSegments: null,\n    separateRefreshUrls: null,\n  }\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation = url.href === currentUrl.href\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentRenderedSearch,\n    currentCacheNode,\n    currentFlightRouterState,\n    navigationSeed.routeTree,\n    navigationSeed.metadataVaryPath,\n    freshnessPolicy,\n    navigationSeed.data,\n    navigationSeed.head,\n    isSamePageNavigation,\n    accumulation\n  )\n  if (task !== null) {\n    if (freshnessPolicy !== FreshnessPolicy.Gesture) {\n      spawnDynamicRequests(\n        task,\n        url,\n        nextUrl,\n        freshnessPolicy,\n        accumulation,\n        routeCacheEntry\n      )\n    }\n    return completeSoftNavigation(\n      state,\n      url,\n      nextUrl,\n      task.route,\n      task.node,\n      navigationSeed.renderedSearch,\n      canonicalUrl,\n      navigateType,\n      shouldScroll,\n      accumulation.scrollableSegments,\n      debugInfo\n    )\n  }\n  // Could not perform a SPA navigation. Revert to a full-page (MPA) navigation.\n  return completeHardNavigation(state, url, navigateType)\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  state: AppRouterState,\n  url: URL,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace',\n  route: FulfilledRouteCacheEntry\n): AppRouterState {\n  const routeTree = route.tree\n  const canonicalUrl = route.canonicalUrl + url.hash\n  const renderedSearch = route.renderedSearch\n  const prefetchSeed: NavigationSeed = {\n    renderedSearch,\n    routeTree,\n    metadataVaryPath: route.metadata.varyPath as any,\n    data: null,\n    head: null,\n  }\n  return navigateToKnownRoute(\n    now,\n    state,\n    url,\n    canonicalUrl,\n    prefetchSeed,\n    currentUrl,\n    currentRenderedSearch,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll,\n    navigateType,\n    null,\n    route\n  )\n}\n\n// Used to request all the dynamic data for a route, rather than just a subset,\n// e.g. during a refresh or a revalidation. Typically this gets constructed\n// during the normal flow when diffing the route tree, but for an unprefetched\n// navigation, where we don't know the structure of the target route, we use\n// this instead.\nconst DynamicRequestTreeForEntireRoute: FlightRouterState = [\n  '',\n  {},\n  null,\n  'refetch',\n]\n\nasync function navigateToUnknownRoute(\n  now: number,\n  state: AppRouterState,\n  url: URL,\n  currentUrl: URL,\n  currentRenderedSearch: string,\n  nextUrl: string | null,\n  currentCacheNode: CacheNode | null,\n  currentFlightRouterState: FlightRouterState,\n  freshnessPolicy: FreshnessPolicy,\n  shouldScroll: boolean,\n  navigateType: 'push' | 'replace'\n): Promise<AppRouterState> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  let dynamicRequestTree: FlightRouterState\n  switch (freshnessPolicy) {\n    case FreshnessPolicy.Default:\n    case FreshnessPolicy.HistoryTraversal:\n    case FreshnessPolicy.Gesture:\n      dynamicRequestTree = currentFlightRouterState\n      break\n    case FreshnessPolicy.Hydration: // <- shouldn't happen during client nav\n    case FreshnessPolicy.RefreshAll:\n    case FreshnessPolicy.HMRRefresh:\n      dynamicRequestTree = DynamicRequestTreeForEntireRoute\n      break\n    default:\n      freshnessPolicy satisfies never\n      dynamicRequestTree = currentFlightRouterState\n      break\n  }\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: dynamicRequestTree,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const redirectUrl = new URL(result, location.origin)\n    return completeHardNavigation(state, redirectUrl, navigateType)\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    couldBeIntercepted,\n    prerendered,\n    debugInfo,\n  } = result\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const navigationSeed = convertServerPatchToFullTree(\n    currentFlightRouterState,\n    flightData,\n    renderedSearch\n  )\n\n  // Learn the route pattern so we can predict it for future navigations.\n  // hasDynamicRewrite is false because this is a fresh navigation to an\n  // unknown route - any rewrite detection happens during the traversal inside\n  // discoverKnownRoute. The hasDynamicRewrite param is only set to true when\n  // retrying after a tree mismatch (see dispatchRetryDueToTreeMismatch).\n  const metadataVaryPath = navigationSeed.metadataVaryPath\n  if (metadataVaryPath !== null) {\n    discoverKnownRoute(\n      now,\n      url.pathname,\n      null, // No pending entry\n      navigationSeed.routeTree,\n      metadataVaryPath,\n      couldBeIntercepted,\n      createHrefFromUrl(canonicalUrl),\n      prerendered,\n      false // hasDynamicRewrite - not a retry, rewrite detection happens during traversal\n    )\n  }\n\n  return navigateToKnownRoute(\n    now,\n    state,\n    url,\n    createHrefFromUrl(canonicalUrl),\n    navigationSeed,\n    currentUrl,\n    currentRenderedSearch,\n    currentCacheNode,\n    currentFlightRouterState,\n    freshnessPolicy,\n    nextUrl,\n    shouldScroll,\n    navigateType,\n    debugInfo,\n    // Unknown route navigations don't use route prediction - the route tree\n    // came directly from the server. If a mismatch occurs during dynamic data\n    // fetch, the retry handler will traverse the known route tree to mark the\n    // entry as having a dynamic rewrite.\n    null\n  )\n}\n\nexport function completeHardNavigation(\n  state: AppRouterState,\n  url: URL,\n  navigateType: 'push' | 'replace'\n): AppRouterState {\n  if (isJavaScriptURLString(url.href)) {\n    console.error(\n      'Next.js has blocked a javascript: URL as a security precaution.'\n    )\n    return state\n  }\n  const newState: AppRouterState = {\n    canonicalUrl:\n      url.origin === location.origin ? createHrefFromUrl(url) : url.href,\n    pushRef: {\n      pendingPush: navigateType === 'push',\n      mpaNavigation: true,\n      preserveCustomHistoryState: false,\n    },\n    // TODO: None of the rest of these values are consistent with the incoming\n    // navigation. We rely on the fact that AppRouter will suspend and trigger\n    // a hard navigation before it accesses any of these values. But instead\n    // we should trigger the hard navigation and blocking any subsequent\n    // router updates without updating React.\n    renderedSearch: state.renderedSearch,\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: state.cache,\n    tree: state.tree,\n    nextUrl: state.nextUrl,\n    previousNextUrl: state.previousNextUrl,\n    debugInfo: null,\n  }\n  return newState\n}\n\nexport function completeSoftNavigation(\n  oldState: AppRouterState,\n  url: URL,\n  referringNextUrl: string | null,\n  tree: FlightRouterState,\n  cache: CacheNode,\n  renderedSearch: string,\n  canonicalUrl: string,\n  navigateType: 'push' | 'replace',\n  shouldScroll: boolean,\n  scrollableSegments: Array<FlightSegmentPath> | null,\n  collectedDebugInfo: Array<unknown> | null\n) {\n  // The \"Next-Url\" is a special representation of the URL that Next.js\n  // uses to implement interception routes.\n  // TODO: Get rid of this extra traversal by computing this during the\n  // same traversal that computes the tree itself. We should also figure out\n  // what is the minimum information needed for the server to correctly\n  // intercept the route.\n  const changedPath = computeChangedPath(oldState.tree, tree)\n  const nextUrlForNewRoute = changedPath ? changedPath : oldState.nextUrl\n\n  // This value is stored on the state as `previousNextUrl`; the naming is\n  // confusing. What it represents is the \"Next-Url\" header that was used to\n  // fetch the incoming route. It's essentially the refererer URL, but in a\n  // Next.js specific format. During refreshes, this is sent back to the server\n  // instead of the current route's \"Next-Url\" so that the same interception\n  // logic is applied as during the original navigation.\n  const previousNextUrl = referringNextUrl\n\n  // Check if the only thing that changed was the hash fragment.\n  const oldUrl = new URL(oldState.canonicalUrl, url)\n  const onlyHashChange =\n    // We don't need to compare the origins, because client-driven\n    // navigations are always same-origin.\n    url.pathname === oldUrl.pathname &&\n    url.search === oldUrl.search &&\n    url.hash !== oldUrl.hash\n\n  // During a hash-only change, setting scrollableSegments to an empty\n  // array triggers a scroll for all new and updated segments. See\n  // `ScrollAndFocusHandler` for more details.\n  //\n  // TODO: Given the previous comment, I don't know why shouldScroll =\n  // false sets this to an empty array. Seems like an accident. I'm just\n  // preserving the logic that was already here. Clean this up when we\n  // move the per-segment scroll state to the CacheNode.\n  const segmentPathsToScrollTo =\n    onlyHashChange || !shouldScroll\n      ? []\n      : scrollableSegments !== null\n        ? scrollableSegments\n        : oldState.focusAndScrollRef.segmentPaths\n\n  const newState: AppRouterState = {\n    canonicalUrl,\n    renderedSearch,\n    pushRef: {\n      pendingPush: navigateType === 'push',\n      mpaNavigation: false,\n      preserveCustomHistoryState: false,\n    },\n    focusAndScrollRef: {\n      // TODO: We should track all the per-segment scroll state on the CacheNode\n      // instead of using the paths.\n      apply: shouldScroll\n        ? segmentPathsToScrollTo !== null\n          ? true\n          : oldState.focusAndScrollRef.apply\n        : oldState.focusAndScrollRef.apply,\n      onlyHashChange,\n      hashFragment:\n        // Remove leading # and decode hash to make non-latin hashes work.\n        //\n        // Empty hash should trigger default behavior of scrolling layout into\n        // view. #top is handled in layout-router.\n        //\n        // Refer to `ScrollAndFocusHandler` for details on how this is used.\n        shouldScroll && url.hash !== ''\n          ? decodeURIComponent(url.hash.slice(1))\n          : oldState.focusAndScrollRef.hashFragment,\n      segmentPaths: segmentPathsToScrollTo,\n    },\n    cache,\n    tree,\n    nextUrl: nextUrlForNewRoute,\n    previousNextUrl,\n    debugInfo: collectedDebugInfo,\n  }\n  return newState\n}\n\nexport function completeTraverseNavigation(\n  state: AppRouterState,\n  url: URL,\n  renderedSearch: string,\n  cache: CacheNode,\n  tree: FlightRouterState,\n  nextUrl: string | null\n) {\n  return {\n    // Set canonical url\n    canonicalUrl: createHrefFromUrl(url),\n    renderedSearch,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache,\n    // Restore provided tree\n    tree,\n    nextUrl,\n    // TODO: We need to restore previousNextUrl, too, which represents the\n    // Next-Url that was used to fetch the data. Anywhere we fetch using the\n    // canonical URL, there should be a corresponding Next-Url.\n    previousNextUrl: null,\n    debugInfo: null,\n  }\n}\n\n// TODO: The rest of this file is related to converting the server response into\n// the data structures used by the client. Probably should move to a\n// separate module.\n\nexport type NavigationSeed = {\n  renderedSearch: string\n  routeTree: RouteTree\n  metadataVaryPath: PageVaryPath | null\n  data: CacheNodeSeedData | null\n  head: HeadData | null\n}\n\nexport function convertServerPatchToFullTree(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData> | null,\n  renderedSearch: string\n): NavigationSeed {\n  // During a client navigation or prefetch, the server sends back only a patch\n  // for the parts of the tree that have changed.\n  //\n  // This applies the patch to the base tree to create a full representation of\n  // the resulting tree.\n  //\n  // The return type includes a full FlightRouterState tree and a full\n  // CacheNodeSeedData tree. (Conceptually these are the same tree, and should\n  // eventually be unified, but there's still lots of existing code that\n  // operates on FlightRouterState trees alone without the CacheNodeSeedData.)\n  //\n  // TODO: This similar to what apply-router-state-patch-to-tree does. It\n  // will eventually fully replace it. We should get rid of all the remaining\n  // places where we iterate over the server patch format. This should also\n  // eventually replace normalizeFlightData.\n\n  let baseTree: FlightRouterState = currentTree\n  let baseData: CacheNodeSeedData | null = null\n  let head: HeadData | null = null\n  if (flightData !== null) {\n    for (const {\n      segmentPath,\n      tree: treePatch,\n      seedData: dataPatch,\n      head: headPatch,\n    } of flightData) {\n      const result = convertServerPatchToFullTreeImpl(\n        baseTree,\n        baseData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        renderedSearch,\n        0\n      )\n      baseTree = result.tree\n      baseData = result.data\n      // This is the same for all patches per response, so just pick an\n      // arbitrary one\n      head = headPatch\n    }\n  }\n\n  const finalFlightRouterState = baseTree\n\n  // Convert the final FlightRouterState into a RouteTree type.\n  //\n  // TODO: Eventually, FlightRouterState will evolve to being a transport format\n  // only. The RouteTree type will become the main type used for dealing with\n  // routes on the client, and we'll store it in the state directly.\n  const acc = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    finalFlightRouterState,\n    renderedSearch as NormalizedSearch,\n    acc\n  )\n\n  return {\n    routeTree,\n    metadataVaryPath: acc.metadataVaryPath,\n    data: baseData,\n    renderedSearch,\n    head,\n  }\n}\n\nfunction convertServerPatchToFullTreeImpl(\n  baseRouterState: FlightRouterState,\n  baseData: CacheNodeSeedData | null,\n  treePatch: FlightRouterState,\n  dataPatch: CacheNodeSeedData | null,\n  segmentPath: FlightSegmentPath,\n  renderedSearch: string,\n  index: number\n): { tree: FlightRouterState; data: CacheNodeSeedData | null } {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return {\n      tree: treePatch,\n      data: dataPatch,\n    }\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: We receive the FlightRouterState patch in the same request as the\n  // seed data patch. Therefore we don't need to worry about diffing the segment\n  // values; we can assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseTreeChildren = baseRouterState[1]\n  const baseSeedDataChildren = baseData !== null ? baseData[1] : null\n  const newTreeChildren: Record<string, FlightRouterState> = {}\n  const newSeedDataChildren: Record<string, CacheNodeSeedData | null> = {}\n  for (const parallelRouteKey in baseTreeChildren) {\n    const childBaseRouterState = baseTreeChildren[parallelRouteKey]\n    const childBaseSeedData =\n      baseSeedDataChildren !== null\n        ? (baseSeedDataChildren[parallelRouteKey] ?? null)\n        : null\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const result = convertServerPatchToFullTreeImpl(\n        childBaseRouterState,\n        childBaseSeedData,\n        treePatch,\n        dataPatch,\n        segmentPath,\n        renderedSearch,\n        // Advance the index by two and keep cloning until we reach\n        // the end of the segment path.\n        index + 2\n      )\n\n      newTreeChildren[parallelRouteKey] = result.tree\n      newSeedDataChildren[parallelRouteKey] = result.data\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newTreeChildren[parallelRouteKey] = childBaseRouterState\n      newSeedDataChildren[parallelRouteKey] = childBaseSeedData\n    }\n  }\n\n  let clonedTree: FlightRouterState\n  let clonedSeedData: CacheNodeSeedData\n  // Clone all the fields except the children.\n\n  // Clone the FlightRouterState tree. Based on equivalent logic in\n  // apply-router-state-patch-to-tree, but should confirm whether we need to\n  // copy all of these fields. Not sure the server ever sends, e.g. the\n  // refetch marker.\n  clonedTree = [baseRouterState[0], newTreeChildren]\n  if (2 in baseRouterState) {\n    const compressedRefreshState = baseRouterState[2]\n    if (\n      compressedRefreshState !== undefined &&\n      compressedRefreshState !== null\n    ) {\n      // Since this part of the tree was patched with new data, any parent\n      // refresh states should be updated to reflect the new rendered search\n      // value. (The refresh state acts like a \"context provider\".) All pages\n      // within the same server response share the same renderedSearch value,\n      // but the same RouteTree could be composed from multiple different\n      // routes, and multiple responses.\n      clonedTree[2] = [compressedRefreshState[0], renderedSearch]\n    }\n  }\n  if (3 in baseRouterState) {\n    clonedTree[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clonedTree[4] = baseRouterState[4]\n  }\n\n  // Clone the CacheNodeSeedData tree.\n  const isEmptySeedDataPartial = true\n  clonedSeedData = [\n    null,\n    newSeedDataChildren,\n    null,\n    isEmptySeedDataPartial,\n    false,\n    null,\n  ]\n\n  return {\n    tree: clonedTree,\n    data: clonedSeedData,\n  }\n}\n","import type {\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\n\nimport {\n  completeHardNavigation,\n  navigate as navigateUsingSegmentCache,\n} from '../../segment-cache/navigation'\nimport { getStaleTimeMs } from '../../segment-cache/cache'\nimport { FreshnessPolicy } from '../ppr-navigations'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS = getStaleTimeMs(\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME)\n)\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n\n  if (isExternalUrl) {\n    return completeHardNavigation(state, url, navigateType)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return completeHardNavigation(state, url, navigateType)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const currentRenderedSearch = state.renderedSearch\n  return navigateUsingSegmentCache(\n    state,\n    url,\n    currentUrl,\n    currentRenderedSearch,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    FreshnessPolicy.Default,\n    shouldScroll,\n    navigateType\n  )\n}\n","export function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n  // Shim of Stage 4 Promise.withResolvers proposal\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return { resolve: resolve!, reject: reject!, promise }\n}\n","import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport {\n  readVaryParams,\n  type VaryParams,\n} from '../../../shared/lib/segment-cache/vary-params-decoding'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n} from './scheduler'\nimport {\n  type RouteVaryPath,\n  type SegmentVaryPath,\n  type PartialSegmentVaryPath,\n  getRouteVaryPath,\n  getFulfilledRouteVaryPath,\n  getFulfilledSegmentVaryPath,\n  getSegmentVaryPathForRequest,\n  appendLayoutVaryPath,\n  finalizeLayoutVaryPath,\n  finalizePageVaryPath,\n  clonePageVaryPathWithNewSearchParams,\n  type PageVaryPath,\n  type LayoutVaryPath,\n  finalizeMetadataVaryPath,\n  getPartialPageVaryPath,\n  getPartialLayoutVaryPath,\n  getRenderedSearchFromVaryPath,\n} from './vary-path'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type {\n  NormalizedPathname,\n  NormalizedSearch,\n  RouteCacheKey,\n} from './cache-key'\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n} from '../../route-params'\nimport {\n  createCacheMap,\n  getFromCacheMap,\n  setInCacheMap,\n  setSizeInCacheMap,\n  deleteFromCacheMap,\n  isValueExpired,\n  type CacheMap,\n  type UnknownMapEntry,\n} from './cache-map'\nimport {\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentRequestKeyPart,\n  HEAD_REQUEST_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport {\n  DYNAMIC_STALETIME_MS,\n  STATIC_STALETIME_MS,\n} from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { FetchStrategy } from './types'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\nimport { readFromBFCacheDuringRegularNavigation } from './bfcache'\nimport { discoverKnownRoute, matchKnownRoute } from './optimistic-routes'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nexport function getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\ntype RouteTreeShared = {\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  refreshState: RefreshState | null\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\nexport type RefreshState = {\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n}\n\ntype LayoutRouteTree = RouteTreeShared & {\n  isPage: false\n  varyPath: LayoutVaryPath\n}\n\ntype PageRouteTree = RouteTreeShared & {\n  isPage: true\n  varyPath: PageVaryPath\n}\n\nexport type RouteTree = LayoutRouteTree | PageRouteTree\n\ntype RouteCacheEntryShared = {\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\nexport type PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  metadata: null\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  metadata: RouteTree\n  isPPREnabled: boolean\n  // When true, this entry should not be used as a template for route\n  // prediction. Set when we discover that the URL was rewritten by middleware\n  // to a different route structure (e.g., /foo was rewritten to /bar). Since\n  // rewrite behavior can vary by param value, we can't safely predict the\n  // route structure for other URLs matching this pattern.\n  hasDynamicRewrite: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  fetchStrategy: FetchStrategy\n\n  // Map-related fields.\n  ref: UnknownMapEntry | null\n  size: number\n  staleAt: number\n  version: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  isPartial: boolean\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\nconst MetadataOnlyRequestTree: FlightRouterState = [\n  '',\n  {},\n  null,\n  'metadata-only',\n]\n\nlet routeCacheMap: CacheMap<RouteCacheEntry> = createCacheMap()\nlet segmentCacheMap: CacheMap<SegmentCacheEntry> = createCacheMap()\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counters used to track cache invalidations. Route and segment\n// caches have separate versions so they can be invalidated independently.\n// Invalidation does not eagerly evict anything from the cache; entries are\n// lazily evicted when read.\nlet currentRouteCacheVersion = 0\nlet currentSegmentCacheVersion = 0\n\nexport function getCurrentRouteCacheVersion(): number {\n  return currentRouteCacheVersion\n}\n\nexport function getCurrentSegmentCacheVersion(): number {\n  return currentSegmentCacheVersion\n}\n\n/**\n * Invalidates all prefetch cache entries (both route and segment caches).\n *\n * After invalidation, triggers re-prefetching of visible links and notifies\n * invalidation listeners.\n */\nexport function invalidateEntirePrefetchCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  currentRouteCacheVersion++\n  currentSegmentCacheVersion++\n\n  pingVisibleLinks(nextUrl, tree)\n  pingInvalidationListeners(nextUrl, tree)\n}\n\n/**\n * Invalidates all route cache entries. Route entries contain the tree structure\n * (which segments exist at a given URL) but not the segment data itself.\n *\n * After invalidation, triggers re-prefetching of visible links and notifies\n * invalidation listeners.\n */\nexport function invalidateRouteCacheEntries(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  currentRouteCacheVersion++\n\n  pingVisibleLinks(nextUrl, tree)\n  pingInvalidationListeners(nextUrl, tree)\n}\n\n/**\n * Invalidates all segment cache entries. Segment entries contain the actual\n * RSC data for each segment.\n *\n * After invalidation, triggers re-prefetching of visible links and notifies\n * invalidation listeners.\n */\nexport function invalidateSegmentCacheEntries(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  currentSegmentCacheVersion++\n\n  pingVisibleLinks(nextUrl, tree)\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it — i.e. the one\n  // optionally passed to router.prefetch(onInvalidate) — then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  const existingEntry = getFromCacheMap(\n    now,\n    getCurrentRouteCacheVersion(),\n    routeCacheMap,\n    varyPath,\n    isRevalidation\n  )\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n\n  // No cache hit. Attempt to construct from template using the new\n  // optimistic routing mechanism (pattern-based matching).\n  if (process.env.__NEXT_OPTIMISTIC_ROUTING) {\n    return matchKnownRoute(key.pathname, key.search)\n  }\n\n  return null\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = false\n  return getFromCacheMap(\n    now,\n    getCurrentSegmentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  varyPath: SegmentVaryPath\n): SegmentCacheEntry | null {\n  const isRevalidation = true\n  return getFromCacheMap(\n    now,\n    getCurrentSegmentCacheVersion(),\n    segmentCacheMap,\n    varyPath,\n    isRevalidation\n  )\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\nfunction createDetachedRouteCacheEntry(): PendingRouteCacheEntry {\n  return {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    metadata: null,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    version: getCurrentRouteCacheVersion(),\n  }\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry = createDetachedRouteCacheEntry()\n  const varyPath: RouteVaryPath = getRouteVaryPath(\n    key.pathname,\n    key.search,\n    key.nextUrl\n  )\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, pendingEntry, isRevalidation)\n  return pendingEntry\n}\n\n// TODO: This function predates the new optimisticRouting feature and will be\n// removed once optimisticRouting is stable. The new mechanism (matchKnownRoute)\n// handles search param variations more robustly as part of the general route\n// prediction system. This fallback remains for when optimisticRouting is\n// disabled (staticChildren is null).\nexport function deprecated_requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  const optimisticRouteTree = deprecated_createOptimisticRouteTree(\n    routeWithNoSearchParams.tree,\n    optimisticRenderedSearch\n  )\n  const optimisticMetadataTree = deprecated_createOptimisticRouteTree(\n    routeWithNoSearchParams.metadata,\n    optimisticRenderedSearch\n  )\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: optimisticRouteTree,\n    metadata: optimisticMetadataTree,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n    hasDynamicRewrite: routeWithNoSearchParams.hasDynamicRewrite,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt: routeWithNoSearchParams.staleAt,\n    version: routeWithNoSearchParams.version,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\nfunction deprecated_createOptimisticRouteTree(\n  tree: RouteTree,\n  newRenderedSearch: NormalizedSearch\n): RouteTree {\n  // Create a new route tree that identical to the original one except for\n  // the rendered search string, which is contained in the vary path.\n\n  let clonedSlots: Record<string, RouteTree> | null = null\n  const originalSlots = tree.slots\n  if (originalSlots !== null) {\n    clonedSlots = {}\n    for (const parallelRouteKey in originalSlots) {\n      const childTree = originalSlots[parallelRouteKey]\n      clonedSlots[parallelRouteKey] = deprecated_createOptimisticRouteTree(\n        childTree,\n        newRenderedSearch\n      )\n    }\n  }\n\n  // We only need to clone the vary path if the route is a page.\n  if (tree.isPage) {\n    return {\n      requestKey: tree.requestKey,\n      segment: tree.segment,\n      refreshState: tree.refreshState,\n      varyPath: clonePageVaryPathWithNewSearchParams(\n        tree.varyPath,\n        newRenderedSearch\n      ),\n      isPage: true,\n      slots: clonedSlots,\n      isRootLayout: tree.isRootLayout,\n      hasLoadingBoundary: tree.hasLoadingBoundary,\n      hasRuntimePrefetch: tree.hasRuntimePrefetch,\n    }\n  }\n\n  return {\n    requestKey: tree.requestKey,\n    segment: tree.segment,\n    refreshState: tree.refreshState,\n    varyPath: tree.varyPath,\n    isPage: false,\n    slots: clonedSlots,\n    isRootLayout: tree.isRootLayout,\n    hasLoadingBoundary: tree.hasLoadingBoundary,\n    hasRuntimePrefetch: tree.hasRuntimePrefetch,\n  }\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache. The stale time is set to a\n  // default value; the actual stale time will be set when the entry is\n  // fulfilled with data from the server response.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(now)\n  const isRevalidation = false\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n): SegmentCacheEntry {\n  // This function is called when we've already confirmed that a particular\n  // segment is cached, but we want to perform another request anyway in case it\n  // returns more complete and/or fresher data than we already have. The logic\n  // for deciding whether to replace the existing entry is handled elsewhere;\n  // this function just handles retrieving a cache entry that we can use to\n  // track the revalidation.\n  //\n  // The reason revalidations are stored in the cache is because we need to be\n  // able to dedupe multiple revalidation requests. The reason they have to be\n  // handled specially is because we shouldn't overwrite a \"normal\" entry if\n  // one exists at the same keypath. So, for each internal cache location, there\n  // is a special \"revalidation\" slot that is used solely for this purpose.\n  //\n  // You can think of it as if all the revalidation entries were stored in a\n  // separate cache map from the canonical entries, and then transfered to the\n  // canonical cache map once the request is complete — this isn't how it's\n  // actually implemented, since it's more efficient to store them in the same\n  // data structure as the normal entries, but that's how it's modeled\n  // conceptually.\n\n  // TODO: Once we implement Fallback behavior for params, where an entry is\n  // re-keyed based on response information, we'll need to account for the\n  // possibility that the keypath of the previous entry is more generic than\n  // the keypath of the revalidating entry. In other words, the server could\n  // return a less generic entry upon revalidation. For now, though, this isn't\n  // a concern because the keypath is based solely on the prefetch strategy,\n  // not on data contained in the response.\n  const existingEntry = readRevalidatingSegmentCacheEntry(now, tree.varyPath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache. The stale time is set to a\n  // default value; the actual stale time will be set when the entry is\n  // fulfilled with data from the server response.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(now)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function overwriteRevalidatingSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  tree: RouteTree\n) {\n  // This function is called when we've already decided to replace an existing\n  // revalidation entry. Create a new entry and write it into the cache,\n  // overwriting the previous value. The stale time is set to a default value;\n  // the actual stale time will be set when the entry is fulfilled with data\n  // from the server response.\n  const varyPathForRequest = getSegmentVaryPathForRequest(fetchStrategy, tree)\n  const pendingEntry = createDetachedSegmentCacheEntry(now)\n  const isRevalidation = true\n  setInCacheMap(\n    segmentCacheMap,\n    varyPathForRequest,\n    pendingEntry,\n    isRevalidation\n  )\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  varyPath: SegmentVaryPath,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n\n  if (isValueExpired(now, getCurrentSegmentCacheVersion(), candidateEntry)) {\n    // The entry is expired. We cannot upsert it.\n    return null\n  }\n\n  const existingEntry = readSegmentCacheEntry(now, varyPath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave revalidating entry in the cache so that it doesn't\n      // get revalidated again unnecessarily. Downgrade the Fulfilled entry to\n      // Rejected and null out the data so it can be garbage collected. We leave\n      // `staleAt` intact to prevent subsequent revalidation attempts only until\n      // the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteFromCacheMap(existingEntry)\n  }\n\n  const isRevalidation = false\n  setInCacheMap(segmentCacheMap, varyPath, candidateEntry, isRevalidation)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  now: number\n): EmptySegmentCacheEntry {\n  // Default stale time for pending segment cache entries. The actual stale time\n  // is set when the entry is fulfilled with data from the server response.\n  const staleAt = now + 30 * 1000\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    rsc: null,\n    isPartial: true,\n    promise: null,\n\n    // Map-related fields\n    ref: null,\n    size: 0,\n    staleAt,\n    version: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n\n  if (fetchStrategy === FetchStrategy.Full) {\n    // We can assume the response will contain the full segment data. Set this\n    // to false so we know it's OK to omit this segment from any navigation\n    // requests that may happen while the data is still pending.\n    pendingEntry.isPartial = false\n  }\n\n  // Set the version here, since this is right before the request is initiated.\n  // The next time the segment cache version is incremented, the entry will\n  // effectively be evicted. This happens before initiating the request, rather\n  // than when receiving the response, because it's guaranteed to happen\n  // before the data is read on the server.\n  pendingEntry.version = getCurrentSegmentCacheVersion()\n  return pendingEntry\n}\n\nexport function attemptToFulfillDynamicSegmentFromBFCache(\n  now: number,\n  segment: EmptySegmentCacheEntry,\n  tree: RouteTree\n): FulfilledSegmentCacheEntry | null {\n  // Attempts to fulfill an empty segment cache entry using data from the\n  // bfcache. This is only valid during a Full prefetch (i.e. one that includes\n  // dynamic data), because the bfcache stores data from navigations which\n  // always include dynamic data.\n\n  // We always use the canonical vary path when checking the bfcache. This is\n  // the same operation we'd use to access the cache during a\n  // regular navigation.\n  const varyPath = tree.varyPath\n\n  // The stale time for dynamic prefetches (default: 5 mins) is different from\n  // the stale time for regular navigations (default: 0 secs). We adjust the\n  // current timestamp to account for the difference.\n  const adjustedCurrentTime = now - STATIC_STALETIME_MS + DYNAMIC_STALETIME_MS\n  const bfcacheEntry = readFromBFCacheDuringRegularNavigation(\n    adjustedCurrentTime,\n    varyPath\n  )\n  if (bfcacheEntry !== null) {\n    // Fulfill the prefetch using the bfcache entry.\n\n    // As explained above, the stale time of this prefetch entry is different\n    // than the one for the bfcache. Calculate when it was originally requested\n    // by subtracting the stale time used by the bfcache.\n    const requestedAt = bfcacheEntry.staleAt - DYNAMIC_STALETIME_MS\n    // Now add the stale time used by dynamic prefetches.\n    const dynamicPrefetchStaleAt = requestedAt + STATIC_STALETIME_MS\n\n    const pendingSegment = upgradeToPendingSegment(segment, FetchStrategy.Full)\n    const isPartial = false\n    return fulfillSegmentCacheEntry(\n      pendingSegment,\n      bfcacheEntry.rsc,\n      dynamicPrefetchStaleAt,\n      isPartial\n    )\n  }\n  return null\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nexport function createMetadataRouteTree(\n  metadataVaryPath: PageVaryPath\n): RouteTree {\n  // The Head is not actually part of the route tree, but other than that, it's\n  // fetched and cached like a segment. Some functions expect a RouteTree\n  // object, so rather than fork the logic in all those places, we use this\n  // \"fake\" one.\n  const metadata: RouteTree = {\n    requestKey: HEAD_REQUEST_KEY,\n    segment: HEAD_REQUEST_KEY,\n    refreshState: null,\n    varyPath: metadataVaryPath,\n    // The metadata isn't really a \"page\" (though it isn't really a \"segment\"\n    // either) but for the purposes of how this field is used, it behaves like\n    // one. If this logic ever gets more complex we can change this to an enum.\n    isPage: true,\n    slots: null,\n    isRootLayout: false,\n    hasLoadingBoundary: HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n    hasRuntimePrefetch: false,\n  }\n  return metadata\n}\n\nexport function fulfillRouteCacheEntry(\n  now: number,\n  entry: PendingRouteCacheEntry,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  // Get the rendered search from the vary path\n  const renderedSearch =\n    getRenderedSearchFromVaryPath(metadataVaryPath) ?? ('' as NormalizedSearch)\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.metadata = createMetadataRouteTree(metadataVaryPath)\n  // Route structure is essentially static — it only changes on deploy.\n  // Always use the static stale time.\n  // NOTE: An exception is rewrites/redirects in middleware or proxy, which can\n  // change routes dynamically. We have other strategies for handling those.\n  fulfilledEntry.staleAt = now + STATIC_STALETIME_MS\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  fulfilledEntry.hasDynamicRewrite = false\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nexport function writeRouteIntoCache(\n  now: number,\n  pathname: NormalizedPathname,\n  tree: RouteTree,\n  metadataVaryPath: PageVaryPath,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  const pendingEntry = createDetachedRouteCacheEntry()\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    now,\n    pendingEntry,\n    tree,\n    metadataVaryPath,\n    couldBeIntercepted,\n    canonicalUrl,\n    isPPREnabled\n  )\n  // nextUrl is always null here because we only write to the route cache for\n  // non-intercepted routes. Intercepted routes are deopted in attemptOptimisticRouting.\n  const renderedSearch = fulfilledEntry.renderedSearch\n  const varyPath = getRouteVaryPath(pathname, renderedSearch, null)\n  const isRevalidation = false\n  setInCacheMap(routeCacheMap, varyPath, fulfilledEntry, isRevalidation)\n  return fulfilledEntry\n}\n\n/**\n * Marks a route cache entry as having a dynamic rewrite. Called when we\n * discover that a route pattern has dynamic rewrite behavior - i.e., we used\n * an optimistic route tree for prediction, but the server responded with a\n * different rendered pathname.\n *\n * Once marked, attempts to use this entry as a template for prediction will\n * bail out to server resolution.\n */\nexport function markRouteEntryAsDynamicRewrite(\n  entry: FulfilledRouteCacheEntry\n): void {\n  entry.hasDynamicRewrite = true\n  // Note: The caller is responsible for also calling invalidateRouteCacheEntries\n  // to invalidate other entries that may have been derived from this template\n  // before we knew it had a dynamic rewrite.\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\ntype RouteTreeAccumulator = {\n  metadataVaryPath: PageVaryPath | null\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_REQUEST_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    pathnameParts,\n    index,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  partialVaryPath: PartialSegmentVaryPath | null,\n  requestKey: SegmentRequestKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    isPage = false\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childSegmentName = childPrefetch.name\n      const childParam = childPrefetch.param\n\n      let childDoesAppearInURL: boolean\n      let childSegment: FlightRouterStateSegment\n      let childPartialVaryPath: PartialSegmentVaryPath | null\n      if (childParam !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParam.type,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childParam.key !== null\n            ? childParam.key\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(\n                childParamValue,\n                '' as NormalizedSearch\n              )\n\n        childPartialVaryPath = appendLayoutVaryPath(\n          partialVaryPath,\n          childParamKey,\n          childSegmentName\n        )\n        childSegment = [\n          childSegmentName,\n          childParamKey,\n          childParam.type,\n          childParam.siblings,\n        ]\n        childDoesAppearInURL = true\n      } else {\n        // This segment does not have a param. Inherit the partial vary path of\n        // the parent.\n        childPartialVaryPath = partialVaryPath\n        childSegment = childSegmentName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childSegmentName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childPartialVaryPath,\n        childRequestKey,\n        pathnameParts,\n        childPathnamePartsIndex,\n        renderedSearch,\n        acc\n      )\n    }\n  } else {\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    refreshState: null,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    varyPath: varyPath as any,\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nexport function convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_REQUEST_KEY,\n    null,\n    renderedSearch,\n    acc\n  )\n}\n\nexport function convertReusedFlightRouterStateToRouteTree(\n  parentRouteTree: RouteTree,\n  parallelRouteKey: string,\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n) {\n  // Create a RouteTree for a FlightRouterState that was reused from an older\n  // route. This happens during a navigation when a parallel route slot does not\n  // match the target route; we reuse whatever slot was already active.\n\n  // Unlike a FlightRouterState, the RouteTree type contains backreferences to\n  // the parent segments. Append the vary path to the parent's vary path.\n  const parentPartialVaryPath = parentRouteTree.isPage\n    ? getPartialPageVaryPath(parentRouteTree.varyPath)\n    : getPartialLayoutVaryPath(parentRouteTree.varyPath)\n  const segment = flightRouterState[0]\n  // And the request key.\n  const parentRequestKey = parentRouteTree.requestKey\n  const requestKeyPart = createSegmentRequestKeyPart(segment)\n  const requestKey = appendSegmentRequestKeyPart(\n    parentRequestKey,\n    parallelRouteKey,\n    requestKeyPart\n  )\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    requestKey,\n    parentPartialVaryPath,\n    renderedSearch,\n    acc\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  requestKey: SegmentRequestKey,\n  parentPartialVaryPath: PartialSegmentVaryPath | null,\n  parentRenderedSearch: NormalizedSearch,\n  acc: RouteTreeAccumulator\n): RouteTree {\n  const originalSegment = flightRouterState[0]\n\n  // If the FlightRouterState has a refresh state, then this segment is part of\n  // an inactive parallel route. It has a different rendered search query than\n  // the outer parent route. In order to construct the inactive route correctly,\n  // we must restore the query that was originally used to render it.\n  const compressedRefreshState = flightRouterState[2] ?? null\n  const refreshState =\n    compressedRefreshState !== null\n      ? {\n          canonicalUrl: compressedRefreshState[0] as string,\n          renderedSearch: compressedRefreshState[1] as NormalizedSearch,\n        }\n      : null\n  const renderedSearch =\n    refreshState !== null ? refreshState.renderedSearch : parentRenderedSearch\n\n  let segment: FlightRouterStateSegment\n  let partialVaryPath: PartialSegmentVaryPath | null\n  let isPage: boolean\n  let varyPath: SegmentVaryPath\n  if (Array.isArray(originalSegment)) {\n    isPage = false\n    const paramCacheKey = originalSegment[1]\n    const paramName = originalSegment[0]\n    partialVaryPath = appendLayoutVaryPath(\n      parentPartialVaryPath,\n      paramCacheKey,\n      paramName\n    )\n    varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    segment = originalSegment\n  } else {\n    // This segment does not have a param. Inherit the partial vary path of\n    // the parent.\n    partialVaryPath = parentPartialVaryPath\n    if (requestKey.endsWith(PAGE_SEGMENT_KEY)) {\n      // This is a page segment.\n      isPage = true\n\n      // The navigation implementation expects the search params to be included\n      // in the segment. However, in the case of a static response, the search\n      // params are omitted. So the client needs to add them back in when reading\n      // from the Segment Cache.\n      //\n      // For consistency, we'll do this for dynamic responses, too.\n      //\n      // TODO: We should move search params out of FlightRouterState and handle\n      // them entirely on the client, similar to our plan for dynamic params.\n      segment = PAGE_SEGMENT_KEY\n      varyPath = finalizePageVaryPath(\n        requestKey,\n        renderedSearch,\n        partialVaryPath\n      )\n      // The metadata \"segment\" is not part the route tree, but it has the same\n      // conceptual params as a page segment. Write the vary path into the\n      // accumulator object. If there are multiple parallel pages, we use the\n      // first one. Which page we choose is arbitrary as long as it's\n      // consistently the same one every time every time. See\n      // finalizeMetadataVaryPath for more details.\n      if (acc.metadataVaryPath === null) {\n        acc.metadataVaryPath = finalizeMetadataVaryPath(\n          requestKey,\n          renderedSearch,\n          partialVaryPath\n        )\n      }\n    } else {\n      // This is a layout segment.\n      isPage = false\n      segment = originalSegment\n      varyPath = finalizeLayoutVaryPath(requestKey, partialVaryPath)\n    }\n  }\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childRequestKey,\n      partialVaryPath,\n      renderedSearch,\n      acc\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    requestKey,\n    segment,\n    refreshState,\n    // TODO: Cheating the type system here a bit because TypeScript can't tell\n    // that the type of isPage and varyPath are consistent. The fix would be to\n    // create separate constructors and call the appropriate one from each of\n    // the branches above. Just seems a bit overkill only for one field so I'll\n    // leave it as-is for now. If isPage were wrong it would break the behavior\n    // and we'd catch it quickly, anyway.\n    varyPath: varyPath as any,\n    isPage: isPage as boolean as any,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const pathname = key.pathname\n  const search = key.search\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    const url = new URL(pathname + search, location.origin)\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, previously we perform a range\n      // request of 64 bytes of the HTML document to check if the target page\n      // is part of this app (by checking if build id matches). Only if the target\n      // page is part of this app do we determine the final canonical URL.\n      //\n      // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n      // some popular static hosting providers (like Cloudflare Pages or Render.com)\n      // do not support range requests, in the worst case, the entire HTML instead\n      // of 64 bytes could be returned, which is wasteful.\n      //\n      // So instead, we drops the check for build id here, and simply perform\n      // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n      // final URL after redirects.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const headResponse = await fetch(url, {\n        method: 'HEAD',\n      })\n      if (headResponse.status < 200 || headResponse.status >= 400) {\n        // The target page responded w/o a successful status code\n        // Could be a WAF serving a 403, or a 5xx from a backend\n        //\n        // Note that we can't use headResponse.ok here, because\n        // Response#ok returns `false` with 3xx responses.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      urlAfterRedirects = headResponse.redirected\n        ? new URL(headResponse.url)\n        : url\n\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      // Convert the server-sent data into the RouteTree format used by the\n      // client cache.\n      //\n      // During this traversal, we accumulate additional data into this\n      // \"accumulator\" object.\n      const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname,\n        renderedSearch,\n        acc\n      )\n      const metadataVaryPath = acc.metadataVaryPath\n      if (metadataVaryPath === null) {\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      discoverKnownRoute(\n        Date.now(),\n        pathname,\n        entry,\n        routeTree,\n        metadataVaryPath,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled,\n        false // hasDynamicRewrite\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          setSizeInCacheMap(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Read head vary params synchronously. Individual segments carry their\n      // own thenables in CacheNodeSeedData.\n      const headVaryParamsThenable = serverData.h\n      const headVaryParams =\n        headVaryParamsThenable !== null\n          ? readVaryParams(headVaryParamsThenable)\n          : null\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled,\n        headVaryParams,\n        pathname\n      )\n    }\n\n    if (!couldBeIntercepted) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n\n      // Re-key the entry. The `set` implementation handles removing it from\n      // its previous position in the cache. We don't need to do anything to\n      // update the LRU, because the entry is already in it.\n      // TODO: Treat this as an upsert — should check if an entry already\n      // exists at the new keypath, and if so, whether we should keep that\n      // one instead.\n      const fulfilledVaryPath: RouteVaryPath = getFulfilledRouteVaryPath(\n        pathname,\n        search,\n        nextUrl,\n        couldBeIntercepted\n      )\n      const isRevalidation = false\n      setInCacheMap(routeCacheMap, fulfilledVaryPath, entry, isRevalidation)\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        setSizeInCacheMap(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    const staleAt = Date.now() + getStaleTimeMs(serverData.staleTime)\n    const fulfilledEntry = fulfillSegmentCacheEntry(\n      segmentCacheEntry,\n      serverData.rsc,\n      staleAt,\n      serverData.isPartial\n    )\n\n    // If the server tells us which params the segment varies by, we can re-key\n    // the entry to a more generic vary path. This allows the entry to be reused\n    // across different param values for params that the segment doesn't\n    // actually depend on.\n    const varyParams = serverData.varyParams\n    if (process.env.__NEXT_VARY_PARAMS && varyParams !== null) {\n      // Re-key the entry by storing it at a more generic vary path where\n      // unused params are replaced with Fallback.\n      const fulfilledVaryPath = getFulfilledSegmentVaryPath(\n        tree.varyPath,\n        varyParams\n      )\n      const isRevalidation = false\n      setInCacheMap(\n        segmentCacheMap,\n        fulfilledVaryPath,\n        fulfilledEntry,\n        isRevalidation\n      )\n    }\n\n    return {\n      value: fulfilledEntry,\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const key = task.key\n  const url = new URL(route.canonicalUrl, location.origin)\n  const nextUrl = key.nextUrl\n\n  if (\n    spawnedEntries.size === 1 &&\n    spawnedEntries.has(route.metadata.requestKey)\n  ) {\n    // The only thing pending is the head. Instruct the server to\n    // skip over everything else.\n    dynamicRequestTree = MetadataOnlyRequestTree\n  }\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time — it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          setSizeInCacheMap(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          serverData.rp?.[0] === true\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n    // Read head vary params synchronously. Individual segments carry their\n    // own thenables in CacheNodeSeedData.\n    const headVaryParamsThenable = serverData.h\n    const headVaryParams =\n      headVaryParamsThenable !== null\n        ? readVaryParams(headVaryParamsThenable)\n        : null\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      headVaryParams,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean,\n  headVaryParams: VaryParams | null,\n  originalPathname: string\n): void {\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Convert the server-sent data into the RouteTree format used by the\n  // client cache.\n  //\n  // During this traversal, we accumulate additional data into this\n  // \"accumulator\" object.\n  const acc: RouteTreeAccumulator = { metadataVaryPath: null }\n  const routeTree = convertRootFlightRouterStateToRouteTree(\n    flightRouterState,\n    renderedSearch,\n    acc\n  )\n  const metadataVaryPath = acc.metadataVaryPath\n  if (metadataVaryPath === null) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const fulfilledEntry = discoverKnownRoute(\n    now,\n    originalPathname,\n    entry,\n    routeTree,\n    metadataVaryPath,\n    couldBeIntercepted,\n    canonicalUrl,\n    routeIsPPREnabled,\n    false // hasDynamicRewrite\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    headVaryParams,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentRequestKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  headVaryParams: VaryParams | null,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  // For runtime prefetches, stale time is in the payload at rp[1].\n  // For other responses, fall back to the header.\n  const staleTimeSeconds =\n    typeof serverData.rp?.[1] === 'number'\n      ? serverData.rp[1]\n      : parseInt(response.headers.get(NEXT_ROUTER_STALE_TIME_HEADER) ?? '', 10)\n  const staleTimeMs = !isNaN(staleTimeSeconds)\n    ? getStaleTimeMs(staleTimeSeconds)\n    : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let tree = route.tree\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        if (tree?.slots?.[parallelRouteKey] !== undefined) {\n          tree = tree.slots[parallelRouteKey]\n        } else {\n          if (spawnedEntries !== null) {\n            rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n          }\n          return null\n        }\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        tree,\n        staleAt,\n        seedData,\n        isResponsePartial,\n        spawnedEntries\n      )\n    }\n\n    const head = flightData.head\n    if (head !== null) {\n      // For head entries, use the head-specific vary params passed as parameter.\n      fulfillEntrySpawnedByRuntimePrefetch(\n        now,\n        fetchStrategy,\n        head,\n        flightData.isHeadPartial,\n        staleAt,\n        headVaryParams,\n        route.metadata,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  tree: RouteTree,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a runtime server request\n  // (CacheNodeSeedData) into the prefetch cache.\n  const rsc = seedData[0]\n  const isPartial = rsc === null || isResponsePartial\n  const varyParamsThenable = seedData[5]\n  // Each segment carries its own vary params thenable in the seed data. The\n  // thenable resolves to the set of params the segment accessed during render.\n  // A null thenable means tracking was not enabled (not a prerender).\n  const varyParams =\n    varyParamsThenable !== null ? readVaryParams(varyParamsThenable) : null\n  fulfillEntrySpawnedByRuntimePrefetch(\n    now,\n    fetchStrategy,\n    rsc,\n    isPartial,\n    staleAt,\n    varyParams,\n    tree,\n    entriesOwnedByCurrentTask\n  )\n\n  // Recursively write the child data into the cache.\n  const slots = tree.slots\n  if (slots !== null) {\n    const seedDataChildren = seedData[1]\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childSeedData: CacheNodeSeedData | null | void =\n        seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null && childSeedData !== undefined) {\n        writeSeedDataIntoCache(\n          now,\n          task,\n          fetchStrategy,\n          childTree,\n          staleAt,\n          childSeedData,\n          isResponsePartial,\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nfunction fulfillEntrySpawnedByRuntimePrefetch(\n  now: number,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  rsc: React.ReactNode,\n  isPartial: boolean,\n  staleAt: number,\n  segmentVaryParams: Set<string> | null,\n  tree: RouteTree,\n  entriesOwnedByCurrentTask: Map<\n    SegmentRequestKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(tree.requestKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    const fulfilledEntry = fulfillSegmentCacheEntry(\n      ownedEntry,\n      rsc,\n      staleAt,\n      isPartial\n    )\n    // Re-key the entry based on which params the segment actually depends on.\n    if (process.env.__NEXT_VARY_PARAMS && segmentVaryParams !== null) {\n      const fulfilledVaryPath = getFulfilledSegmentVaryPath(\n        tree.varyPath,\n        segmentVaryParams\n      )\n      const isRevalidation = false\n      setInCacheMap(\n        segmentCacheMap,\n        fulfilledVaryPath,\n        fulfilledEntry,\n        isRevalidation\n      )\n    }\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      tree\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      const fulfilledEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        staleAt,\n        isPartial\n      )\n      // Re-key the entry based on which params the segment actually depends on.\n      if (process.env.__NEXT_VARY_PARAMS && segmentVaryParams !== null) {\n        const fulfilledVaryPath = getFulfilledSegmentVaryPath(\n          tree.varyPath,\n          segmentVaryParams\n        )\n        const isRevalidation = false\n        setInCacheMap(\n          segmentCacheMap,\n          fulfilledVaryPath,\n          fulfilledEntry,\n          isRevalidation\n        )\n      }\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(now),\n          fetchStrategy\n        ),\n        rsc,\n        staleAt,\n        isPartial\n      )\n      // Use the fulfilled vary path if available, otherwise fall back to\n      // the request vary path.\n      const varyPath =\n        process.env.__NEXT_VARY_PARAMS && segmentVaryParams !== null\n          ? getFulfilledSegmentVaryPath(tree.varyPath, segmentVaryParams)\n          : getSegmentVaryPathForRequest(fetchStrategy, tree)\n      upsertSegmentEntry(now, varyPath, newEntry)\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n","import type {\n  FlightRouterState,\n  Segment as FlightRouterStateSegment,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport { matchSegment } from '../match-segments'\nimport {\n  readOrCreateRouteCacheEntry,\n  readOrCreateSegmentCacheEntry,\n  fetchRouteOnCacheMiss,\n  fetchSegmentOnCacheMiss,\n  EntryStatus,\n  type FulfilledRouteCacheEntry,\n  type RouteCacheEntry,\n  type SegmentCacheEntry,\n  type RouteTree,\n  fetchSegmentPrefetchesUsingDynamicRequest,\n  type PendingSegmentCacheEntry,\n  convertRouteTreeToFlightRouterState,\n  readOrCreateRevalidatingSegmentEntry,\n  upsertSegmentEntry,\n  type FulfilledSegmentCacheEntry,\n  upgradeToPendingSegment,\n  waitForSegmentCacheEntry,\n  overwriteRevalidatingSegmentCacheEntry,\n  canNewFetchStrategyProvideMoreContent,\n  attemptToFulfillDynamicSegmentFromBFCache,\n} from './cache'\nimport { getSegmentVaryPathForRequest, type SegmentVaryPath } from './vary-path'\nimport type { RouteCacheKey } from './cache-key'\nimport { createCacheKey } from './cache-key'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './types'\nimport {\n  getCurrentRouteCacheVersion,\n  getCurrentSegmentCacheVersion,\n} from './cache'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { SegmentRequestKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\nconst scheduleMicrotask =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn: () => unknown) =>\n        Promise.resolve()\n          .then(fn)\n          .catch((error) =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n\nexport type PrefetchTask = {\n  key: RouteCacheKey\n\n  /**\n   * The FlightRouterState at the time the task was initiated. This is needed\n   * when falling back to the non-PPR behavior, which only prefetches up to\n   * the first loading boundary.\n   */\n  treeAtTimeOfPrefetch: FlightRouterState\n\n  /**\n   * The cache versions at the time the task was initiated. Used to determine\n   * if the cache was invalidated since the task was initiated. Route and\n   * segment caches have separate versions so they can be invalidated\n   * independently.\n   */\n  routeCacheVersion: number\n  segmentCacheVersion: number\n\n  /**\n   * Whether to prefetch dynamic data, in addition to static data. This is\n   * used by `<Link prefetch={true}>`.\n   *\n   * Note that a task with `FetchStrategy.PPR` might need to use\n   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n   * does not support PPR after doing the initial route prefetch.\n   */\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  /**\n   * sortId is an incrementing counter\n   *\n   * Newer prefetches are prioritized over older ones, so that as new links\n   * enter the viewport, they are not starved by older links that are no\n   * longer relevant. In the future, we can add additional prioritization\n   * heuristics, like removing prefetches once a link leaves the viewport.\n   *\n   * The sortId is assigned when the prefetch is initiated, and reassigned if\n   * the same task is prefetched again (effectively bumping it to the top of\n   * the queue).\n   *\n   * TODO: We can add additional fields here to indicate what kind of prefetch\n   * it is. For example, was it initiated by a link? Or was it an imperative\n   * call? If it was initiated by a link, we can remove it from the queue when\n   * the link leaves the viewport, but if it was an imperative call, then we\n   * should keep it in the queue until it's fulfilled.\n   *\n   * We can also add priority levels. For example, hovering over a link could\n   * increase the priority of its prefetch.\n   */\n  sortId: number\n\n  /**\n   * The priority of the task. Like sortId, this affects the task's position in\n   * the queue, so it must never be updated without resifting the heap.\n   */\n  priority: PrefetchPriority\n\n  /**\n   * The phase of the task. Tasks are split into multiple phases so that their\n   * priority can be adjusted based on what kind of work they're doing.\n   * Concretely, prefetching the route tree is higher priority than prefetching\n   * segment data.\n   */\n  phase: PrefetchPhase\n\n  /**\n   * These fields are temporary state for tracking the currently running task.\n   * They are reset after each iteration of the task queue.\n   */\n  hasBackgroundWork: boolean\n  spawnedRuntimePrefetches: Set<SegmentRequestKey> | null\n\n  /**\n   * True if the prefetch was cancelled.\n   */\n  isCanceled: boolean\n\n  /**\n   * The callback passed to `router.prefetch`, if given.\n   */\n  onInvalidate: null | (() => void)\n\n  /**\n   * The index of the task in the heap's backing array. Used to efficiently\n   * change the priority of a task by re-sifting it, which requires knowing\n   * where it is in the array. This is only used internally by the heap\n   * algorithm. The naive alternative is indexOf every time a task is queued,\n   * which has O(n) complexity.\n   *\n   * We also use this field to check whether a task is currently in the queue.\n   */\n  _heapIndex: number\n}\n\nconst enum PrefetchTaskExitStatus {\n  /**\n   * The task yielded because there are too many requests in progress.\n   */\n  InProgress,\n\n  /**\n   * The task is blocked. It needs more data before it can proceed.\n   *\n   * Currently the only reason this happens is we're still waiting to receive a\n   * route tree from the server, because we can't start prefetching the segments\n   * until we know what to prefetch.\n   */\n  Blocked,\n\n  /**\n   * There's nothing left to prefetch.\n   */\n  Done,\n}\n\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\nconst enum PrefetchPhase {\n  RouteTree = 1,\n  Segments = 0,\n}\n\nexport type PrefetchSubtaskResult<T> = {\n  /**\n   * A promise that resolves when the network connection is closed.\n   */\n  closed: Promise<void>\n  value: T\n}\n\nconst taskHeap: Array<PrefetchTask> = []\n\nlet inProgressRequests = 0\n\nlet sortIdCounter = 0\nlet didScheduleMicrotask = false\n\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink: PrefetchTask | null = null\n\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300\n\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle: ReturnType<typeof setTimeout> | null =\n  null\n\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */\nexport function startRevalidationCooldown(): void {\n  // Clear any existing timeout in case multiple revalidations happen\n  // in quick succession.\n  if (revalidationCooldownTimeoutHandle !== null) {\n    clearTimeout(revalidationCooldownTimeoutHandle)\n  }\n\n  // Schedule the cooldown to expire after the delay.\n  revalidationCooldownTimeoutHandle = setTimeout(() => {\n    revalidationCooldownTimeoutHandle = null\n    // Retry the prefetch queue now that the cooldown has expired.\n    ensureWorkIsScheduled()\n  }, REVALIDATION_COOLDOWN_MS)\n}\n\nexport type IncludeDynamicData = null | 'full' | 'dynamic'\n\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */\nexport function schedulePrefetchTask(\n  key: RouteCacheKey,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority,\n  onInvalidate: null | (() => void)\n): PrefetchTask {\n  // Spawn a new prefetch task\n  const task: PrefetchTask = {\n    key,\n    treeAtTimeOfPrefetch,\n    routeCacheVersion: getCurrentRouteCacheVersion(),\n    segmentCacheVersion: getCurrentSegmentCacheVersion(),\n    priority,\n    phase: PrefetchPhase.RouteTree,\n    hasBackgroundWork: false,\n    spawnedRuntimePrefetches: null,\n    fetchStrategy,\n    sortId: sortIdCounter++,\n    isCanceled: false,\n    onInvalidate,\n    _heapIndex: -1,\n  }\n\n  trackMostRecentlyHoveredLink(task)\n\n  heapPush(taskHeap, task)\n\n  // Schedule an async task to process the queue.\n  //\n  // The main reason we process the queue in an async task is for batching.\n  // It's common for a single JS task/event to trigger multiple prefetches.\n  // By deferring to a microtask, we only process the queue once per JS task.\n  // If they have different priorities, it also ensures they are processed in\n  // the optimal order.\n  ensureWorkIsScheduled()\n\n  return task\n}\n\nexport function cancelPrefetchTask(task: PrefetchTask): void {\n  // Remove the prefetch task from the queue. If the task already completed,\n  // then this is a no-op.\n  //\n  // We must also explicitly mark the task as canceled so that a blocked task\n  // does not get added back to the queue when it's pinged by the network.\n  task.isCanceled = true\n  heapDelete(taskHeap, task)\n}\n\nexport function reschedulePrefetchTask(\n  task: PrefetchTask,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority\n): void {\n  // Bump the prefetch task to the top of the queue, as if it were a fresh\n  // task. This is essentially the same as canceling the task and scheduling\n  // a new one, except it reuses the original object.\n  //\n  // The primary use case is to increase the priority of a Link-initated\n  // prefetch on hover.\n\n  // Un-cancel the task, in case it was previously canceled.\n  task.isCanceled = false\n  task.phase = PrefetchPhase.RouteTree\n\n  // Assign a new sort ID to move it ahead of all other tasks at the same\n  // priority level. (Higher sort IDs are processed first.)\n  task.sortId = sortIdCounter++\n  task.priority =\n    // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n\n  task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n  task.fetchStrategy = fetchStrategy\n\n  trackMostRecentlyHoveredLink(task)\n\n  if (task._heapIndex !== -1) {\n    // The task is already in the queue.\n    heapResift(taskHeap, task)\n  } else {\n    heapPush(taskHeap, task)\n  }\n  ensureWorkIsScheduled()\n}\n\nexport function isPrefetchTaskDirty(\n  task: PrefetchTask,\n  nextUrl: string | null,\n  tree: FlightRouterState\n): boolean {\n  // This is used to quickly bail out of a prefetch task if the result is\n  // guaranteed to not have changed since the task was initiated. This is\n  // strictly an optimization — theoretically, if it always returned true, no\n  // behavior should change because a full prefetch task will effectively\n  // perform the same checks.\n  return (\n    task.routeCacheVersion !== getCurrentRouteCacheVersion() ||\n    task.segmentCacheVersion !== getCurrentSegmentCacheVersion() ||\n    task.treeAtTimeOfPrefetch !== tree ||\n    task.key.nextUrl !== nextUrl\n  )\n}\n\nfunction trackMostRecentlyHoveredLink(task: PrefetchTask) {\n  // Track the mostly recently hovered link, i.e. the most recently scheduled\n  // task at Intent priority. There must only be one such task at a time.\n  if (\n    task.priority === PrefetchPriority.Intent &&\n    task !== mostRecentlyHoveredLink\n  ) {\n    if (mostRecentlyHoveredLink !== null) {\n      // Bump the previously hovered link's priority down to Default.\n      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n        heapResift(taskHeap, mostRecentlyHoveredLink)\n      }\n    }\n    mostRecentlyHoveredLink = task\n  }\n}\n\nfunction ensureWorkIsScheduled() {\n  if (didScheduleMicrotask) {\n    // Already scheduled a task to process the queue\n    return\n  }\n  didScheduleMicrotask = true\n  scheduleMicrotask(processQueueInMicrotask)\n}\n\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit — prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */\nfunction hasNetworkBandwidth(task: PrefetchTask): boolean {\n  // Check if we're within the revalidation cooldown window\n  if (revalidationCooldownTimeoutHandle !== null) {\n    // We're within the cooldown window. Return false to prevent prefetching.\n    // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n    // to retry the queue.\n    return false\n  }\n\n  // TODO: Also check if there's an in-progress navigation. We should never\n  // add prefetch requests to the network queue if an actual navigation is\n  // taking place, to ensure there's sufficient bandwidth for render-blocking\n  // data and resources.\n\n  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n\n  if (task.priority === PrefetchPriority.Intent) {\n    // The most recently hovered link is allowed to exceed the default limit.\n    //\n    // The goal is to always have enough bandwidth to start a new prefetch\n    // request when hovering over a link.\n    //\n    // However, because we don't abort in-progress requests, it's still possible\n    // we'll run out of bandwidth. When links are hovered in quick succession,\n    // there could be multiple hover requests running simultaneously.\n    return inProgressRequests < 12\n  }\n\n  // The default limit is lower than the limit for a hovered link.\n  return inProgressRequests < 4\n}\n\nfunction spawnPrefetchSubtask<T>(\n  prefetchSubtask: Promise<PrefetchSubtaskResult<T> | null>\n): Promise<T | null> {\n  // When the scheduler spawns an async task, we don't await its result.\n  // Instead, the async task writes its result directly into the cache, then\n  // pings the scheduler to continue.\n  //\n  // We process server responses streamingly, so the prefetch subtask will\n  // likely resolve before we're finished receiving all the data. The subtask\n  // result includes a promise that resolves once the network connection is\n  // closed. The scheduler uses this to control network bandwidth by tracking\n  // and limiting the number of concurrent requests.\n  inProgressRequests++\n  return prefetchSubtask.then((result) => {\n    if (result === null) {\n      // The prefetch task errored before it could start processing the\n      // network stream. Assume the connection is closed.\n      onPrefetchConnectionClosed()\n      return null\n    }\n    // Wait for the connection to close before freeing up more bandwidth.\n    result.closed.then(onPrefetchConnectionClosed)\n    return result.value\n  })\n}\n\nfunction onPrefetchConnectionClosed(): void {\n  inProgressRequests--\n\n  // Notify the scheduler that we have more bandwidth, and can continue\n  // processing tasks.\n  ensureWorkIsScheduled()\n}\n\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport function pingPrefetchTask(task: PrefetchTask) {\n  // \"Ping\" a prefetch that's already in progress to notify it of new data.\n  if (\n    // Check if prefetch was canceled.\n    task.isCanceled ||\n    // Check if prefetch is already queued.\n    task._heapIndex !== -1\n  ) {\n    return\n  }\n  // Add the task back to the queue.\n  heapPush(taskHeap, task)\n  ensureWorkIsScheduled()\n}\n\nfunction processQueueInMicrotask() {\n  didScheduleMicrotask = false\n\n  // We aim to minimize how often we read the current time. Since nearly all\n  // functions in the prefetch scheduler are synchronous, we can read the time\n  // once and pass it as an argument wherever it's needed.\n  const now = Date.now()\n\n  // Process the task queue until we run out of network bandwidth.\n  let task = heapPeek(taskHeap)\n  while (task !== null && hasNetworkBandwidth(task)) {\n    task.routeCacheVersion = getCurrentRouteCacheVersion()\n    task.segmentCacheVersion = getCurrentSegmentCacheVersion()\n\n    const exitStatus = pingRoute(now, task)\n\n    // These fields are only valid for a single attempt. Reset them after each\n    // iteration of the task queue.\n    const hasBackgroundWork = task.hasBackgroundWork\n    task.hasBackgroundWork = false\n    task.spawnedRuntimePrefetches = null\n\n    switch (exitStatus) {\n      case PrefetchTaskExitStatus.InProgress:\n        // The task yielded because there are too many requests in progress.\n        // Stop processing tasks until we have more bandwidth.\n        return\n      case PrefetchTaskExitStatus.Blocked:\n        // The task is blocked. It needs more data before it can proceed.\n        // Keep the task out of the queue until the server responds.\n        heapPop(taskHeap)\n        // Continue to the next task\n        task = heapPeek(taskHeap)\n        continue\n      case PrefetchTaskExitStatus.Done:\n        if (task.phase === PrefetchPhase.RouteTree) {\n          // Finished prefetching the route tree. Proceed to prefetching\n          // the segments.\n          task.phase = PrefetchPhase.Segments\n          heapResift(taskHeap, task)\n        } else if (hasBackgroundWork) {\n          // The task spawned additional background work. Reschedule the task\n          // at background priority.\n          task.priority = PrefetchPriority.Background\n          heapResift(taskHeap, task)\n        } else {\n          // The prefetch is complete. Continue to the next task.\n          heapPop(taskHeap)\n        }\n        task = heapPeek(taskHeap)\n        continue\n      default:\n        exitStatus satisfies never\n    }\n  }\n}\n\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */\nfunction background(task: PrefetchTask): boolean {\n  if (task.priority === PrefetchPriority.Background) {\n    return true\n  }\n  task.hasBackgroundWork = true\n  return false\n}\n\nfunction pingRoute(now: number, task: PrefetchTask): PrefetchTaskExitStatus {\n  const key = task.key\n  const route = readOrCreateRouteCacheEntry(now, task, key)\n  const exitStatus = pingRootRouteTree(now, task, route)\n\n  if (exitStatus !== PrefetchTaskExitStatus.InProgress && key.search !== '') {\n    // If the URL has a non-empty search string, also prefetch the pathname\n    // without the search string. We use the searchless route tree as a base for\n    // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n    //\n    // Note that we don't need to prefetch any of the segment data. Just the\n    // route tree.\n    //\n    // TODO: This is a temporary solution; the plan is to replace this by adding\n    // a wildcard lookup method to the TupleMap implementation. This is\n    // non-trivial to implement because it needs to account for things like\n    // fallback route entries, hence this temporary workaround.\n    const url = new URL(key.pathname, location.origin)\n    const keyWithoutSearch = createCacheKey(url.href, key.nextUrl)\n    const routeWithoutSearch = readOrCreateRouteCacheEntry(\n      now,\n      task,\n      keyWithoutSearch\n    )\n    switch (routeWithoutSearch.status) {\n      case EntryStatus.Empty: {\n        if (background(task)) {\n          routeWithoutSearch.status = EntryStatus.Pending\n          spawnPrefetchSubtask(\n            fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch)\n          )\n        }\n        break\n      }\n      case EntryStatus.Pending:\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected: {\n        // Either the route tree is already cached, or there's already a\n        // request in progress. Since we don't need to fetch any segment data\n        // for this route, there's nothing left to do.\n        break\n      }\n      default:\n        routeWithoutSearch satisfies never\n    }\n  }\n\n  return exitStatus\n}\n\nfunction pingRootRouteTree(\n  now: number,\n  task: PrefetchTask,\n  route: RouteCacheEntry\n): PrefetchTaskExitStatus {\n  switch (route.status) {\n    case EntryStatus.Empty: {\n      // Route is not yet cached, and there's no request already in progress.\n      // Spawn a task to request the route, load it into the cache, and ping\n      // the task to continue.\n\n      // TODO: There are multiple strategies in the <Link> API for prefetching\n      // a route. Currently we've only implemented the main one: per-segment,\n      // static-data only.\n      //\n      // There's also `<Link prefetch={true}>`\n      // which prefetch both static *and* dynamic data.\n      // Similarly, we need to fallback to the old, per-page\n      // behavior if PPR is disabled for a route (via the incremental opt-in).\n      //\n      // Those cases will be handled here.\n      spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key))\n\n      // If the request takes longer than a minute, a subsequent request should\n      // retry instead of waiting for this one. When the response is received,\n      // this value will be replaced by a new value based on the stale time sent\n      // from the server.\n      // TODO: We should probably also manually abort the fetch task, to reclaim\n      // server bandwidth.\n      route.staleAt = now + 60 * 1000\n\n      // Upgrade to Pending so we know there's already a request in progress\n      route.status = EntryStatus.Pending\n\n      // Intentional fallthrough to the Pending branch\n    }\n    case EntryStatus.Pending: {\n      // Still pending. We can't start prefetching the segments until the route\n      // tree has loaded. Add the task to the set of blocked tasks so that it\n      // is notified when the route tree is ready.\n      const blockedTasks = route.blockedTasks\n      if (blockedTasks === null) {\n        route.blockedTasks = new Set([task])\n      } else {\n        blockedTasks.add(task)\n      }\n      return PrefetchTaskExitStatus.Blocked\n    }\n    case EntryStatus.Rejected: {\n      // Route tree failed to load. Treat as a 404.\n      return PrefetchTaskExitStatus.Done\n    }\n    case EntryStatus.Fulfilled: {\n      if (task.phase !== PrefetchPhase.Segments) {\n        // Do not prefetch segment data until we've entered the segment phase.\n        return PrefetchTaskExitStatus.Done\n      }\n      // Recursively fill in the segment tree.\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const tree = route.tree\n\n      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n      // We don't need to do this for runtime prefetches, because those are only available in\n      // `cacheComponents`, where every route is PPR.\n      const fetchStrategy =\n        task.fetchStrategy === FetchStrategy.PPR\n          ? route.isPPREnabled\n            ? FetchStrategy.PPR\n            : FetchStrategy.LoadingBoundary\n          : task.fetchStrategy\n\n      switch (fetchStrategy) {\n        case FetchStrategy.PPR: {\n          // For Cache Components pages, each segment may be prefetched\n          // statically or using a runtime request, based on various\n          // configurations and heuristics. We'll do this in two passes: first\n          // traverse the tree and perform all the static prefetches.\n          //\n          // Then, if there are any segments that need a runtime request,\n          // do another pass to perform a runtime prefetch.\n          pingStaticHead(now, task, route)\n          const exitStatus = pingSharedPartOfCacheComponentsTree(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree\n          )\n          if (exitStatus === PrefetchTaskExitStatus.InProgress) {\n            // Child yielded without finishing.\n            return PrefetchTaskExitStatus.InProgress\n          }\n          const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches\n          if (spawnedRuntimePrefetches !== null) {\n            // During the first pass, we discovered segments that require a\n            // runtime prefetch. Do a second pass to construct a request tree.\n            const spawnedEntries = new Map<\n              SegmentRequestKey,\n              PendingSegmentCacheEntry\n            >()\n            pingRuntimeHead(\n              now,\n              task,\n              route,\n              spawnedEntries,\n              FetchStrategy.PPRRuntime\n            )\n            const requestTree = pingRuntimePrefetches(\n              now,\n              task,\n              route,\n              tree,\n              spawnedRuntimePrefetches,\n              spawnedEntries\n            )\n            let needsDynamicRequest = spawnedEntries.size > 0\n            if (needsDynamicRequest) {\n              // Perform a dynamic prefetch request and populate the cache with\n              // the result.\n              spawnPrefetchSubtask(\n                fetchSegmentPrefetchesUsingDynamicRequest(\n                  task,\n                  route,\n                  FetchStrategy.PPRRuntime,\n                  requestTree,\n                  spawnedEntries\n                )\n              )\n            }\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        case FetchStrategy.Full:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.LoadingBoundary: {\n          // Prefetch multiple segments using a single dynamic request.\n          // TODO: We can consolidate this branch with previous one by modeling\n          // it as if the first segment in the new tree has runtime prefetching\n          // enabled. Will do this as a follow-up refactor. Might want to remove\n          // the special metatdata case below first. In the meantime, it's not\n          // really that much duplication, just would be nice to remove one of\n          // these codepaths.\n          const spawnedEntries = new Map<\n            SegmentRequestKey,\n            PendingSegmentCacheEntry\n          >()\n          pingRuntimeHead(now, task, route, spawnedEntries, fetchStrategy)\n          const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree,\n            spawnedEntries,\n            fetchStrategy\n          )\n          let needsDynamicRequest = spawnedEntries.size > 0\n          if (needsDynamicRequest) {\n            spawnPrefetchSubtask(\n              fetchSegmentPrefetchesUsingDynamicRequest(\n                task,\n                route,\n                fetchStrategy,\n                dynamicRequestTree,\n                spawnedEntries\n              )\n            )\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        default:\n          fetchStrategy satisfies never\n      }\n      break\n    }\n    default: {\n      route satisfies never\n    }\n  }\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingStaticHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry\n): void {\n  // The Head data for a page (metadata, viewport) is not really a route\n  // segment, in the sense that it doesn't appear in the route tree. But we\n  // store it in the cache as if it were, using a special key.\n  pingStaticSegmentData(\n    now,\n    task,\n    route,\n    readOrCreateSegmentCacheEntry(now, FetchStrategy.PPR, route.metadata),\n    task.key,\n    route.metadata\n  )\n}\n\nfunction pingRuntimeHead(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): void {\n  pingRouteTreeAndIncludeDynamicData(\n    now,\n    task,\n    route,\n    route.metadata,\n    false,\n    spawnedEntries,\n    // When prefetching the head, there's no difference between Full\n    // and LoadingBoundary\n    fetchStrategy === FetchStrategy.LoadingBoundary\n      ? FetchStrategy.Full\n      : fetchStrategy\n  )\n}\n\n// TODO: Rename dynamic -> runtime throughout this module\n\nfunction pingSharedPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree\n): PrefetchTaskExitStatus {\n  // When Cache Components is enabled (or PPR, or a fully static route when PPR\n  // is disabled; those cases are treated equivalently to Cache Components), we\n  // start by prefetching each segment individually. Once we reach the \"new\"\n  // part of the tree — the part that doesn't exist on the current page — we\n  // may choose to switch to a runtime prefetch instead, based on the\n  // information sent by the server in the route tree.\n  //\n  // The traversal starts in the \"shared\" part of the tree. Once we reach the\n  // \"new\" part of the tree, we switch to a different traversal,\n  // pingNewPartOfCacheComponentsTree.\n\n  // Prefetch this segment's static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    newTree\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n\n  // Recursively ping the children.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      let childExitStatus\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // We're still in the \"shared\" part of the tree.\n        childExitStatus = pingSharedPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild\n        )\n      } else {\n        // We've entered the \"new\" part of the tree. Switch\n        // traversal functions.\n        childExitStatus = pingNewPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          newTreeChild\n        )\n      }\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingNewPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n  // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n  // exist on the current page. (In other words, we're deeper than the\n  // shared layouts.) Segments in here default to being prefetched statically.\n  // However, if the server instructs us to, we may switch to a runtime\n  // prefetch instead. Traverse the tree and check at each segment.\n  if (tree.hasRuntimePrefetch) {\n    // This route has a runtime prefetch response. Since we're below the shared\n    // layout, everything from this point should be prefetched using a single,\n    // combined runtime request, rather than using per-segment static requests.\n    // This is true even if some of the child segments are known to be fully\n    // static — once we've decided to perform a runtime prefetch, we might as\n    // well respond with the static segments in the same roundtrip. (That's how\n    // regular navigations work, too.) We'll still skip over segments that are\n    // already cached, though.\n    //\n    // It's the server's responsibility to set a reasonable value of\n    // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n    // server may send a value of `false` even if the user opts in, if it\n    // determines during build that the route is always fully static. There are\n    // more optimizations we can do once we implement fallback param\n    // tracking, too.\n    //\n    // Use the task object to collect the segments that need a runtime prefetch.\n    // This will signal to the outer task queue that a second traversal is\n    // required to construct a request tree.\n    if (task.spawnedRuntimePrefetches === null) {\n      task.spawnedRuntimePrefetches = new Set([tree.requestKey])\n    } else {\n      task.spawnedRuntimePrefetches.add(tree.requestKey)\n    }\n    // Then exit the traversal without prefetching anything further.\n    return PrefetchTaskExitStatus.Done\n  }\n\n  // This segment should not be runtime prefetched. Prefetch its static data.\n  const segment = readOrCreateSegmentCacheEntry(now, task.fetchStrategy, tree)\n  pingStaticSegmentData(now, task, route, segment, task.key, tree)\n  if (tree.slots !== null) {\n    if (!hasNetworkBandwidth(task)) {\n      // Stop prefetching segments until there's more bandwidth.\n      return PrefetchTaskExitStatus.InProgress\n    }\n    // Recursively ping the children.\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      const childExitStatus = pingNewPartOfCacheComponentsTree(\n        now,\n        task,\n        route,\n        childTree\n      )\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n  // This segment and all its children have finished prefetching.\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction diffRouteTreeAgainstCurrent(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): FlightRouterState {\n  // This is a single recursive traversal that does multiple things:\n  // - Finds the parts of the target route (newTree) that are not part of\n  //   of the current page (oldTree) by diffing them, using the same algorithm\n  //   as a real navigation.\n  // - Constructs a request tree (FlightRouterState) that describes which\n  //   segments need to be prefetched and which ones are already cached.\n  // - Creates a set of pending cache entries for the segments that need to\n  //   be prefetched, so that a subsequent prefetch task does not request the\n  //   same segments again.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // This segment is already part of the current route. Keep traversing.\n        const requestTreeChild = diffRouteTreeAgainstCurrent(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild,\n          spawnedEntries,\n          fetchStrategy\n        )\n        requestTreeChildren[parallelRouteKey] = requestTreeChild\n      } else {\n        // This segment is not part of the current route. We're entering a\n        // part of the tree that we need to prefetch (unless everything is\n        // already cached).\n        switch (fetchStrategy) {\n          case FetchStrategy.LoadingBoundary: {\n            // When PPR is disabled, we can't prefetch per segment. We must\n            // fallback to the old prefetch behavior and send a dynamic request.\n            // Only routes that include a loading boundary can be prefetched in\n            // this way.\n            //\n            // This is simlar to a \"full\" prefetch, but we're much more\n            // conservative about which segments to include in the request.\n            //\n            // The server will only render up to the first loading boundary\n            // inside new part of the tree. If there's no loading boundary\n            // anywhere in the tree, the server will never return any data, so\n            // we can skip the request.\n            const subtreeHasLoadingBoundary =\n              newTreeChild.hasLoadingBoundary !==\n              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n            const requestTreeChild = subtreeHasLoadingBoundary\n              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                  now,\n                  task,\n                  route,\n                  newTreeChild,\n                  null,\n                  spawnedEntries\n                )\n              : // There's no loading boundary within this tree. Bail out.\n                convertRouteTreeToFlightRouterState(newTreeChild)\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.PPRRuntime: {\n            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n            // not just the static PPR shell.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.Full: {\n            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n            // static and dynamic. We issue roughly the same request that we\n            // would during a real navigation. The goal is that once the\n            // navigation occurs, the router should not have to fetch any\n            // additional data.\n            //\n            // Although the response will include dynamic data, opting into a\n            // Full prefetch — via <Link prefetch={true}> — implicitly\n            // instructs the cache to treat the response as \"static\", or non-\n            // dynamic, since the whole point is to cache it for\n            // future navigations.\n            //\n            // Construct a tree (currently a FlightRouterState) that represents\n            // which segments need to be prefetched and which ones are already\n            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n            // send the request tree to the server and use the response to\n            // populate the segment cache.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          default:\n            fetchStrategy satisfies never\n        }\n      }\n    }\n  }\n  const requestTree: FlightRouterState = [\n    newTree.segment,\n    requestTreeChildren,\n    null,\n    null,\n    newTree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n  // server is only going to return a minimal loading state — it will stop\n  // rendering at the first loading boundary. Whereas a Full prefetch is\n  // intentionally aggressive and tries to pretfetch all the data that will be\n  // needed for a navigation, a LoadingBoundary prefetch is much more\n  // conservative. For example, it will omit from the request tree any segment\n  // that is already cached, regardles of whether it's partial or full. By\n  // contrast, a Full prefetch will refetch partial segments.\n\n  // \"inside-shared-layout\" tells the server where to start looking for a\n  // loading boundary.\n  let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n    refetchMarkerContext === null ? 'inside-shared-layout' : null\n\n  const segment = readOrCreateSegmentCacheEntry(now, task.fetchStrategy, tree)\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Add a refetch marker so the server knows\n      // to start rendering here.\n      // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n      // FlightRouterState from the request tree. I think this would probably\n      // already work even without any updates to the server. For consistency,\n      // though, I'll send the full tree and we'll look into this later as part\n      // of a larger redesign of the request protocol.\n\n      // Add the pending cache entry to the result map.\n      spawnedEntries.set(\n        tree.requestKey,\n        upgradeToPendingSegment(\n          segment,\n          // Set the fetch strategy to LoadingBoundary to indicate that the server\n          // might not include it in the pending response. If another route is able\n          // to issue a per-segment request, we'll do that in the background.\n          FetchStrategy.LoadingBoundary\n        )\n      )\n      if (refetchMarkerContext !== 'refetch') {\n        refetchMarker = refetchMarkerContext = 'refetch'\n      } else {\n        // There's already a parent with a refetch marker, so we don't need\n        // to add another one.\n      }\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      const segmentHasLoadingBoundary =\n        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n      if (segmentHasLoadingBoundary) {\n        // This segment has a loading boundary, which means the server won't\n        // render its children. So there's nothing left to prefetch along this\n        // path. We can bail out.\n        return convertRouteTreeToFlightRouterState(tree)\n      }\n      // NOTE: If the cached segment were fetched using PPR, then it might be\n      // partial. We could get a more complete version of the segment by\n      // including it in this non-PPR request.\n      //\n      // We're intentionally choosing not to, though, because it's generally\n      // better to avoid doing a full prefetch whenever possible.\n      break\n    }\n    case EntryStatus.Pending: {\n      // There's another prefetch currently in progress. Don't add the refetch\n      // marker yet, so the server knows it can skip rendering this segment.\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The segment failed to load. We shouldn't issue another request until\n      // the stale time has elapsed.\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingPPRDisabledRouteTreeUpToLoadingBoundary(\n          now,\n          task,\n          route,\n          childTree,\n          refetchMarkerContext,\n          spawnedEntries\n        )\n    }\n  }\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRouteTreeAndIncludeDynamicData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  isInsideRefetchingParent: boolean,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): FlightRouterState {\n  // The tree we're constructing is the same shape as the tree we're navigating\n  // to. But even though this is a \"new\" tree, some of the individual segments\n  // may be cached as a result of other route prefetches.\n  //\n  // So we need to find the first uncached segment along each path add an\n  // explicit \"refetch\" marker so the server knows where to start rendering.\n  // Once the server starts rendering along a path, it keeps rendering the\n  // entire subtree.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy,\n    tree\n  )\n\n  let spawnedSegment: PendingSegmentCacheEntry | null = null\n\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached.\n      if (fetchStrategy === FetchStrategy.Full) {\n        // Check if there's a matching entry in the bfcache. If so, fulfill the\n        // segment using the bfcache entry instead of issuing a new request.\n        const fulfilled = attemptToFulfillDynamicSegmentFromBFCache(\n          now,\n          segment,\n          tree\n        )\n        if (fulfilled !== null) {\n          break\n        }\n      }\n      // Include it in the request.\n      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      if (\n        segment.isPartial &&\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n        // This means we're in one of these cases:\n        //   - we have a static prefetch, and we're doing a runtime prefetch\n        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n        // In either case, we need to include it in the request to get a more specific (or full) version.\n        spawnedSegment = pingFullSegmentRevalidation(now, tree, fetchStrategy)\n      }\n      break\n    }\n    case EntryStatus.Pending:\n    case EntryStatus.Rejected: {\n      // There's either another prefetch currently in progress, or the previous\n      // attempt failed. If the new strategy can provide more content, fetch it again.\n      if (\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        spawnedSegment = pingFullSegmentRevalidation(now, tree, fetchStrategy)\n      }\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingRouteTreeAndIncludeDynamicData(\n          now,\n          task,\n          route,\n          childTree,\n          isInsideRefetchingParent || spawnedSegment !== null,\n          spawnedEntries,\n          fetchStrategy\n        )\n    }\n  }\n\n  if (spawnedSegment !== null) {\n    // Add the pending entry to the result map.\n    spawnedEntries.set(tree.requestKey, spawnedSegment)\n  }\n\n  // Don't bother to add a refetch marker if one is already present in a parent.\n  const refetchMarker =\n    !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null\n\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRuntimePrefetches(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  spawnedRuntimePrefetches: Set<SegmentRequestKey>,\n  spawnedEntries: Map<SegmentRequestKey, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n  // a segment is part of the runtime prefetch, the tree is constructed by\n  // diffing against what's already in the prefetch cache. Otherwise, we send\n  // a regular FlightRouterState with no special markers.\n  //\n  // See pingRouteTreeAndIncludeDynamicData for details.\n  if (spawnedRuntimePrefetches.has(tree.requestKey)) {\n    // This segment needs a runtime prefetch.\n    return pingRouteTreeAndIncludeDynamicData(\n      now,\n      task,\n      route,\n      tree,\n      false,\n      spawnedEntries,\n      FetchStrategy.PPRRuntime\n    )\n  }\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(\n        now,\n        task,\n        route,\n        childTree,\n        spawnedRuntimePrefetches,\n        spawnedEntries\n      )\n    }\n  }\n\n  // This segment is not part of the runtime prefetch. Clone the base tree.\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    null,\n  ]\n  return requestTree\n}\n\nfunction pingStaticSegmentData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  segment: SegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  switch (segment.status) {\n    case EntryStatus.Empty:\n      // Upgrade to Pending so we know there's already a request in progress\n      spawnPrefetchSubtask(\n        fetchSegmentOnCacheMiss(\n          route,\n          upgradeToPendingSegment(segment, FetchStrategy.PPR),\n          routeKey,\n          tree\n        )\n      )\n      break\n    case EntryStatus.Pending: {\n      // There's already a request in progress. Depending on what kind of\n      // request it is, we may want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // There's already a request in progress. Don't do anything.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a pending request, but because it's using the old\n          // prefetching strategy, we can't be sure if it will be fulfilled by\n          // the response — it might be inside the loading boundary. Perform\n          // a revalidation, but because it's speculative, wait to do it at\n          // background priority.\n          if (background(task)) {\n            // TODO: Instead of speculatively revalidating, consider including\n            // `hasLoading` in the route tree prefetch response.\n            pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          }\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The existing entry in the cache was rejected. Depending on how it\n      // was originally fetched, we may or may not want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // The previous attempt to fetch this entry failed. Don't attempt to\n          // fetch it again until the entry expires.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a rejected entry, but it was fetched using the loading\n          // boundary strategy. So the reason it wasn't returned by the server\n          // might just be because it was inside a loading boundary. Or because\n          // there was a dynamic rewrite. Revalidate it using the per-\n          // segment strategy.\n          //\n          // Because a rejected segment will definitely prevent the segment (and\n          // all of its children) from rendering, we perform this revalidation\n          // immediately instead of deferring it to a background task.\n          pingPPRSegmentRevalidation(now, route, routeKey, tree)\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Fulfilled:\n      // Segment is already cached. There's nothing left to prefetch.\n      break\n    default:\n      segment satisfies never\n  }\n\n  // Segments do not have dependent tasks, so once the prefetch is initiated,\n  // there's nothing else for us to do (except write the server data into the\n  // entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\n\nfunction pingPPRSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    FetchStrategy.PPR,\n    tree\n  )\n  switch (revalidatingSegment.status) {\n    case EntryStatus.Empty:\n      // Spawn a prefetch request and upsert the segment into the cache\n      // upon completion.\n      upsertSegmentOnCompletion(\n        spawnPrefetchSubtask(\n          fetchSegmentOnCacheMiss(\n            route,\n            upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n            routeKey,\n            tree\n          )\n        ),\n        getSegmentVaryPathForRequest(FetchStrategy.PPR, tree)\n      )\n      break\n    case EntryStatus.Pending:\n      // There's already a revalidation in progress.\n      break\n    case EntryStatus.Fulfilled:\n    case EntryStatus.Rejected:\n      // A previous revalidation attempt finished, but we chose not to replace\n      // the existing entry in the cache. Don't try again until or unless the\n      // revalidation entry expires.\n      break\n    default:\n      revalidatingSegment satisfies never\n  }\n}\n\nfunction pingFullSegmentRevalidation(\n  now: number,\n  tree: RouteTree,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): PendingSegmentCacheEntry | null {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    fetchStrategy,\n    tree\n  )\n  if (revalidatingSegment.status === EntryStatus.Empty) {\n    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n    // segments that we need. So we don't initiate a request here directly. By\n    // returning a pending entry from this function, it signals to the caller\n    // that this segment should be included in the request that's sent to\n    // the server.\n    const pendingSegment = upgradeToPendingSegment(\n      revalidatingSegment,\n      fetchStrategy\n    )\n    upsertSegmentOnCompletion(\n      waitForSegmentCacheEntry(pendingSegment),\n      getSegmentVaryPathForRequest(fetchStrategy, tree)\n    )\n    return pendingSegment\n  } else {\n    // There's already a revalidation in progress.\n    const nonEmptyRevalidatingSegment = revalidatingSegment\n    if (\n      canNewFetchStrategyProvideMoreContent(\n        nonEmptyRevalidatingSegment.fetchStrategy,\n        fetchStrategy\n      )\n    ) {\n      // The existing revalidation was fetched using a less specific strategy.\n      // Reset it and start a new revalidation.\n      const emptySegment = overwriteRevalidatingSegmentCacheEntry(\n        now,\n        fetchStrategy,\n        tree\n      )\n      const pendingSegment = upgradeToPendingSegment(\n        emptySegment,\n        fetchStrategy\n      )\n      upsertSegmentOnCompletion(\n        waitForSegmentCacheEntry(pendingSegment),\n        getSegmentVaryPathForRequest(fetchStrategy, tree)\n      )\n      return pendingSegment\n    }\n    switch (nonEmptyRevalidatingSegment.status) {\n      case EntryStatus.Pending:\n        // There's already an in-progress prefetch that includes this segment.\n        return null\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected:\n        // A previous revalidation attempt finished, but we chose not to replace\n        // the existing entry in the cache. Don't try again until or unless the\n        // revalidation entry expires.\n        return null\n      default:\n        nonEmptyRevalidatingSegment satisfies never\n        return null\n    }\n  }\n}\n\nconst noop = () => {}\n\nfunction upsertSegmentOnCompletion(\n  promise: Promise<FulfilledSegmentCacheEntry | null>,\n  varyPath: SegmentVaryPath\n) {\n  // Wait for a segment to finish loading, then upsert it into the cache\n  promise.then((fulfilled) => {\n    if (fulfilled !== null) {\n      // Received new data. Attempt to replace the existing entry in the cache.\n      upsertSegmentEntry(Date.now(), varyPath, fulfilled)\n    }\n  }, noop)\n}\n\nfunction doesCurrentSegmentMatchCachedSegment(\n  route: FulfilledRouteCacheEntry,\n  currentSegment: Segment,\n  cachedSegment: Segment\n): boolean {\n  if (cachedSegment === PAGE_SEGMENT_KEY) {\n    // In the FlightRouterState stored by the router, the page segment has the\n    // rendered search params appended to the name of the segment. In the\n    // prefetch cache, however, this is stored separately. So, when comparing\n    // the router's current FlightRouterState to the cached FlightRouterState,\n    // we need to make sure we compare both parts of the segment.\n    // TODO: This is not modeled clearly. We use the same type,\n    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n    // _and_ the server response format, when conceptually those are three\n    // different things and treated in different ways. We should encode more of\n    // this information into the type design so mistakes are less likely.\n    return (\n      currentSegment ===\n      addSearchParamsIfPageSegment(\n        PAGE_SEGMENT_KEY,\n        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n      )\n    )\n  }\n  // Non-page segments are compared using the same function as the server\n  return matchSegment(cachedSegment, currentSegment)\n}\n\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\n\nfunction compareQueuePriority(a: PrefetchTask, b: PrefetchTask) {\n  // Since the queue is a MinHeap, this should return a positive number if b is\n  // higher priority than a, and a negative number if a is higher priority\n  // than b.\n\n  // `priority` is an integer, where higher numbers are higher priority.\n  const priorityDiff = b.priority - a.priority\n  if (priorityDiff !== 0) {\n    return priorityDiff\n  }\n\n  // If the priority is the same, check which phase the prefetch is in — is it\n  // prefetching the route tree, or the segments? Route trees are prioritized.\n  const phaseDiff = b.phase - a.phase\n  if (phaseDiff !== 0) {\n    return phaseDiff\n  }\n\n  // Finally, check the insertion order. `sortId` is an incrementing counter\n  // assigned to prefetches. We want to process the newest prefetches first.\n  return b.sortId - a.sortId\n}\n\nfunction heapPush(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = heap.length\n  heap.push(node)\n  node._heapIndex = index\n  heapSiftUp(heap, node, index)\n}\n\nfunction heapPeek(heap: Array<PrefetchTask>): PrefetchTask | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\nfunction heapPop(heap: Array<PrefetchTask>): PrefetchTask | null {\n  if (heap.length === 0) {\n    return null\n  }\n  const first = heap[0]\n  first._heapIndex = -1\n  const last = heap.pop() as PrefetchTask\n  if (last !== first) {\n    heap[0] = last\n    last._heapIndex = 0\n    heapSiftDown(heap, last, 0)\n  }\n  return first\n}\n\nfunction heapDelete(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    node._heapIndex = -1\n    if (heap.length !== 0) {\n      const last = heap.pop() as PrefetchTask\n      if (last !== node) {\n        heap[index] = last\n        last._heapIndex = index\n        heapSiftDown(heap, last, index)\n      }\n    }\n  }\n}\n\nfunction heapResift(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    if (index === 0) {\n      heapSiftDown(heap, node, 0)\n    } else {\n      const parentIndex = (index - 1) >>> 1\n      const parent = heap[parentIndex]\n      if (compareQueuePriority(parent, node) > 0) {\n        // The parent is larger. Sift up.\n        heapSiftUp(heap, node, index)\n      } else {\n        // The parent is smaller (or equal). Sift down.\n        heapSiftDown(heap, node, index)\n      }\n    }\n  }\n}\n\nfunction heapSiftUp(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n    if (compareQueuePriority(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      node._heapIndex = parentIndex\n      heap[index] = parent\n      parent._heapIndex = index\n\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\nfunction heapSiftDown(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  const length = heap.length\n  const halfLength = length >>> 1\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compareQueuePriority(left, node) < 0) {\n      if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n        heap[index] = right\n        right._heapIndex = index\n        heap[rightIndex] = node\n        node._heapIndex = rightIndex\n\n        index = rightIndex\n      } else {\n        heap[index] = left\n        left._heapIndex = index\n        heap[leftIndex] = node\n        node._heapIndex = leftIndex\n\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n      heap[index] = right\n      right._heapIndex = index\n      heap[rightIndex] = node\n      node._heapIndex = rightIndex\n\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n","import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  PrefetchPriority,\n} from './segment-cache/types'\nimport { createCacheKey } from './segment-cache/cache-key'\nimport {\n  type PrefetchTask,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n  isPrefetchTaskDirty,\n} from './segment-cache/scheduler'\nimport { startTransition } from 'react'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Checks if a given path starts with a given prefix. It ensures it matches\n * exactly without containing extra chars. e.g. prefix /docs should replace\n * for /docs, /docs/, /docs/a but not /docsss\n * @param path The path to check.\n * @param prefix The prefix to check against.\n */\nexport function pathHasPrefix(path: string, prefix: string) {\n  if (typeof path !== 'string') {\n    return false\n  }\n\n  const { pathname } = parsePath(path)\n  return pathname === prefix || pathname.startsWith(prefix + '/')\n}\n","import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n","import { isAbsoluteUrl, getLocationOrigin } from '../../utils'\nimport { hasBasePath } from '../../../../client/has-base-path'\n\n/**\n * Detects whether a given url is routable by the Next.js router (browser only).\n */\nexport function isLocalURL(url: string): boolean {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (!isAbsoluteUrl(url)) return true\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = getLocationOrigin()\n    const resolved = new URL(url, locationOrigin)\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname)\n  } catch (_) {\n    return false\n  }\n}\n","let errorOnce = (_: string) => {}\nif (process.env.NODE_ENV !== 'production') {\n  const errors = new Set<string>()\n  errorOnce = (msg: string) => {\n    if (!errors.has(msg)) {\n      console.error(msg)\n    }\n    errors.add(msg)\n  }\n}\n\nexport { errorOnce }\n","'use client'\n\nimport React, { createContext, useContext, useOptimistic, useRef } from 'react'\nimport type { UrlObject } from 'url'\nimport { formatUrl } from '../../shared/lib/router/utils/format-url'\nimport { AppRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useMergedRef } from '../use-merged-ref'\nimport { isAbsoluteUrl } from '../../shared/lib/utils'\nimport { addBasePath } from '../add-base-path'\nimport { warnOnce } from '../../shared/lib/utils/warn-once'\nimport type { PENDING_LINK_STATUS } from '../components/links'\nimport {\n  IDLE_LINK_STATUS,\n  mountLinkInstance,\n  onNavigationIntent,\n  unmountLinkForCurrentNavigation,\n  unmountPrefetchableInstance,\n  type LinkInstance,\n} from '../components/links'\nimport { isLocalURL } from '../../shared/lib/router/utils/is-local-url'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from '../components/segment-cache/types'\nimport { errorOnce } from '../../shared/lib/utils/error-once'\n\ntype Url = string | UrlObject\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never\n}[keyof T]\n\ntype OnNavigateEventHandler = (event: { preventDefault: () => void }) => void\n\ntype InternalLinkProps = {\n  /**\n   * **Required**. The path or URL to navigate to. It can also be an object (similar to `URL`).\n   *\n   * @example\n   * ```tsx\n   * // Navigate to /dashboard:\n   * <Link href=\"/dashboard\">Dashboard</Link>\n   *\n   * // Navigate to /about?name=test:\n   * <Link href={{ pathname: '/about', query: { name: 'test' } }}>\n   *   About\n   * </Link>\n   * ```\n   *\n   * @remarks\n   * - For external URLs, use a fully qualified URL such as `https://...`.\n   * - In the App Router, dynamic routes must not include bracketed segments in `href`.\n   */\n  href: Url\n\n  /**\n   * @deprecated v10.0.0: `href` props pointing to a dynamic route are\n   * automatically resolved and no longer require the `as` prop.\n   */\n  as?: Url\n\n  /**\n   * Replace the current `history` state instead of adding a new URL into the stack.\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/about\" replace>\n   *   About (replaces the history state)\n   * </Link>\n   * ```\n   */\n  replace?: boolean\n\n  /**\n   * Whether to override the default scroll behavior. If `true`, Next.js attempts to maintain\n   * the scroll position if the newly navigated page is still visible. If not, it scrolls to the top.\n   *\n   * If `false`, Next.js will not modify the scroll behavior at all.\n   *\n   * @defaultValue `true`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" scroll={false}>\n   *   No auto scroll\n   * </Link>\n   * ```\n   */\n  scroll?: boolean\n\n  /**\n   * Update the path of the current page without rerunning data fetching methods\n   * like `getStaticProps`, `getServerSideProps`, or `getInitialProps`.\n   *\n   * @remarks\n   * `shallow` only applies to the Pages Router. For the App Router, see the\n   * [following documentation](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#using-the-native-history-api).\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/blog\" shallow>\n   *   Shallow navigation\n   * </Link>\n   * ```\n   */\n  shallow?: boolean\n\n  /**\n   * Forces `Link` to pass its `href` to the child component. Useful if the child is a custom\n   * component that wraps an `<a>` tag, or if you're using certain styling libraries.\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" passHref legacyBehavior>\n   *   <MyStyledAnchor>Dashboard</MyStyledAnchor>\n   * </Link>\n   * ```\n   */\n  passHref?: boolean\n\n  /**\n   * Prefetch the page in the background.\n   * Any `<Link />` that is in the viewport (initially or through scroll) will be prefetched.\n   * Prefetch can be disabled by passing `prefetch={false}`.\n   *\n   * @remarks\n   * Prefetching is only enabled in production.\n   *\n   * - In the **App Router**:\n   *   - `\"auto\"`, `null`, `undefined` (default): Prefetch behavior depends on static vs dynamic routes:\n   *     - Static routes: fully prefetched\n   *     - Dynamic routes: partial prefetch to the nearest segment with a `loading.js`\n   *   - `true`: Always prefetch the full route and data.\n   *   - `false`: Disable prefetching on both viewport and hover.\n   * - In the **Pages Router**:\n   *   - `true` (default): Prefetches the route and data in the background on viewport or hover.\n   *   - `false`: Prefetch only on hover, not on viewport.\n   *\n   * @defaultValue `true` (Pages Router) or `null` (App Router)\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" prefetch={false}>\n   *   Dashboard\n   * </Link>\n   * ```\n   */\n  prefetch?: boolean | 'auto' | null\n\n  /**\n   * (unstable) Switch to a full prefetch on hover. Effectively the same as\n   * updating the prefetch prop to `true` in a mouse event.\n   */\n  unstable_dynamicOnHover?: boolean\n\n  /**\n   * The active locale is automatically prepended in the Pages Router. `locale` allows for providing\n   * a different locale, or can be set to `false` to opt out of automatic locale behavior.\n   *\n   * @remarks\n   * Note: locale only applies in the Pages Router and is ignored in the App Router.\n   *\n   * @example\n   * ```tsx\n   * // Use the 'fr' locale:\n   * <Link href=\"/about\" locale=\"fr\">\n   *   About (French)\n   * </Link>\n   *\n   * // Disable locale prefix:\n   * <Link href=\"/about\" locale={false}>\n   *   About (no locale prefix)\n   * </Link>\n   * ```\n   */\n  locale?: string | false\n\n  /**\n   * Enable legacy link behavior.\n   *\n   * @deprecated This will be removed in a future version\n   * @defaultValue `false`\n   * @see https://github.com/vercel/next.js/commit/489e65ed98544e69b0afd7e0cfc3f9f6c2b803b7\n   */\n  legacyBehavior?: boolean\n\n  /**\n   * Optional event handler for when the mouse pointer is moved onto the `<Link>`.\n   */\n  onMouseEnter?: React.MouseEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is touched.\n   */\n  onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is clicked.\n   */\n  onClick?: React.MouseEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is navigated.\n   */\n  onNavigate?: OnNavigateEventHandler\n}\n\n// TODO-APP: Include the full set of Anchor props\n// adding this to the publicly exported type currently breaks existing apps\n\n// `RouteInferType` is a stub here to avoid breaking `typedRoutes` when the type\n// isn't generated yet. It will be replaced when type generation runs.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type LinkProps<RouteInferType = any> = InternalLinkProps\ntype LinkPropsRequired = RequiredKeys<LinkProps>\ntype LinkPropsOptional = OptionalKeys<Omit<InternalLinkProps, 'locale'>>\n\nfunction isModifiedEvent(event: React.MouseEvent): boolean {\n  const eventTarget = event.currentTarget as HTMLAnchorElement | SVGAElement\n  const target = eventTarget.getAttribute('target')\n  return (\n    (target && target !== '_self') ||\n    event.metaKey ||\n    event.ctrlKey ||\n    event.shiftKey ||\n    event.altKey || // triggers resource download\n    (event.nativeEvent && event.nativeEvent.which === 2)\n  )\n}\n\nfunction linkClicked(\n  e: React.MouseEvent,\n  href: string,\n  linkInstanceRef: React.RefObject<LinkInstance | null>,\n  replace?: boolean,\n  scroll?: boolean,\n  onNavigate?: OnNavigateEventHandler\n): void {\n  if (typeof window !== 'undefined') {\n    const { nodeName } = e.currentTarget\n\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A'\n    if (\n      (isAnchorNodeName && isModifiedEvent(e)) ||\n      e.currentTarget.hasAttribute('download')\n    ) {\n      // ignore click for browser’s default behavior\n      return\n    }\n\n    if (!isLocalURL(href)) {\n      if (replace) {\n        // browser default behavior does not replace the history state\n        // so we need to do it manually\n        e.preventDefault()\n        location.replace(href)\n      }\n\n      // ignore click for browser’s default behavior\n      return\n    }\n\n    e.preventDefault()\n\n    if (onNavigate) {\n      let isDefaultPrevented = false\n\n      onNavigate({\n        preventDefault: () => {\n          isDefaultPrevented = true\n        },\n      })\n\n      if (isDefaultPrevented) {\n        return\n      }\n    }\n\n    const { dispatchNavigateAction } =\n      require('../components/app-router-instance') as typeof import('../components/app-router-instance')\n\n    React.startTransition(() => {\n      dispatchNavigateAction(\n        href,\n        replace ? 'replace' : 'push',\n        scroll ?? true,\n        linkInstanceRef.current\n      )\n    })\n  }\n}\n\nfunction formatStringOrUrl(urlObjOrString: UrlObject | string): string {\n  if (typeof urlObjOrString === 'string') {\n    return urlObjOrString\n  }\n\n  return formatUrl(urlObjOrString)\n}\n\n/**\n * A React component that extends the HTML `<a>` element to provide\n * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation. This is the primary way to navigate between routes in Next.js.\n *\n * @remarks\n * - Prefetching is only enabled in production.\n *\n * @see https://nextjs.org/docs/app/api-reference/components/link\n */\nexport default function LinkComponent(\n  props: LinkProps & {\n    children: React.ReactNode\n    ref: React.Ref<HTMLAnchorElement>\n  }\n) {\n  const [linkStatus, setOptimisticLinkStatus] = useOptimistic(IDLE_LINK_STATUS)\n\n  let children: React.ReactNode\n\n  const linkInstanceRef = useRef<LinkInstance | null>(null)\n\n  const {\n    href: hrefProp,\n    as: asProp,\n    children: childrenProp,\n    prefetch: prefetchProp = null,\n    passHref,\n    replace,\n    shallow,\n    scroll,\n    onClick,\n    onMouseEnter: onMouseEnterProp,\n    onTouchStart: onTouchStartProp,\n    legacyBehavior = false,\n    onNavigate,\n    ref: forwardedRef,\n    unstable_dynamicOnHover,\n    ...restProps\n  } = props\n\n  children = childrenProp\n\n  if (\n    legacyBehavior &&\n    (typeof children === 'string' || typeof children === 'number')\n  ) {\n    children = <a>{children}</a>\n  }\n\n  const router = React.useContext(AppRouterContext)\n\n  const prefetchEnabled = prefetchProp !== false\n\n  const fetchStrategy =\n    prefetchProp !== false\n      ? getFetchStrategyFromPrefetchProp(prefetchProp)\n      : // TODO: it makes no sense to assign a fetchStrategy when prefetching is disabled.\n        FetchStrategy.PPR\n\n  if (process.env.NODE_ENV !== 'production') {\n    function createPropError(args: {\n      key: string\n      expected: string\n      actual: string\n    }) {\n      return new Error(\n        `Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` +\n          (typeof window !== 'undefined'\n            ? \"\\nOpen your browser's console to view the Component stack trace.\"\n            : '')\n      )\n    }\n\n    // TypeScript trick for type-guarding:\n    const requiredPropsGuard: Record<LinkPropsRequired, true> = {\n      href: true,\n    } as const\n    const requiredProps: LinkPropsRequired[] = Object.keys(\n      requiredPropsGuard\n    ) as LinkPropsRequired[]\n    requiredProps.forEach((key: LinkPropsRequired) => {\n      if (key === 'href') {\n        if (\n          props[key] == null ||\n          (typeof props[key] !== 'string' && typeof props[key] !== 'object')\n        ) {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: props[key] === null ? 'null' : typeof props[key],\n          })\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        const _: never = key\n      }\n    })\n\n    // TypeScript trick for type-guarding:\n    const optionalPropsGuard: Record<LinkPropsOptional, true> = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      unstable_dynamicOnHover: true,\n      onClick: true,\n      onMouseEnter: true,\n      onTouchStart: true,\n      legacyBehavior: true,\n      onNavigate: true,\n    } as const\n    const optionalProps: LinkPropsOptional[] = Object.keys(\n      optionalPropsGuard\n    ) as LinkPropsOptional[]\n    optionalProps.forEach((key: LinkPropsOptional) => {\n      const valType = typeof props[key]\n\n      if (key === 'as') {\n        if (props[key] && valType !== 'string' && valType !== 'object') {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: valType,\n          })\n        }\n      } else if (\n        key === 'onClick' ||\n        key === 'onMouseEnter' ||\n        key === 'onTouchStart' ||\n        key === 'onNavigate'\n      ) {\n        if (props[key] && valType !== 'function') {\n          throw createPropError({\n            key,\n            expected: '`function`',\n            actual: valType,\n          })\n        }\n      } else if (\n        key === 'replace' ||\n        key === 'scroll' ||\n        key === 'shallow' ||\n        key === 'passHref' ||\n        key === 'legacyBehavior' ||\n        key === 'unstable_dynamicOnHover'\n      ) {\n        if (props[key] != null && valType !== 'boolean') {\n          throw createPropError({\n            key,\n            expected: '`boolean`',\n            actual: valType,\n          })\n        }\n      } else if (key === 'prefetch') {\n        if (\n          props[key] != null &&\n          valType !== 'boolean' &&\n          props[key] !== 'auto'\n        ) {\n          throw createPropError({\n            key,\n            expected: '`boolean | \"auto\"`',\n            actual: valType,\n          })\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        const _: never = key\n      }\n    })\n  }\n\n  const resolvedHref = asProp || hrefProp\n  const formattedHref = formatStringOrUrl(resolvedHref)\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (props.locale) {\n      warnOnce(\n        'The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization'\n      )\n    }\n    if (!asProp) {\n      let href: string | undefined\n      if (typeof resolvedHref === 'string') {\n        href = resolvedHref\n      } else if (\n        typeof resolvedHref === 'object' &&\n        typeof resolvedHref.pathname === 'string'\n      ) {\n        href = resolvedHref.pathname\n      }\n\n      if (href) {\n        const hasDynamicSegment = href\n          .split('/')\n          .some((segment) => segment.startsWith('[') && segment.endsWith(']'))\n\n        if (hasDynamicSegment) {\n          throw new Error(\n            `Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`\n          )\n        }\n      }\n    }\n  }\n\n  // This will return the first child, if multiple are provided it will throw an error\n  let child: any\n  if (legacyBehavior) {\n    if ((children as any)?.$$typeof === Symbol.for('react.lazy')) {\n      throw new Error(\n        `\\`<Link legacyBehavior>\\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \\`<a>\\` tag.`\n      )\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      if (onClick) {\n        console.warn(\n          `\"onClick\" was passed to <Link> with \\`href\\` of \\`${formattedHref}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`\n        )\n      }\n      if (onMouseEnterProp) {\n        console.warn(\n          `\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${formattedHref}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`\n        )\n      }\n      try {\n        child = React.Children.only(children)\n      } catch (err) {\n        if (!children) {\n          throw new Error(\n            `No children were passed to <Link> with \\`href\\` of \\`${formattedHref}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`\n          )\n        }\n        throw new Error(\n          `Multiple children were passed to <Link> with \\`href\\` of \\`${formattedHref}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` +\n            (typeof window !== 'undefined'\n              ? \" \\nOpen your browser's console to view the Component stack trace.\"\n              : '')\n        )\n      }\n    } else {\n      child = React.Children.only(children)\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if ((children as any)?.type === 'a') {\n        throw new Error(\n          'Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'\n        )\n      }\n    }\n  }\n\n  const childRef: any = legacyBehavior\n    ? child && typeof child === 'object' && child.ref\n    : forwardedRef\n\n  // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n  // mount. In the future we will also use this to keep track of all the\n  // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n  // a revalidation or refresh.\n  const observeLinkVisibilityOnMount = React.useCallback(\n    (element: HTMLAnchorElement | SVGAElement) => {\n      if (router !== null) {\n        linkInstanceRef.current = mountLinkInstance(\n          element,\n          formattedHref,\n          router,\n          fetchStrategy,\n          prefetchEnabled,\n          setOptimisticLinkStatus\n        )\n      }\n\n      return () => {\n        if (linkInstanceRef.current) {\n          unmountLinkForCurrentNavigation(linkInstanceRef.current)\n          linkInstanceRef.current = null\n        }\n        unmountPrefetchableInstance(element)\n      }\n    },\n    [\n      prefetchEnabled,\n      formattedHref,\n      router,\n      fetchStrategy,\n      setOptimisticLinkStatus,\n    ]\n  )\n\n  const mergedRef = useMergedRef(observeLinkVisibilityOnMount, childRef)\n\n  const childProps: {\n    onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n    onMouseEnter: React.MouseEventHandler<HTMLAnchorElement>\n    onClick: React.MouseEventHandler<HTMLAnchorElement>\n    href?: string\n    ref?: any\n  } = {\n    ref: mergedRef,\n    onClick(e) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!e) {\n          throw new Error(\n            `Component rendered inside next/link has to pass click event to \"onClick\" prop.`\n          )\n        }\n      }\n\n      if (!legacyBehavior && typeof onClick === 'function') {\n        onClick(e)\n      }\n\n      if (\n        legacyBehavior &&\n        child.props &&\n        typeof child.props.onClick === 'function'\n      ) {\n        child.props.onClick(e)\n      }\n\n      if (!router) {\n        return\n      }\n      if (e.defaultPrevented) {\n        return\n      }\n      linkClicked(\n        e,\n        formattedHref,\n        linkInstanceRef,\n        replace,\n        scroll,\n        onNavigate\n      )\n    },\n    onMouseEnter(e) {\n      if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n        onMouseEnterProp(e)\n      }\n\n      if (\n        legacyBehavior &&\n        child.props &&\n        typeof child.props.onMouseEnter === 'function'\n      ) {\n        child.props.onMouseEnter(e)\n      }\n\n      if (!router) {\n        return\n      }\n      if (!prefetchEnabled || process.env.NODE_ENV === 'development') {\n        return\n      }\n\n      const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true\n      onNavigationIntent(\n        e.currentTarget as HTMLAnchorElement | SVGAElement,\n        upgradeToDynamicPrefetch\n      )\n    },\n    onTouchStart: process.env.__NEXT_LINK_NO_TOUCH_START\n      ? undefined\n      : function onTouchStart(e) {\n          if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n            onTouchStartProp(e)\n          }\n\n          if (\n            legacyBehavior &&\n            child.props &&\n            typeof child.props.onTouchStart === 'function'\n          ) {\n            child.props.onTouchStart(e)\n          }\n\n          if (!router) {\n            return\n          }\n          if (!prefetchEnabled) {\n            return\n          }\n\n          const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true\n          onNavigationIntent(\n            e.currentTarget as HTMLAnchorElement | SVGAElement,\n            upgradeToDynamicPrefetch\n          )\n        },\n  }\n\n  // If the url is absolute, we can bypass the logic to prepend the basePath.\n  if (isAbsoluteUrl(formattedHref)) {\n    childProps.href = formattedHref\n  } else if (\n    !legacyBehavior ||\n    passHref ||\n    (child.type === 'a' && !('href' in child.props))\n  ) {\n    childProps.href = addBasePath(formattedHref)\n  }\n\n  let link: React.ReactNode\n\n  if (legacyBehavior) {\n    if (process.env.NODE_ENV === 'development') {\n      errorOnce(\n        '`legacyBehavior` is deprecated and will be removed in a future ' +\n          'release. A codemod is available to upgrade your components:\\n\\n' +\n          'npx @next/codemod@latest new-link .\\n\\n' +\n          'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components'\n      )\n    }\n    link = React.cloneElement(child, childProps)\n  } else {\n    link = (\n      <a {...restProps} {...childProps}>\n        {children}\n      </a>\n    )\n  }\n\n  return (\n    <LinkStatusContext.Provider value={linkStatus}>\n      {link}\n    </LinkStatusContext.Provider>\n  )\n}\n\nconst LinkStatusContext = createContext<\n  typeof PENDING_LINK_STATUS | typeof IDLE_LINK_STATUS\n>(IDLE_LINK_STATUS)\n\nexport const useLinkStatus = () => {\n  return useContext(LinkStatusContext)\n}\n\nfunction getFetchStrategyFromPrefetchProp(\n  prefetchProp: Exclude<LinkProps['prefetch'], undefined | false>\n): PrefetchTaskFetchStrategy {\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    if (prefetchProp === true) {\n      return FetchStrategy.Full\n    }\n\n    // `null` or `\"auto\"`: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport.\n    // This will also include invalid prop values that don't match the types specified here.\n    // (although those should've been filtered out by prop validation in dev)\n    prefetchProp satisfies null | 'auto'\n    return FetchStrategy.PPR\n  } else {\n    return prefetchProp === null || prefetchProp === 'auto'\n      ? // We default to PPR, and we'll discover whether or not the route supports it with the initial prefetch.\n        FetchStrategy.PPR\n      : // In the old implementation without runtime prefetches, `prefetch={true}` forces all dynamic data to be prefetched.\n        // To preserve backwards-compatibility, anything other than `false`, `null`, or `\"auto\"` results in a full prefetch.\n        // (although invalid values should've been filtered out by prop validation in dev)\n        FetchStrategy.Full\n  }\n}\n","\"use client\";\r\n\r\nimport React, { useState, useEffect } from 'react';\r\nimport { supabase } from '@/lib/supabase';\r\nimport PortalEntry from '@/components/PortalEntry';\r\nimport Layout from '@/components/Layout';\r\n\r\nexport default function PortalLayout({\r\n    children,\r\n}: {\r\n    children: React.ReactNode;\r\n}) {\r\n    const [hasEntered, setHasEntered] = useState(false);\r\n    const [session, setSession] = useState<any>(null);\r\n    const [loading, setLoading] = useState(true);\r\n\r\n    useEffect(() => {\r\n        const checkSession = async () => {\r\n            const { data: { session: activeSession } } = await supabase.auth.getSession();\r\n            setSession(activeSession);\r\n            setLoading(false);\r\n        };\r\n\r\n        checkSession();\r\n\r\n        const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {\r\n            setSession(session);\r\n        });\r\n\r\n        return () => subscription.unsubscribe();\r\n    }, []);\r\n\r\n    if (loading) {\r\n        return <div className=\"h-screen w-full bg-background flex items-center justify-center\">\r\n            <div className=\"animate-pulse text-pacific-500 font-mono text-sm uppercase tracking-widest\">Initializing...</div>\r\n        </div>;\r\n    }\r\n\r\n    // If not logged in, PortalEntry will handle the login UI.\r\n    // We don't render children yet to prevent unauthorized data fetching attempts.\r\n    if (!session) {\r\n        return <PortalEntry onEnter={() => { }} />; // PortalEntry shows login UI when no session\r\n    }\r\n\r\n    // If logged in but hasn't finished the animation\r\n    return (\r\n        <div className=\"relative h-screen w-full overflow-hidden\">\r\n            {/* \r\n        PRE-LOADING STRATEGY: \r\n        Children are rendered immediately so they can start fetching data.\r\n        PortalEntry is rendered OVER them (z-index 50) and handles the split-door animation.\r\n      */}\r\n            <Layout>\r\n                {children}\r\n            </Layout>\r\n\r\n            {!hasEntered && (\r\n                <PortalEntry onEnter={() => setHasEntered(true)} />\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n","\"use client\";\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport {\n  LayoutDashboard,\n  Target,\n  TrendingUp,\n  Library,\n  Film,\n  Settings,\n  Moon,\n  Sun,\n  Database,\n  ChevronLeft,\n  PanelLeft,\n  Timer,\n  User\n} from 'lucide-react';\nimport Link from 'next/link';\nimport { usePathname } from 'next/navigation';\nimport { useTheme } from '@/contexts/ThemeContext';\nimport { TempoSettingsModal } from './TempoSettingsModal';\nimport { AccountSettingsModal } from './AccountSettingsModal';\n\ninterface LayoutProps {\n  children: React.ReactNode;\n}\n\nconst NavItem: React.FC<{\n  icon: React.ReactNode;\n  label: string;\n  href: string;\n  active: boolean;\n  collapsed: boolean;\n}> = ({ icon, label, href, active, collapsed }) => (\n  <Link\n    href={href}\n    title={collapsed ? label : undefined}\n    className={`group flex items-center rounded-xl py-3 text-sm font-semibold transition-all duration-300 border border-transparent relative overflow-hidden ${active\n      ? 'bg-graphite-100 dark:bg-white/5 text-pacific-700 dark:text-pacific-400 border-pacific-200/50 dark:border-pacific-500/10'\n      : 'text-graphite-500 hover:bg-graphite-50 hover:text-graphite-900 dark:text-graphite-400 dark:hover:bg-white/5 dark:hover:text-graphite-200'\n      } ${collapsed ? 'w-full justify-center px-2 gap-0' : 'w-full px-4 gap-3'}`}\n  >\n    {active && <div className={`absolute top-0 bottom-0 w-1 bg-pacific-500 rounded-r-full transition-all duration-300 ${collapsed ? 'left-0 h-full rounded-none' : 'left-0'}`}></div>}\n    <span className={`${active ? 'text-pacific-600 dark:text-pacific-400' : 'text-graphite-400 group-hover:text-pacific-500 dark:group-hover:text-pacific-400 transition-colors'}`}>\n      {icon}\n    </span>\n    <span className={`whitespace-nowrap transition-all duration-300 ${collapsed ? 'w-0 opacity-0 overflow-hidden' : 'w-auto opacity-100'}`}>\n      {label}\n    </span>\n  </Link>\n);\n\nconst Layout: React.FC<LayoutProps> = ({ children }) => {\n  const [isSettingsOpen, setIsSettingsOpen] = useState(false);\n  const [showTempoModal, setShowTempoModal] = useState(false);\n  const [showAccountModal, setShowAccountModal] = useState(false);\n  const settingsRef = useRef<HTMLDivElement>(null);\n  const { theme, toggleTheme } = useTheme();\n\n  const pathname = usePathname();\n  const activePage = pathname.split('/').pop() || 'dashboard';\n\n  // Sidebar State\n  const [isCollapsed, setIsCollapsed] = useState(false);\n\n  useEffect(() => {\n    function handleClickOutside(event: MouseEvent) {\n      if (settingsRef.current && !settingsRef.current.contains(event.target as Node)) {\n        setIsSettingsOpen(false);\n      }\n    }\n    if (isSettingsOpen) document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [isSettingsOpen]);\n\n  const toggleSidebar = () => setIsCollapsed(!isCollapsed);\n\n  return (\n    <div className=\"flex h-screen w-full overflow-hidden bg-background text-graphite-900 dark:text-graphite-50 font-sans transition-colors duration-500 flex-row\">\n\n      {/* Sidebar - Rich Graphite */}\n      <aside className={`${isCollapsed ? 'w-[80px] px-3' : 'w-[280px] px-6'} flex-shrink-0 border-graphite-200 dark:border-graphite-800 bg-white dark:bg-graphite-900 py-6 flex flex-col relative z-20 transition-all duration-300 ease-in-out border-r`}>\n\n        {/* LOGO REDESIGN */}\n        <div className={`mb-10 transition-all duration-300 ${isCollapsed ? 'flex justify-center mt-6' : 'pl-6 mt-8'}`}>\n          {!isCollapsed ? (\n            <div className=\"group flex items-center justify-start select-none cursor-pointer\">\n              {/* P */}\n              <span className=\"font-display text-3xl font-black tracking-tighter text-graphite-900 dark:text-white leading-none mr-[2px]\">P</span>\n\n              {/* THE PORTAL \"O\" */}\n              <div className=\"relative h-7 w-7 mx-[1px] flex-shrink-0 flex items-center justify-center transition-transform duration-500 group-hover:rotate-180\">\n                {/* Ambient Glow */}\n                <div className=\"absolute inset-[-6px] bg-pacific-500/20 blur-lg rounded-full opacity-0 group-hover:opacity-100 transition-opacity duration-500\"></div>\n\n                {/* Outer Ring - Pacific */}\n                <div className=\"absolute inset-0 rounded-full border-[3px] border-transparent border-t-pacific-500 border-l-pacific-400 animate-[spin_3s_linear_infinite]\" style={{ boxShadow: '0 0 10px rgba(14, 165, 233, 0.1)' }}></div>\n\n                {/* Inner Ring - Bali */}\n                <div className=\"absolute inset-[3px] rounded-full border-[2.5px] border-transparent border-b-bali-500 border-r-bali-400 animate-[spin_2s_linear_infinite_reverse]\"></div>\n\n                {/* Center Singularity */}\n                <div className=\"absolute h-1.5 w-1.5 bg-graphite-900 dark:bg-white rounded-full shadow-[0_0_8px_currentColor] animate-pulse\"></div>\n              </div>\n\n              {/* RTAL */}\n              <span className=\"font-display text-3xl font-black tracking-tighter text-graphite-900 dark:text-white leading-none ml-[2px]\">RTAL</span>\n            </div>\n          ) : (\n            /* Collapsed Icon - Just the Portal */\n            <div className=\"relative h-10 w-10 flex items-center justify-center group cursor-pointer\">\n              <div className=\"absolute inset-0 bg-pacific-500/20 blur-lg rounded-full opacity-50 group-hover:opacity-100 transition-opacity\"></div>\n              <div className=\"absolute inset-0 border-[3px] border-pacific-500 border-t-transparent border-l-transparent rounded-full animate-[spin_3s_linear_infinite]\"></div>\n              <div className=\"absolute inset-[5px] border-[2.5px] border-bali-500 border-b-transparent border-r-transparent rounded-full animate-[spin_2s_linear_infinite_reverse]\"></div>\n              <div className=\"absolute h-2 w-2 bg-white rounded-full shadow-[0_0_10px_rgba(255,255,255,0.8)]\"></div>\n            </div>\n          )}\n        </div>\n\n        <nav className=\"space-y-1.5 flex-1\">\n          <NavItem collapsed={isCollapsed} icon={<LayoutDashboard size={20} />} label=\"Dashboard\" active={activePage === 'dashboard'} href=\"/dashboard\" />\n          <NavItem collapsed={isCollapsed} icon={<Target size={20} />} label=\"The Lab\" active={activePage === 'lab'} href=\"/lab\" />\n          <NavItem collapsed={isCollapsed} icon={<TrendingUp size={20} />} label=\"History\" active={activePage === 'history'} href=\"/history\" />\n          <NavItem collapsed={isCollapsed} icon={<Library size={20} />} label=\"Archives\" active={activePage === 'archives'} href=\"/archives\" />\n          <NavItem collapsed={isCollapsed} icon={<Film size={20} />} label=\"Cinema\" active={activePage === 'cinema'} href=\"/cinema\" />\n          <NavItem collapsed={isCollapsed} icon={<Database size={20} />} label=\"Database\" active={activePage === 'database'} href=\"/database\" />\n        </nav>\n\n        <div className=\"border-t border-graphite-200 dark:border-graphite-800 pt-6 space-y-2\">\n          {/* Sidebar Controls */}\n          <div className={`flex items-center mb-2 ${isCollapsed ? 'justify-center' : 'justify-end px-2'}`}>\n            <button\n              onClick={toggleSidebar}\n              className=\"p-2 text-graphite-400 hover:text-graphite-900 dark:hover:text-white transition-colors rounded-lg hover:bg-graphite-50 dark:hover:bg-white/5\"\n              title={isCollapsed ? \"Expand\" : \"Collapse\"}\n            >\n              {isCollapsed ? <PanelLeft size={18} /> : <ChevronLeft size={18} />}\n            </button>\n          </div>\n\n          <div className=\"relative\" ref={settingsRef}>\n            {isSettingsOpen && (\n              <div className={`absolute bottom-full mb-3 rounded-2xl border border-graphite-200 dark:border-graphite-700 bg-white dark:bg-graphite-800 shadow-2xl p-2 animate-in slide-in-from-bottom-2 fade-in zoom-in-95 z-50 ${isCollapsed ? 'left-full ml-2 w-48' : 'left-0 right-0'}`}>\n\n                {/* Tempo Settings */}\n                <button\n                  onClick={() => { setShowTempoModal(true); setIsSettingsOpen(false); }}\n                  className=\"flex w-full items-center gap-3 rounded-xl px-3 py-2.5 text-sm font-medium text-graphite-600 dark:text-graphite-300 hover:bg-graphite-50 dark:hover:bg-graphite-700/50 transition-colors mb-1\"\n                >\n                  <Timer size={16} className=\"text-pacific-500\" />\n                  Tempo & Structure\n                </button>\n\n                {/* Theme Toggle */}\n                <button\n                  onClick={toggleTheme}\n                  className=\"flex w-full items-center justify-between rounded-xl px-3 py-2.5 text-sm font-medium text-graphite-600 dark:text-graphite-300 hover:bg-graphite-50 dark:hover:bg-graphite-700/50 transition-colors mb-1\"\n                >\n                  <span className=\"flex items-center gap-2\">\n                    {theme === 'dark' ? <Moon size={16} className=\"text-pacific-400\" /> : <Sun size={16} className=\"text-bali-500\" />}\n                    Theme\n                  </span>\n                  <span className=\"text-xs font-bold uppercase text-graphite-400\">{theme}</span>\n                </button>\n\n                {/* Account Settings - At the bottom of dropdown */}\n                <button\n                  onClick={() => { setShowAccountModal(true); setIsSettingsOpen(false); }}\n                  className=\"flex w-full items-center gap-3 rounded-xl px-3 py-2.5 text-sm font-medium text-graphite-600 dark:text-graphite-300 hover:bg-graphite-50 dark:hover:bg-graphite-700/50 transition-colors\"\n                >\n                  <User size={16} className=\"text-pacific-500\" />\n                  Account Settings\n                </button>\n              </div>\n            )}\n\n            <button\n              onClick={() => setIsSettingsOpen(!isSettingsOpen)}\n              className={`flex items-center rounded-xl py-3 text-sm font-semibold text-graphite-500 hover:bg-graphite-50 hover:text-graphite-900 dark:text-graphite-400 dark:hover:bg-white/5 dark:hover:text-graphite-200 transition-all ${isCollapsed ? 'w-full justify-center px-0 gap-0' : 'w-full px-4 gap-3'}`}\n              title=\"Settings\"\n            >\n              <Settings size={20} className={`transition-transform duration-500 ${isSettingsOpen ? 'rotate-90 text-pacific-500' : 'group-hover:rotate-45'}`} />\n              <span className={`whitespace-nowrap transition-all duration-300 ${isCollapsed ? 'w-0 opacity-0 overflow-hidden' : 'w-auto opacity-100'}`}>\n                Settings\n              </span>\n            </button>\n          </div>\n        </div>\n      </aside>\n\n      {/* Main Content Area */}\n      <main className=\"flex-1 overflow-y-auto bg-graphite-50 dark:bg-graphite-950 p-6 lg:p-10 relative\">\n        <div className=\"mx-auto max-w-7xl h-full\">\n          {children}\n        </div>\n      </main>\n\n      {showTempoModal && <TempoSettingsModal onClose={() => setShowTempoModal(false)} />}\n      {showAccountModal && <AccountSettingsModal onClose={() => setShowAccountModal(false)} />}\n    </div>\n  );\n};\n\nexport default Layout;\n","import React, { useEffect, useState } from 'react';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { LogIn, Mail, Lock, Eye, EyeOff, XCircle, Loader2, Apple } from 'lucide-react';\r\n\r\ninterface PortalEntryProps {\r\n  onEnter: () => void;\r\n}\r\n\r\nconst PortalEntry: React.FC<PortalEntryProps> = ({ onEnter }) => {\r\n  const [stage, setStage] = useState<0 | 1 | 2 | 'login'>(0);\r\n  const [loading, setLoading] = useState(true);\r\n  const [email, setEmail] = useState('');\r\n  const [password, setPassword] = useState('');\r\n  const [isSignUp, setIsSignUp] = useState(false);\r\n  const [authLoading, setAuthLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [showPassword, setShowPassword] = useState(false);\r\n\r\n  useEffect(() => {\r\n    checkSession();\r\n  }, []);\r\n\r\n  const checkSession = async () => {\r\n    const { data: { session } } = await supabase.auth.getSession();\r\n    if (session) {\r\n      startAnimation();\r\n    } else {\r\n      setLoading(false);\r\n      setStage('login');\r\n    }\r\n  };\r\n\r\n  const handleEmailAuth = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    setAuthLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      if (isSignUp) {\r\n        const { error: signUpError } = await supabase.auth.signUp({\r\n          email,\r\n          password,\r\n          options: {\r\n            emailRedirectTo: window.location.origin,\r\n          }\r\n        });\r\n        if (signUpError) throw signUpError;\r\n        setError(\"Account created! Check your email to confirm.\");\r\n      } else {\r\n        const { error: signInError } = await supabase.auth.signInWithPassword({ email, password });\r\n        if (signInError) throw signInError;\r\n      }\r\n    } catch (err: any) {\r\n      setError(err.message);\r\n    } finally {\r\n      setAuthLoading(false);\r\n    }\r\n  };\r\n\r\n  const startAnimation = () => {\r\n    setLoading(false);\r\n    setStage(0);\r\n    // Sequence\r\n    setTimeout(() => setStage(1), 500);\r\n    setTimeout(() => setStage(2), 2500);\r\n    setTimeout(() => onEnter(), 5500);\r\n  };\r\n\r\n  const handleGoogleLogin = async () => {\r\n    await supabase.auth.signInWithOAuth({\r\n      provider: 'google',\r\n      options: {\r\n        redirectTo: window.location.origin,\r\n        queryParams: {\r\n          prompt: 'select_account'\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-[#050505]\">\r\n        <div className=\"relative flex flex-col items-center\">\r\n          <div className=\"h-12 w-12 rounded-full border-t-2 border-pacific-500 animate-spin mb-4\"></div>\r\n          <div className=\"text-white/20 font-mono text-[10px] uppercase tracking-[0.5em] animate-pulse\">\r\n            Verifying System Identity\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (stage === 'login') {\r\n    return (\r\n      <div className=\"fixed inset-0 z-50 flex flex-col items-center justify-center bg-[#010101] transition-colors duration-1000 overflow-hidden font-sans select-none\">\r\n\r\n        {/* Cinematic Background Layers */}\r\n        <div className=\"absolute inset-0\">\r\n          {/* Broad atmospheric Pacific-blue wash at bottom edge */}\r\n          <div className=\"absolute bottom-[-15%] left-1/2 -translate-x-1/2 w-[140%] h-[65vh] bg-pacific-500/20 blur-[160px] rounded-[100%] opacity-100\"></div>\r\n          <div className=\"absolute bottom-[-10%] left-1/2 -translate-x-1/2 w-[80%] h-[40vh] bg-pacific-400/10 blur-[120px] rounded-[100%] animate-pulse duration-[8s] transition-all\"></div>\r\n\r\n          {/* Global Film Grain Overlay */}\r\n          <div className=\"absolute inset-0 opacity-[0.05] mix-blend-overlay pointer-events-none\"\r\n            style={{\r\n              backgroundImage: `url(\"data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E\")`\r\n            }}>\r\n          </div>\r\n\r\n          {/* Parallax Star Particles */}\r\n          <div className=\"absolute inset-0 opacity-[0.02]\">\r\n            {[...Array(6)].map((_, i) => (\r\n              <div\r\n                key={i}\r\n                className=\"absolute w-px h-px bg-white rounded-full\"\r\n                style={{\r\n                  top: `${Math.random() * 100}%`,\r\n                  left: `${Math.random() * 100}%`,\r\n                  opacity: Math.random()\r\n                }}\r\n              />\r\n            ))}\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"relative z-10 flex flex-col items-center w-full max-w-[440px] px-6 animate-in fade-in zoom-in-95 duration-1000\">\r\n\r\n          {/* Main Login Card - Professional Structural Re-architecture */}\r\n          <div className=\"w-full relative group/card p-[1px] rounded-[34px] bg-gradient-to-br from-white/15 via-white/5 to-white/10 shadow-[0_60px_120px_-30px_rgba(0,0,0,1)]\">\r\n\r\n            {/* Layer 2: High-Contrast Specular Highlights (The \"Glint\") */}\r\n            <div className=\"absolute inset-0 rounded-[34px] bg-gradient-to-tr from-transparent via-white/40 to-transparent opacity-0 group-hover/card:opacity-100 transition-opacity duration-[1.5s] pointer-events-none\"></div>\r\n\r\n            {/* Parent Surface Container (The Core) */}\r\n            <div className=\"relative rounded-[33px] bg-zinc-950/40 backdrop-blur-3xl overflow-hidden shadow-[inset_0_1px_1px_rgba(255,255,255,0.1)]\">\r\n\r\n              {/* Industrial Mesh Texture (Top Head Section) */}\r\n              <div className=\"absolute top-0 left-0 right-0 h-48 opacity-[0.08] mix-blend-soft-light pointer-events-none\"\r\n                style={{\r\n                  backgroundImage: `radial-gradient(circle at 2px 2px, white 1px, transparent 0)`,\r\n                  backgroundSize: '16px 16px'\r\n                }}>\r\n              </div>\r\n\r\n              {/* Internal Rim Lighting (Precision Edge) */}\r\n              <div className=\"absolute inset-0 rounded-[33px] border-t border-l border-white/10 pointer-events-none\"></div>\r\n\r\n              {/* Card Content Interior */}\r\n              <div className=\"relative px-11 py-11\">\r\n\r\n                {/* Branding Wordmark (Sidebar Sync) */}\r\n                <div className=\"flex flex-col items-center mb-10\">\r\n                  <div className=\"flex items-center justify-center select-none\">\r\n                    <span className=\"font-sans text-4xl font-black tracking-tighter text-white leading-none mr-[2px]\">P</span>\r\n                    <div className=\"relative h-8 w-8 mx-[1px] flex-shrink-0 flex items-center justify-center\">\r\n                      <div className=\"absolute inset-0 rounded-full border-[3.5px] border-transparent border-t-pacific-500 border-l-pacific-400 animate-[spin_3.5s_linear_infinite]\" style={{ boxShadow: '0 0 15px rgba(14, 165, 233, 0.3)' }}></div>\r\n                      <div className=\"absolute inset-[4px] rounded-full border-[2.5px] border-transparent border-b-bali-500 border-r-bali-400 animate-[spin_2.5s_linear_infinite_reverse]\"></div>\r\n                      <div className=\"absolute h-1.5 w-1.5 bg-white rounded-full shadow-[0_0_10px_white]\"></div>\r\n                    </div>\r\n                    <span className=\"font-sans text-4xl font-black tracking-tighter text-white leading-none ml-[2px]\">RTAL</span>\r\n                  </div>\r\n                </div>\r\n\r\n                <div className=\"mb-9 text-center\">\r\n                  <h2 className=\"text-[18px] font-bold text-white tracking-wide mb-1.5\">{isSignUp ? \"Initialize Identity\" : \"Authorize Access\"}</h2>\r\n                  <p className=\"text-white/20 text-[10px] leading-relaxed max-w-[220px] mx-auto\">Access your secure encrypted performance hub.</p>\r\n                </div>\r\n\r\n                {error && (\r\n                  <div className=\"mb-6 p-4 rounded-2xl bg-red-500/5 border border-red-500/15 flex items-center gap-3 animate-in slide-in-from-top-2\">\r\n                    <XCircle className=\"w-3.5 h-3.5 text-red-500/50 shrink-0\" />\r\n                    <p className=\"text-red-400/70 text-[10px] leading-tight\">{error}</p>\r\n                  </div>\r\n                )}\r\n\r\n                <form onSubmit={handleEmailAuth} className=\"space-y-4\">\r\n                  {/* Email Input Field */}\r\n                  <div className=\"relative h-[54px] group/input\">\r\n                    <div className=\"absolute left-[18px] top-1/2 -translate-y-1/2 flex items-center justify-center pointer-events-none z-10 h-4 w-4\">\r\n                      <Mail className=\"w-full h-full text-white/10 group-focus-within/input:text-pacific-400 transition-colors\" />\r\n                    </div>\r\n                    <input\r\n                      type=\"email\"\r\n                      value={email}\r\n                      onChange={(e) => setEmail(e.target.value)}\r\n                      placeholder=\"Email address\"\r\n                      required\r\n                      className=\"w-full h-full bg-black/40 border border-white/5 rounded-[18px] pl-[52px] pr-5 text-white placeholder:text-white/10 text-xs focus:outline-none focus:border-pacific-500/30 focus:bg-black/60 transition-all shadow-[inset_0_1px_6px_rgba(0,0,0,0.6)]\"\r\n                    />\r\n                  </div>\r\n\r\n                  {/* Password Input Field */}\r\n                  <div className=\"relative h-[54px] group/input\">\r\n                    <div className=\"absolute left-[18px] top-1/2 -translate-y-1/2 flex items-center justify-center pointer-events-none z-10 h-4 w-4\">\r\n                      <Lock className=\"w-full h-full text-white/10 group-focus-within/input:text-pacific-400 transition-colors\" />\r\n                    </div>\r\n                    <input\r\n                      type={showPassword ? \"text\" : \"password\"}\r\n                      value={password}\r\n                      onChange={(e) => setPassword(e.target.value)}\r\n                      placeholder=\"Password\"\r\n                      required\r\n                      className=\"w-full h-full bg-black/40 border border-white/5 rounded-[18px] pl-[52px] pr-[52px] text-white placeholder:text-white/10 text-xs focus:outline-none focus:border-pacific-500/30 focus:bg-black/60 transition-all shadow-[inset_0_1px_6px_rgba(0,0,0,0.6)]\"\r\n                    />\r\n                    <button\r\n                      type=\"button\"\r\n                      onClick={() => setShowPassword(!showPassword)}\r\n                      className=\"absolute right-[18px] top-1/2 -translate-y-1/2 flex items-center justify-center text-white/10 hover:text-white/30 transition-colors z-20 h-5 w-5\"\r\n                    >\r\n                      {showPassword ? <EyeOff className=\"w-4 h-4\" /> : <Eye className=\"w-4 h-4\" />}\r\n                    </button>\r\n                  </div>\r\n\r\n                  <button\r\n                    type=\"submit\"\r\n                    disabled={authLoading}\r\n                    className=\"w-full h-12 bg-white/[0.04] hover:bg-white/[0.07] border border-white/10 rounded-[18px] text-white font-bold text-xs tracking-[0.2em] transition-all active:scale-[0.98] flex items-center justify-center gap-2 group/btn relative overflow-hidden mt-3 shadow-lg\"\r\n                  >\r\n                    <div className=\"absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent -translate-x-full group-hover/btn:translate-x-full duration-1000 transition-transform\"></div>\r\n                    {authLoading ? (\r\n                      <Loader2 className=\"w-4 h-4 animate-spin text-pacific-400\" />\r\n                    ) : (\r\n                      <span className=\"pl-[0.15em]\">{isSignUp ? \"INITIALIZE\" : \"AUTHENTICATE\"}</span>\r\n                    )}\r\n                  </button>\r\n                </form>\r\n\r\n                <div className=\"my-7 flex items-center gap-4\">\r\n                  <div className=\"h-px flex-1 bg-white/[0.03]\"></div>\r\n                  <span className=\"text-[7px] text-white/10 uppercase tracking-[0.5em] font-bold pl-[0.5em]\">Network Protocol</span>\r\n                  <div className=\"h-px flex-1 bg-white/[0.03]\"></div>\r\n                </div>\r\n\r\n                <button\r\n                  onClick={handleGoogleLogin}\r\n                  className=\"w-full flex items-center justify-center gap-3.5 h-11 bg-black/30 hover:bg-black/50 border border-white/5 rounded-[18px] transition-all active:scale-[0.98] hover:border-pacific-500/20\"\r\n                >\r\n                  <svg viewBox=\"0 0 24 24\" className=\"w-4 h-4 opacity-70\">\r\n                    <path fill=\"#4285F4\" d=\"M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z\" />\r\n                    <path fill=\"#34A853\" d=\"M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z\" />\r\n                    <path fill=\"#FBBC05\" d=\"M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.26.81-.58z\" />\r\n                    <path fill=\"#EA4335\" d=\"M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z\" />\r\n                  </svg>\r\n                  <span className=\"text-white/30 text-[9px] font-bold tracking-widest uppercase pl-[0.1em]\">Log in with Google</span>\r\n                </button>\r\n\r\n                <div className=\"mt-9 text-center\">\r\n                  <button\r\n                    onClick={() => setIsSignUp(!isSignUp)}\r\n                    className=\"text-white/15 text-[8.5px] uppercase tracking-[0.5em] font-bold hover:text-pacific-400 transition-colors pl-[0.5em]\"\r\n                  >\r\n                    {isSignUp ? \"Identity Exists? Access\" : \"Request Portal Access\"}\r\n                  </button>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className={`fixed inset-0 z-50 flex items-center justify-center overflow-hidden bg-transparent ${stage === 2 ? 'pointer-events-none' : ''}`}>\r\n\r\n      {/* The \"Door\" Logic - Two panels splitting */}\r\n      {/* Light Mode: #fafafa (Zinc 50), Dark Mode: #18181b (Zinc 900) */}\r\n      <div\r\n        className={`absolute inset-y-0 left-0 z-20 transition-transform duration-[1500ms] ease-in-out border-r \r\n        bg-[#fafafa] dark:bg-[#18181b] border-zinc-200 dark:border-zinc-800\r\n        ${stage === 2 ? '-translate-x-full' : 'translate-x-0'}`}\r\n        style={{ width: '50%' }}\r\n      />\r\n      <div\r\n        className={`absolute inset-y-0 right-0 z-20 transition-transform duration-[1500ms] ease-in-out border-l \r\n        bg-[#fafafa] dark:bg-[#18181b] border-zinc-200 dark:border-zinc-800\r\n        ${stage === 2 ? 'translate-x-full' : 'translate-x-0'}`}\r\n        style={{ width: '50%' }}\r\n      />\r\n\r\n      {/* The Central Animation Container */}\r\n      <div className={`relative z-30 flex items-center justify-center transition-all duration-700 ${stage === 2 ? 'scale-125 opacity-0' : 'scale-100 opacity-100'}`}>\r\n\r\n        {/* Decorative Lines */}\r\n        <div className=\"absolute inset-0 flex items-center justify-center pointer-events-none\">\r\n          {/* Main Center Line */}\r\n          <div className={`absolute h-[1px] bg-zinc-900 dark:bg-white shadow-[0_0_20px_rgba(0,0,0,0.2)] dark:shadow-[0_0_20px_rgba(255,255,255,0.8)] transition-all duration-1000 ease-out \r\n              ${stage >= 1 ? 'w-[600px] opacity-100' : 'w-0 opacity-0'}`}\r\n          />\r\n\r\n          {/* Top Secondary Line */}\r\n          <div className={`absolute h-[1px] bg-zinc-300 dark:bg-zinc-700 transition-all duration-[1200ms] ease-out delay-100\r\n              ${stage >= 1 ? 'w-[400px] -translate-y-20 opacity-40' : 'w-0 translate-y-0 opacity-0'}`}\r\n          />\r\n\r\n          {/* Bottom Secondary Line */}\r\n          <div className={`absolute h-[1px] bg-zinc-300 dark:bg-zinc-700 transition-all duration-[1200ms] ease-out delay-100\r\n              ${stage >= 1 ? 'w-[400px] translate-y-20 opacity-40' : 'w-0 translate-y-0 opacity-0'}`}\r\n          />\r\n\r\n          {/* Vertical Scanner Line */}\r\n          <div className={`absolute w-[1px] bg-pacific-500/50 transition-all duration-700 ease-in-out delay-300\r\n              ${stage >= 1 ? 'h-40 opacity-100' : 'h-0 opacity-0'}`}\r\n          />\r\n        </div>\r\n\r\n        {/* Logo Replacement - Centered with background to mask lines */}\r\n        <div className={`relative z-10 flex items-center justify-center bg-[#fafafa] dark:bg-[#18181b] px-8 py-4 transition-all duration-1000 delay-300 ${stage >= 1 ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>\r\n          {/* P */}\r\n          <span className=\"font-display text-8xl font-black tracking-tighter text-zinc-900 dark:text-white leading-none mr-1.5\">P</span>\r\n\r\n          {/* THE PORTAL \"O\" */}\r\n          <div className=\"relative h-16 w-16 mx-1.5 flex-shrink-0 flex items-center justify-center\">\r\n            {/* Outer Ring - Pacific */}\r\n            <div className=\"absolute inset-0 rounded-full border-[4px] border-transparent border-t-pacific-500 border-l-pacific-400 animate-[spin_3s_linear_infinite]\" style={{ boxShadow: '0 0 25px rgba(14, 165, 233, 0.5)' }}></div>\r\n\r\n            {/* Inner Ring - Bali */}\r\n            <div className=\"absolute inset-[6px] rounded-full border-[3px] border-transparent border-b-bali-500 border-r-bali-400 animate-[spin_2s_linear_infinite_reverse]\"></div>\r\n\r\n            {/* Center Singularity */}\r\n            <div className=\"absolute h-3 w-3 bg-zinc-900 dark:bg-white rounded-full shadow-[0_0_15px_currentColor] animate-pulse\"></div>\r\n          </div>\r\n\r\n          {/* RTAL */}\r\n          <span className=\"font-display text-8xl font-black tracking-tighter text-zinc-900 dark:text-white leading-none ml-1.5\">RTAL</span>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PortalEntry;","\r\nimport React, { useState, useEffect } from 'react';\r\nimport { Timer, AlertTriangle, Save, X } from 'lucide-react';\r\nimport { supabaseService } from '@/lib/supabaseService';\r\n\r\ninterface TempoSettingsModalProps {\r\n  onClose: () => void;\r\n}\r\n\r\nexport const TempoSettingsModal: React.FC<TempoSettingsModalProps> = ({ onClose }) => {\r\n  const [days, setDays] = useState(90);\r\n  const [cycles, setCycles] = useState(6);\r\n  const [loading, setLoading] = useState(true);\r\n\r\n  useEffect(() => {\r\n    const fetchSettings = async () => {\r\n      try {\r\n        const settings = await supabaseService.getSystemSettings();\r\n        setDays(settings.days);\r\n        setCycles(settings.cycles);\r\n      } catch (e) {\r\n        console.error(\"Failed to load settings\", e);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n    fetchSettings();\r\n  }, []);\r\n\r\n  const handleSave = async () => {\r\n    setLoading(true);\r\n    await supabaseService.updateSystemSettings(days, cycles);\r\n    setLoading(false);\r\n    onClose();\r\n  };\r\n\r\n  const sprintLength = cycles > 0 ? (days / cycles).toFixed(1) : 0;\r\n  const isCleanDivison = days % cycles === 0;\r\n\r\n  if (loading) return null;\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 z-[60] flex items-center justify-center bg-graphite-950/80 backdrop-blur-sm p-4\" onClick={onClose}>\r\n      <div className=\"w-full max-w-md rounded-2xl bg-white dark:bg-graphite-900 p-8 shadow-2xl animate-in zoom-in-95 duration-200 border border-graphite-200 dark:border-graphite-800\" onClick={(e) => e.stopPropagation()}>\r\n        <div className=\"flex justify-between items-start mb-6\">\r\n          <div>\r\n            <h2 className=\"text-xl font-bold text-graphite-900 dark:text-white flex items-center gap-2\">\r\n              <div className=\"p-2 bg-pacific-100 dark:bg-pacific-900/20 text-pacific-600 dark:text-pacific-400 rounded-lg\"><Timer size={20} /></div>\r\n              Tempo & Structure\r\n            </h2>\r\n            <p className=\"text-xs text-graphite-500 mt-2\">Define the rhythm of your versions.</p>\r\n          </div>\r\n          <button onClick={onClose} className=\"text-graphite-400 hover:text-white\"><X size={20} /></button>\r\n        </div>\r\n\r\n        <div className=\"space-y-6\">\r\n          <div>\r\n            <label className=\"mb-1.5 block text-xs font-bold text-graphite-500 uppercase tracking-wide\">Total Version Days</label>\r\n            <input\r\n              type=\"number\"\r\n              value={days}\r\n              onChange={(e) => setDays(Number(e.target.value))}\r\n              className=\"w-full rounded-xl bg-graphite-50 dark:bg-graphite-800 border border-graphite-200 dark:border-graphite-700 p-3 text-graphite-900 dark:text-white focus:border-pacific-500 focus:ring-2 focus:ring-pacific-500/20 focus:outline-none transition-all\"\r\n            />\r\n          </div>\r\n          <div>\r\n            <label className=\"mb-1.5 block text-xs font-bold text-graphite-500 uppercase tracking-wide\">Cycles per Version</label>\r\n            <input\r\n              type=\"number\"\r\n              value={cycles}\r\n              onChange={(e) => setCycles(Number(e.target.value))}\r\n              className=\"w-full rounded-xl bg-graphite-50 dark:bg-graphite-800 border border-graphite-200 dark:border-graphite-700 p-3 text-graphite-900 dark:text-white focus:border-pacific-500 focus:ring-2 focus:ring-pacific-500/20 focus:outline-none transition-all\"\r\n            />\r\n          </div>\r\n\r\n          <div className={`p-4 rounded-xl border ${isCleanDivison ? 'bg-pacific-50 dark:bg-pacific-900/10 border-pacific-200 dark:border-pacific-800' : 'bg-red-50 dark:bg-red-900/10 border-red-200 dark:border-red-800'}`}>\r\n            <div className=\"flex items-center justify-between mb-1\">\r\n              <span className=\"text-xs font-bold uppercase text-graphite-500\">Calculated Sprint Length</span>\r\n              <span className={`text-lg font-bold ${isCleanDivison ? 'text-pacific-600 dark:text-pacific-400' : 'text-red-500'}`}>{sprintLength} Days</span>\r\n            </div>\r\n            {!isCleanDivison && (\r\n              <div className=\"flex items-start gap-2 mt-2 text-red-500 text-xs font-medium\">\r\n                <AlertTriangle size={14} className=\"shrink-0 mt-0.5\" />\r\n                Days must be perfectly divisible by cycles to ensure equal sprint lengths.\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          <div className=\"flex justify-end gap-3 pt-2\">\r\n            <button onClick={onClose} type=\"button\" className=\"rounded-xl px-4 py-2 text-sm font-medium text-graphite-500 hover:text-graphite-800 dark:hover:text-graphite-200 transition-colors\">Cancel</button>\r\n            <button\r\n              onClick={handleSave}\r\n              disabled={!isCleanDivison || days <= 0 || cycles <= 0}\r\n              className=\"rounded-xl bg-pacific-600 px-6 py-2.5 text-sm font-bold text-white hover:bg-pacific-500 transition-colors shadow-lg shadow-pacific-500/30 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2\"\r\n            >\r\n              <Save size={16} /> Save Settings\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name LayoutDashboard\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI5IiB4PSIzIiB5PSIzIiByeD0iMSIgLz4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI1IiB4PSIxNCIgeT0iMyIgcng9IjEiIC8+CiAgPHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iOSIgeD0iMTQiIHk9IjEyIiByeD0iMSIgLz4KICA8cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSI1IiB4PSIzIiB5PSIxNiIgcng9IjEiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/layout-dashboard\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LayoutDashboard = createLucideIcon('LayoutDashboard', [\n  ['rect', { width: '7', height: '9', x: '3', y: '3', rx: '1', key: '10lvy0' }],\n  ['rect', { width: '7', height: '5', x: '14', y: '3', rx: '1', key: '16une8' }],\n  ['rect', { width: '7', height: '9', x: '14', y: '12', rx: '1', key: '1hutg5' }],\n  ['rect', { width: '7', height: '5', x: '3', y: '16', rx: '1', key: 'ldoo1y' }],\n]);\n\nexport default LayoutDashboard;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Moon\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTIgM2E2IDYgMCAwIDAgOSA5IDkgOSAwIDEgMS05LTlaIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/moon\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Moon = createLucideIcon('Moon', [\n  ['path', { d: 'M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z', key: 'a7tn18' }],\n]);\n\nexport default Moon;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Pencil\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTcgM2EyLjg1IDIuODMgMCAxIDEgNCA0TDcuNSAyMC41IDIgMjJsMS41LTUuNVoiIC8+CiAgPHBhdGggZD0ibTE1IDUgNCA0IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/pencil\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Pencil = createLucideIcon('Pencil', [\n  ['path', { d: 'M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z', key: '5qss01' }],\n  ['path', { d: 'm15 5 4 4', key: '1mk7zo' }],\n]);\n\nexport default Pencil;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Loader2\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEgMTJhOSA5IDAgMSAxLTYuMjE5LTguNTYiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/loader-2\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Loader2 = createLucideIcon('Loader2', [\n  ['path', { d: 'M21 12a9 9 0 1 1-6.219-8.56', key: '13zald' }],\n]);\n\nexport default Loader2;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Sun\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI0IiAvPgogIDxwYXRoIGQ9Ik0xMiAydjIiIC8+CiAgPHBhdGggZD0iTTEyIDIwdjIiIC8+CiAgPHBhdGggZD0ibTQuOTMgNC45MyAxLjQxIDEuNDEiIC8+CiAgPHBhdGggZD0ibTE3LjY2IDE3LjY2IDEuNDEgMS40MSIgLz4KICA8cGF0aCBkPSJNMiAxMmgyIiAvPgogIDxwYXRoIGQ9Ik0yMCAxMmgyIiAvPgogIDxwYXRoIGQ9Im02LjM0IDE3LjY2LTEuNDEgMS40MSIgLz4KICA8cGF0aCBkPSJtMTkuMDcgNC45My0xLjQxIDEuNDEiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/sun\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Sun = createLucideIcon('Sun', [\n  ['circle', { cx: '12', cy: '12', r: '4', key: '4exip2' }],\n  ['path', { d: 'M12 2v2', key: 'tus03m' }],\n  ['path', { d: 'M12 20v2', key: '1lh1kg' }],\n  ['path', { d: 'm4.93 4.93 1.41 1.41', key: '149t6j' }],\n  ['path', { d: 'm17.66 17.66 1.41 1.41', key: 'ptbguv' }],\n  ['path', { d: 'M2 12h2', key: '1t8f8n' }],\n  ['path', { d: 'M20 12h2', key: '1q8mjw' }],\n  ['path', { d: 'm6.34 17.66-1.41 1.41', key: '1m8zz5' }],\n  ['path', { d: 'm19.07 4.93-1.41 1.41', key: '1shlcs' }],\n]);\n\nexport default Sun;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Mail\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHg9IjIiIHk9IjQiIHJ4PSIyIiAvPgogIDxwYXRoIGQ9Im0yMiA3LTguOTcgNS43YTEuOTQgMS45NCAwIDAgMS0yLjA2IDBMMiA3IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/mail\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Mail = createLucideIcon('Mail', [\n  ['rect', { width: '20', height: '16', x: '2', y: '4', rx: '2', key: '18n3k1' }],\n  ['path', { d: 'm22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7', key: '1ocrg3' }],\n]);\n\nexport default Mail;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Lock\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB3aWR0aD0iMTgiIGhlaWdodD0iMTEiIHg9IjMiIHk9IjExIiByeD0iMiIgcnk9IjIiIC8+CiAgPHBhdGggZD0iTTcgMTFWN2E1IDUgMCAwIDEgMTAgMHY0IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/lock\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Lock = createLucideIcon('Lock', [\n  ['rect', { width: '18', height: '11', x: '3', y: '11', rx: '2', ry: '2', key: '1w4ew1' }],\n  ['path', { d: 'M7 11V7a5 5 0 0 1 10 0v4', key: 'fwvmzm' }],\n]);\n\nexport default Lock;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name LogOut\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNOSAyMUg1YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDQiIC8+CiAgPHBvbHlsaW5lIHBvaW50cz0iMTYgMTcgMjEgMTIgMTYgNyIgLz4KICA8bGluZSB4MT0iMjEiIHgyPSI5IiB5MT0iMTIiIHkyPSIxMiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/log-out\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LogOut = createLucideIcon('LogOut', [\n  ['path', { d: 'M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4', key: '1uf3rs' }],\n  ['polyline', { points: '16 17 21 12 16 7', key: '1gabdz' }],\n  ['line', { x1: '21', x2: '9', y1: '12', y2: '12', key: '1uyos4' }],\n]);\n\nexport default LogOut;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name PanelLeft\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cmVjdCB3aWR0aD0iMTgiIGhlaWdodD0iMTgiIHg9IjMiIHk9IjMiIHJ4PSIyIiAvPgogIDxwYXRoIGQ9Ik05IDN2MTgiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/panel-left\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst PanelLeft = createLucideIcon('PanelLeft', [\n  ['rect', { width: '18', height: '18', x: '3', y: '3', rx: '2', key: 'afitv7' }],\n  ['path', { d: 'M9 3v18', key: 'fh3hqa' }],\n]);\n\nexport default PanelLeft;\n","import React, { useState, useEffect } from 'react';\r\nimport { X, LogOut, Pencil, Loader2 } from 'lucide-react';\r\nimport { supabaseService } from '@/lib/supabaseService';\r\nimport { supabase } from '@/lib/supabase';\r\nimport { Profile } from '@/types/types';\r\n\r\ninterface AccountSettingsModalProps {\r\n  onClose: () => void;\r\n}\r\n\r\nexport const AccountSettingsModal: React.FC<AccountSettingsModalProps> = ({ onClose }) => {\r\n  const [profile, setProfile] = useState<Profile | null>(null);\r\n  const [userData, setUserData] = useState<{ name?: string, email?: string, googleAvatar?: string } | null>(null);\r\n  const [uploading, setUploading] = useState(false);\r\n  const fileInputRef = React.useRef<HTMLInputElement>(null);\r\n\r\n  useEffect(() => {\r\n    const fetchUserData = async () => {\r\n      const { data: { session } } = await supabase.auth.getSession();\r\n      if (session?.user) {\r\n        setUserData({\r\n          name: session.user.user_metadata?.full_name,\r\n          email: session.user.email,\r\n          googleAvatar: session.user.user_metadata?.avatar_url || session.user.user_metadata?.picture\r\n        });\r\n        const p = await supabaseService.getProfile();\r\n        setProfile(p);\r\n      }\r\n    };\r\n    fetchUserData();\r\n  }, []);\r\n\r\n  const handleSignOut = async () => {\r\n    await supabase.auth.signOut();\r\n    window.location.href = '/';\r\n  };\r\n\r\n  const handleAvatarClick = () => {\r\n    fileInputRef.current?.click();\r\n  };\r\n\r\n  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {\r\n    const file = e.target.files?.[0];\r\n    if (!file) return;\r\n\r\n    try {\r\n      setUploading(true);\r\n      const publicUrl = await supabaseService.uploadAvatar(file);\r\n      await supabaseService.updateProfile({ avatar_url: publicUrl });\r\n\r\n      // Update local state\r\n      setProfile((prev: Profile | null) => prev ? { ...prev, avatar_url: publicUrl } : null);\r\n    } catch (error) {\r\n      console.error('Error uploading avatar:', error);\r\n      alert('Failed to upload avatar. Please try again.');\r\n    } finally {\r\n      setUploading(false);\r\n    }\r\n  };\r\n\r\n  const currentAvatar = profile?.avatar_url || userData?.googleAvatar || `https://ui-avatars.com/api/?name=${userData?.name || 'User'}&background=0ea5e9&color=fff`;\r\n\r\n  const handleImageError = (e: React.SyntheticEvent<HTMLImageElement, Event>) => {\r\n    const fallback = `https://ui-avatars.com/api/?name=${userData?.name || 'User'}&background=0ea5e9&color=fff`;\r\n    if (e.currentTarget.src !== fallback) {\r\n      e.currentTarget.src = fallback;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 z-[60] flex items-center justify-center bg-graphite-950/80 backdrop-blur-sm p-4\" onClick={onClose}>\r\n      <div className=\"w-full max-w-sm rounded-[2rem] bg-white dark:bg-graphite-900 shadow-2xl animate-in zoom-in-95 duration-300 border border-graphite-200 dark:border-graphite-800 p-8 pt-10\" onClick={(e) => e.stopPropagation()}>\r\n\r\n        <input\r\n          type=\"file\"\r\n          ref={fileInputRef}\r\n          className=\"hidden\"\r\n          accept=\"image/*\"\r\n          onChange={handleFileChange}\r\n        />\r\n\r\n        <div className=\"flex justify-between items-start mb-10\">\r\n          <div>\r\n            <h2 className=\"text-xl font-display font-black text-graphite-900 dark:text-white\">\r\n              Account Settings\r\n            </h2>\r\n          </div>\r\n          <button onClick={onClose} className=\"p-2 text-graphite-400 hover:bg-graphite-100 dark:hover:bg-white/5 rounded-full transition-colors\">\r\n            <X size={20} />\r\n          </button>\r\n        </div>\r\n\r\n        <div className=\"flex justify-between items-center mb-10 gap-6\">\r\n          <div className=\"flex-1 min-w-0\">\r\n            <h3 className=\"text-xl font-display font-bold text-graphite-900 dark:text-white tracking-tight truncate\">\r\n              {userData?.name || 'Authorized User'}\r\n            </h3>\r\n            <p className=\"text-xs font-medium text-graphite-500 dark:text-graphite-400 font-mono mt-1 truncate\">\r\n              {userData?.email}\r\n            </p>\r\n          </div>\r\n\r\n          <div className=\"relative group cursor-pointer shrink-0\" onClick={handleAvatarClick}>\r\n            <div className=\"absolute inset-0 bg-pacific-500/20 blur-xl rounded-full opacity-50 group-hover:opacity-100 transition-opacity\"></div>\r\n\r\n            <div className=\"relative z-10\">\r\n              <img\r\n                src={currentAvatar}\r\n                className=\"w-16 h-16 rounded-full border-2 border-pacific-500/30 object-cover shadow-2xl transition-all duration-500 group-hover:brightness-75\"\r\n                alt=\"\"\r\n                onError={handleImageError}\r\n              />\r\n\r\n              {/* Pencil Overlay */}\r\n              <div className=\"absolute top-0 right-0 p-1 bg-white dark:bg-graphite-800 rounded-full shadow-lg border border-graphite-100 dark:border-graphite-700 opacity-0 group-hover:opacity-100 transition-all duration-300 transform scale-50 group-hover:scale-100 translate-x-1/4 -translate-y-1/4\">\r\n                <Pencil size={10} className=\"text-pacific-500\" />\r\n              </div>\r\n\r\n              {/* Uploading Overlay */}\r\n              {uploading && (\r\n                <div className=\"absolute inset-0 z-20 flex items-center justify-center bg-black/40 rounded-full backdrop-blur-[2px]\">\r\n                  <Loader2 size={16} className=\"text-white animate-spin\" />\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"space-y-3\">\r\n          <button\r\n            onClick={handleSignOut}\r\n            className=\"w-full flex items-center justify-center gap-3 py-4 rounded-2xl bg-red-50 dark:bg-red-900/10 text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-600 border border-red-100 dark:border-red-900/20 font-bold text-sm transition-all duration-300 group\"\r\n          >\r\n            <LogOut size={18} className=\"transition-transform group-hover:-translate-x-1\" />\r\n            Log Out\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Timer\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8bGluZSB4MT0iMTAiIHgyPSIxNCIgeTE9IjIiIHkyPSIyIiAvPgogIDxsaW5lIHgxPSIxMiIgeDI9IjE1IiB5MT0iMTQiIHkyPSIxMSIgLz4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjE0IiByPSI4IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/timer\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Timer = createLucideIcon('Timer', [\n  ['line', { x1: '10', x2: '14', y1: '2', y2: '2', key: '14vaq8' }],\n  ['line', { x1: '12', x2: '15', y1: '14', y2: '11', key: '17fdiu' }],\n  ['circle', { cx: '12', cy: '14', r: '8', key: '1e1u0o' }],\n]);\n\nexport default Timer;\n"],"names":["assign","searchParamsToUrlQuery","urlQueryToSearchParams","searchParams","query","key","value","entries","existing","Array","isArray","push","stringifyUrlQueryParam","param","isNaN","String","URLSearchParams","Object","item","append","set","target","searchParamsList","keys","delete","formatUrl","formatWithValidation","urlObjectKeys","slashedProtocols","urlObj","auth","hostname","protocol","pathname","hash","host","encodeURIComponent","replace","indexOf","port","querystring","search","endsWith","slashes","test","url","process","env","NODE_ENV","forEach","includes","console","warn","useMergedRef","refA","refB","cleanupA","useRef","cleanupB","useCallback","current","cleanupFnA","cleanupFnB","applyRef","cleanup","DecodeError","MiddlewareNotFoundError","MissingStaticPage","NormalizeError","PageNotFoundError","SP","ST","WEB_VITALS","execOnce","getDisplayName","getLocationOrigin","getURL","isAbsoluteUrl","isResSent","loadGetInitialProps","normalizeRepeatedSlashes","stringifyError","fn","used","result","args","ABSOLUTE_URL_REGEX","window","location","href","origin","substring","length","Component","displayName","name","res","finished","headersSent","urlParts","split","urlNoQuery","slice","join","App","ctx","prototype","getInitialProps","message","Error","pageProps","props","performance","every","method","constructor","page","code","error","JSON","stringify","stack","parsePath","path","hashIndex","queryIndex","hasQuery","undefined","addPathPrefix","prefix","startsWith","removeTrailingSlash","route","normalizePathTrailingSlash","__NEXT_MANUAL_TRAILING_SLASH","__NEXT_TRAILING_SLASH","addBasePath","basePath","__NEXT_ROUTER_BASEPATH","required","__NEXT_MANUAL_CLIENT_BASE_PATH","warnOnce","_","warnings","Set","msg","has","add","FetchStrategy","NavigationResultTag","PrefetchPriority","createCacheKey","originalHref","nextUrl","originalUrl","URL","cacheKey","HasLoadingBoundary","matchSegment","existingSegment","segment","readVaryParams","thenable","then","noop","status","ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_ACTION_REVALIDATED_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind","isThenable","promise","dispatchAppRouterAction","dispatchGestureState","useActionQueue","dispatch","action","setGestureRouterState","state","__DEV__","promisesWithDebugInfo","WeakMap","actionQueue","canonicalState","setState","React","useState","setGesture","useOptimistic","useAppDevRenderingIndicator","require","appDevRenderingIndicator","stateWithDebugInfo","useMemo","promiseWithDebugInfo","get","debugInfo","Promise","resolve","asyncState","_debugInfo","use","callServer","actionId","actionArgs","reject","startTransition","type","findSourceMapURL","filename","document","HEAD_REQUEST_KEY","ROOT_SEGMENT_REQUEST_KEY","appendSegmentRequestKeyPart","convertSegmentPathToStaticExportFilename","createSegmentRequestKeyPart","PAGE_SEGMENT_KEY","safeName","encodeToFilesystemAndURLSafeString","paramType","encodedName","parentRequestKey","parallelRouteKey","childRequestKeyPart","slotKey","simpleParamValueRegex","base64url","btoa","segmentPath","doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlSearchParamsToParsedUrlQuery","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","rewrittenPath","pathnameParts","partIndex","map","s","i","DEFAULT_SEGMENT_KEY","paramValue","renderedSearch","pageSegmentWithSearchParams","addSearchParamsIfPageSegment","fromEntries","urlWithoutFlightParameters","__NEXT_CONFIG_OUTPUT","paramCacheKey","isCatchAll","createHrefFromUrl","includeHash","createInitialRSCPayloadFromFallbackPrerender","getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","tree","seedData","head","isHeadPartial","pathToSegment","isRootRender","fallbackInitialRSCPayload","renderedPathname","canonicalUrl","originalFlightDataPath","f","originalFlightRouterState","b","c","q","fillInFallbackFlightRouterState","m","G","S","h","flightRouterState","filter","p","index","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","paramName","staticSiblings","childPathnamePartsIndex","children","newChildren","childFlightRouterState","newState","flightSegmentPath","flightData","isHmrRefresh","stripClientOnlyDataFromFlightRouterState","parallelRoutes","_refreshState","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripClientOnlyDataFromSegment","cleanedParallelRoutes","childState","getAppBuildId","setAppBuildId","globalBuildId","buildId","djb2Hash","hexHash","str","char","charCodeAt","toString","computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","uniqueCacheKey","existingSearch","rawQuery","pairs","pair","getDeploymentId","getDeploymentIdQueryOrEmptyString","deploymentId","documentElement","dataset","dplId","NEXT_DEPLOYMENT_ID","createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","createDebugChannel","__NEXT_REACT_DEBUG_CHANNEL","doMpaNavigation","isPageUnloading","addEventListener","options","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","responseUrl","redirected","contentType","interception","postponed","staleTimeHeaderSeconds","staleTime","parseInt","isFlightResponse","ok","body","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","normalizedFlightData","couldBeIntercepted","prerendered","err","fetchPriority","signal","__NEXT_TEST_MODE","self","__next_r","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","priority","fetchUrl","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","rscResponse","requestHeaders","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","deleteFromLru","lruPut","updateLruSize","didScheduleCleanup","lruSize","maxLruSize","node","prev","next","size","ensureCleanupIsScheduled","tail","newNodeSize","prevNodeSize","deleted","requestCleanupCallback","ninetyPercentMax","deleteMapEntry","requestIdleCallback","cb","setTimeout","Fallback","createCacheMap","deleteFromCacheMap","getFromCacheMap","isValueExpired","setInCacheMap","setSizeInCacheMap","Revalidation","cacheMap","parent","getOrInitialize","isRevalidation","entry","remainingKeys","previousKey","existingEntry","Map","newEntry","now","currentCacheVersion","rootEntry","getEntryWithFallbackImpl","staleAt","version","lazilyEvictIfNeeded","fallbackEntry","setMapEntryValue","dropRef","oldEntry","ref","parentMap","revalidatingEntry","appendLayoutVaryPath","clonePageVaryPathWithNewSearchParams","finalizeLayoutVaryPath","finalizeMetadataVaryPath","finalizePageVaryPath","getFulfilledRouteVaryPath","getFulfilledSegmentVaryPath","getPartialLayoutVaryPath","getPartialPageVaryPath","getRenderedSearchFromVaryPath","getRouteVaryPath","getSegmentVaryPathForRequest","varyPath","id","parentPath","varyPathPart","requestKey","layoutVaryPath","finalizedVaryPath","pageVaryPath","pageRequestKey","fetchStrategy","originalVaryPath","isPage","doesVaryOnSearchParams","Full","PPRRuntime","searchParamsVaryPath","pathParamsVaryPath","patchedVaryPath","newSearch","clonedVaryPath","original","varyParams","clone","isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","slots","currentTreeChildren","slot","nextTreeChild","currentTreeChild","discoverKnownRoute","matchKnownRoute","resetKnownRoutes","createEmptyPart","staticChildren","dynamicChild","dynamicChildParamName","dynamicChildParamType","pattern","knownRouteTreeRoot","pendingEntry","routeTree","metadataVaryPath","isPPREnabled","hasDynamicRewrite","firstPart","remainingParts","fulfilledEntry","fulfillRouteCacheEntry","discoverKnownRoutePart","discoverDynamicChild","part","newChild","mutablePart","parentKnownRoutePart","urlPart","fullTree","segmentAppearsInURL","knownRoutePart","nextUrlPart","nextRemainingParts","writeRouteIntoCache","sibling","existingChild","resultFromChildren","childRouteTree","refreshState","resolvedParams","match","matchKnownRoutePart","matchedPart","acc","reifiedTree","reifyRouteTree","reifiedMetadata","createMetadataRouteTree","syntheticEntry","EntryStatus","Fulfilled","blockedTasks","metadata","staticChild","dynamicPart","dynamicPattern","parentPartialVaryPath","partialVaryPath","newValue","newCacheKey","newSlots","newVaryPath","hasRuntimePrefetch","invalidateBfCache","readFromBFCache","readFromBFCacheDuringRegularNavigation","writeHeadToBFCache","writeToBFCache","bfcacheMap","currentBfCacheVersion","rsc","prefetchRsc","prefetchHead","DYNAMIC_STALETIME_MS","FreshnessPolicy","createInitialCacheNodeForHydration","isDeferredRsc","spawnDynamicRequests","startPPRNavigation","navigatedAt","initialTree","seedHead","accumulation","scrollableSegments","separateRefreshUrls","task","createCacheNodeOnNavigation","oldUrl","oldRenderedSearch","oldCacheNode","oldRouterState","newRouteTree","newMetadataVaryPath","freshness","isSamePageNavigation","didFindRootLayout","parentNeedsDynamicRequest","parentRefreshState","oldRootRefreshState","updateCacheNodeOnNavigation","parentSegmentPath","parentParallelRouteKey","oldSegment","createSegmentFromRouteTree","NOT_FOUND_SEGMENT_KEY","concat","oldRouterStateChildren","seedDataChildren","childDidFindRootLayout","shouldRefreshDynamicData","isLeafSegment","newCacheNode","needsDynamicRequest","dropPrefetchRsc","reuseSharedCacheNode","seedRsc","createCacheNodeForSegment","cacheNode","maybeRefreshState","accumulateRefreshUrl","patchedRouterStateChildren","taskChildren","childNeedsDynamicRequest","dynamicRequestTreeChildren","newCacheNodeSlots","oldCacheNodeSlots","newRouteTreeChild","oldRouterStateChild","seedDataChild","oldSegmentChild","newSegmentChild","seedHeadChild","reuseActiveSegmentInDefaultSlot","oldCacheNodeChild","taskChild","taskChildRoute","dynamicRequestTreeChild","dynamicRequestTree","newFlightRouterState","createDynamicRequestTree","stringifiedQuery","patchRouterStateWithNewChildren","baseRouterState","newRouterState","refreshUrl","parentRouteTree","reusedUrl","reusedRenderedSearch","oldRefreshState","reusedRouteTree","convertReusedFlightRouterStateToRouteTree","existingCacheNode","createCacheNode","bfcacheEntry","oldRsc","oldRscDidResolve","cachedRsc","isCachedRscPartial","segmentEntry","readSegmentCacheEntry","isPartial","Pending","promiseForFulfilledEntry","waitForSegmentCacheEntry","Empty","Rejected","doesSegmentNeedDynamicRequest","createDeferredRsc","doesHeadNeedDynamicRequest","cachedHead","isCachedHeadPartial","metadataEntry","__NEXT_OPTIMISTIC_ROUTING","previousNavigationDidMismatch","primaryUrl","freshnessPolicy","routeCacheEntry","primaryRequestPromise","fetchMissingDynamicData","refreshRequestPromises","scopedDynamicRequestTree","voidPromise","finishNavigationTask","exitStatus","waitForRequestsToFinish","abortRemainingPendingTasks","isHardRetry","primaryRequestResult","dispatchRetryDueToTreeMismatch","seed","onFulfill","remainingCount","onReject","refreshRequestPromise","retryUrl","retryNextUrl","baseTree","markRouteEntryAsDynamicRewrite","Date","invalidateRouteCacheEntries","retryAction","previousTree","mpa","convertServerPatchToFullTree","didReceiveUnknownParallelRoute","writeDynamicDataIntoNavigationTask","data","serverRouteTree","dynamicData","dynamicHead","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouteTreeChild","dynamicDataChild","taskSegment","serverSegment","childDidReceiveUnknownParallelRoute","dynamicSegmentData","abortPendingCacheNode","childExitStatus","DEFERRED","Symbol","tag","pendingRsc","rej","responseDebugInfo","fulfilledRsc","apply","rejectedRsc","reason","ensureLeadingSlash","normalizeAppPath","normalizeRscURL","reduce","segments","isGroupSegment","INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","find","interceptingRoute","marker","interceptedRoute","splitInterceptingRoute","computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","segmentToPathname","normalizeSegments","some","childrenPath","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","changedPath","params","parallelRoute","values","isDynamicParameter","segmentValue","isJavaScriptURLString","isJavaScriptProtocol","completeHardNavigation","completeSoftNavigation","completeTraverseNavigation","navigate","navigateToKnownRoute","currentUrl","currentRenderedSearch","currentCacheNode","currentFlightRouterState","shouldScroll","navigateType","readRouteCacheEntry","navigateUsingPrefetchedRouteTree","optimisticRoute","deprecated_requestOptimisticRouteCacheEntry","navigateToUnknownRoute","catch","navigationSeed","Gesture","prefetchSeed","DynamicRequestTreeForEntireRoute","Default","HistoryTraversal","Hydration","RefreshAll","HMRRefresh","promiseForDynamicServerResponse","redirectUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","cache","previousNextUrl","oldState","referringNextUrl","collectedDebugInfo","nextUrlForNewRoute","onlyHashChange","segmentPathsToScrollTo","segmentPaths","hashFragment","decodeURIComponent","baseData","treePatch","dataPatch","headPatch","convertServerPatchToFullTreeImpl","finalFlightRouterState","convertRootFlightRouterStateToRouteTree","updatedParallelRouteKey","baseTreeChildren","baseSeedDataChildren","newTreeChildren","newSeedDataChildren","childBaseRouterState","childBaseSeedData","clonedTree","clonedSeedData","compressedRefreshState","isEmptySeedDataPartial","STATIC_STALETIME_MS","navigateReducer","Number","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","getStaleTimeMs","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","isExternalUrl","getElementById","navigateUsingSegmentCache","createPromiseWithResolvers","attemptToFulfillDynamicSegmentFromBFCache","canNewFetchStrategyProvideMoreContent","convertRouteTreeToFlightRouterState","createDetachedSegmentCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","fetchSegmentPrefetchesUsingDynamicRequest","getCurrentRouteCacheVersion","getCurrentSegmentCacheVersion","invalidateEntirePrefetchCache","invalidateSegmentCacheEntries","overwriteRevalidatingSegmentCacheEntry","pingInvalidationListeners","readOrCreateRevalidatingSegmentEntry","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","upgradeToPendingSegment","upsertSegmentEntry","staleTimeSeconds","Math","max","isOutputExportMode","MetadataOnlyRequestTree","routeCacheMap","segmentCacheMap","invalidationListeners","currentRouteCacheVersion","currentSegmentCacheVersion","pingVisibleLinks","attachInvalidationListener","onInvalidate","notifyInvalidationListener","reportError","tasks","isPrefetchTaskDirty","readRevalidatingSegmentCacheEntry","promiseWithResolvers","createDetachedRouteCacheEntry","Infinity","requestedUrl","requestedSearch","urlWithoutSearchParams","routeWithNoSearchParams","createPrefetchRequestKey","canonicalUrlForRouteWithNoSearchParams","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","optimisticCanonicalUrl","optimisticRouteTree","deprecated_createOptimisticRouteTree","optimisticMetadataTree","optimisticEntry","newRenderedSearch","clonedSlots","originalSlots","childTree","varyPathForRequest","candidateEntry","rejectedEntry","emptyEntry","PPR","adjustedCurrentTime","requestedAt","dynamicPrefetchStaleAt","pendingSegment","fulfillSegmentCacheEntry","pingBlockedTasks","pingPrefetchTask","SubtreeHasNoLoadingBoundary","segmentCacheEntry","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","rootSegment","convertTreePrefetchToRouteTree","prefetch","prefetchSlots","childPrefetch","childSegmentName","childParam","childDoesAppearInURL","childSegment","childPartialVaryPath","childParamValue","childParamKey","siblings","childRequestKey","SegmentHasLoadingBoundary","convertFlightRouterStateToRouteTree","requestKeyPart","parentRenderedSearch","childRouterState","urlAfterRedirects","headResponse","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","varyHeader","closed","routeIsPPREnabled","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","serverData","headVaryParamsThenable","headVaryParams","writeDynamicTreeResponseIntoCache","LoadingBoundary","fulfilledVaryPath","routeKey","normalizedRequestKey","requestUrl","__NEXT_VARY_PARAMS","spawnedEntries","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","isResponsePartial","rp","writeDynamicRenderResponseIntoCache","originalPathname","normalizedFlightDataResult","flightDatas","staleTimeMs","writeSeedDataIntoCache","fulfillEntrySpawnedByRuntimePrefetch","entriesOwnedByCurrentTask","varyParamsThenable","childSeedData","segmentVaryParams","ownedEntry","possiblyNewEntry","onStreamClose","totalByteLength","byteLength","staticUrl","routeDir","staticExportFilename","currentStrategy","newStrategy","cancelPrefetchTask","reschedulePrefetchTask","schedulePrefetchTask","startRevalidationCooldown","scheduleMicrotask","queueMicrotask","taskHeap","inProgressRequests","sortIdCounter","didScheduleMicrotask","mostRecentlyHoveredLink","REVALIDATION_COOLDOWN_MS","revalidationCooldownTimeoutHandle","clearTimeout","ensureWorkIsScheduled","treeAtTimeOfPrefetch","routeCacheVersion","segmentCacheVersion","phase","hasBackgroundWork","spawnedRuntimePrefetches","sortId","isCanceled","_heapIndex","trackMostRecentlyHoveredLink","heapPush","heapDelete","Intent","heapResift","Background","processQueueInMicrotask","hasNetworkBandwidth","spawnPrefetchSubtask","prefetchSubtask","onPrefetchConnectionClosed","heapPeek","pingRoute","heapPop","background","pingRootRouteTree","keyWithoutSearch","routeWithoutSearch","pingStaticHead","pingSharedPartOfCacheComponentsTree","pingRuntimeHead","requestTree","pingRuntimePrefetches","diffRouteTreeAgainstCurrent","pingStaticSegmentData","pingRouteTreeAndIncludeDynamicData","oldTree","newTree","oldTreeChildren","newTreeChild","newTreeChildSegment","oldTreeChild","oldTreeChildSegment","doesCurrentSegmentMatchCachedSegment","pingNewPartOfCacheComponentsTree","requestTreeChildren","requestTreeChild","subtreeHasLoadingBoundary","pingPPRDisabledRouteTreeUpToLoadingBoundary","refetchMarkerContext","refetchMarker","segmentHasLoadingBoundary","isInsideRefetchingParent","spawnedSegment","fulfilled","pingFullSegmentRevalidation","pingPPRSegmentRevalidation","revalidatingSegment","upsertSegmentOnCompletion","nonEmptyRevalidatingSegment","emptySegment","currentSegment","cachedSegment","compareQueuePriority","a","priorityDiff","phaseDiff","heap","heapSiftUp","first","last","pop","heapSiftDown","parentIndex","halfLength","leftIndex","left","rightIndex","right","IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","link","setOptimisticLinkStatus","prefetchable","prefetchableAndVisible","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","element","instance","existingInstance","observe","coercePrefetchableUrl","createPrefetchURL","reportErrorFn","router","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","unobserve","intersectionRatio","rescheduleLinkPrefetch","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","existingPrefetchTask","getCurrentAppRouterState","appRouterState","scheduleSegmentPrefetchTask","pathHasPrefix","hasBasePath","isLocalURL","locationOrigin","resolved","errorOnce","errors","LinkComponent","useLinkStatus","isModifiedEvent","event","eventTarget","currentTarget","getAttribute","metaKey","ctrlKey","shiftKey","altKey","nativeEvent","which","linkClicked","e","linkInstanceRef","scroll","onNavigate","nodeName","isAnchorNodeName","toUpperCase","hasAttribute","preventDefault","isDefaultPrevented","dispatchNavigateAction","formatStringOrUrl","urlObjOrString","linkStatus","hrefProp","as","asProp","childrenProp","prefetchProp","passHref","shallow","onClick","onMouseEnter","onMouseEnterProp","onTouchStart","onTouchStartProp","legacyBehavior","forwardedRef","unstable_dynamicOnHover","restProps","useContext","AppRouterContext","getFetchStrategyFromPrefetchProp","createPropError","expected","actual","requiredPropsGuard","requiredProps","optionalPropsGuard","optionalProps","valType","resolvedHref","formattedHref","locale","hasDynamicSegment","child","$$typeof","for","Children","only","childRef","observeLinkVisibilityOnMount","mergedRef","childProps","defaultPrevented","upgradeToDynamicPrefetch","__NEXT_LINK_NO_TOUCH_START","cloneElement","LinkStatusContext","Provider","createContext","Mail","height"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,58,59,60,61,62,63,64,65,66,68]}